<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Lincity-ng-commit] r1286 - in trunk/src: lincity lincity/modules	tools
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/lincity-ng-commit/2007-November/index.html" >
   <LINK REL="made" HREF="mailto:lincity-ng-commit%40lists.berlios.de?Subject=Re%3A%20%5BLincity-ng-commit%5D%20r1286%20-%20in%20trunk/src%3A%20lincity%20lincity/modules%0A%09tools&In-Reply-To=%3C200711251915.lAPJFtme021369%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000213.html">
   <LINK REL="Next"  HREF="000214.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Lincity-ng-commit] r1286 - in trunk/src: lincity lincity/modules	tools</H1>
    <B>alainb at BerliOS</B> 
    <A HREF="mailto:lincity-ng-commit%40lists.berlios.de?Subject=Re%3A%20%5BLincity-ng-commit%5D%20r1286%20-%20in%20trunk/src%3A%20lincity%20lincity/modules%0A%09tools&In-Reply-To=%3C200711251915.lAPJFtme021369%40sheep.berlios.de%3E"
       TITLE="[Lincity-ng-commit] r1286 - in trunk/src: lincity lincity/modules	tools">alainb at mail.berlios.de
       </A><BR>
    <I>Sun Nov 25 20:16:59 CET 2007</I>
    <P><UL>
        <LI>Previous message: <A HREF="000213.html">[Lincity-ng-commit] r1285 - in trunk: . src/tools
</A></li>
        <LI>Next message: <A HREF="000214.html">[Lincity-ng-commit] r1287 - in trunk/src/lincity: . modules
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#362">[ date ]</a>
              <a href="thread.html#362">[ thread ]</a>
              <a href="subject.html#362">[ subject ]</a>
              <a href="author.html#362">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: alainb
Date: 2007-11-25 20:15:34 +0100 (Sun, 25 Nov 2007)
New Revision: 1286

Added:
   trunk/src/tools/Lindent.sh
Removed:
   trunk/src/tools/Lindent-2.6.23.8.sh
Modified:
   trunk/src/lincity/confw32.h
   trunk/src/lincity/engglobs.h
   trunk/src/lincity/engine.cpp
   trunk/src/lincity/engine.h
   trunk/src/lincity/fileutil.cpp
   trunk/src/lincity/fileutil.h
   trunk/src/lincity/getopt.cpp
   trunk/src/lincity/lc_common.h
   trunk/src/lincity/lc_locale.cpp
   trunk/src/lincity/lc_locale.h
   trunk/src/lincity/lcconfig.h
   trunk/src/lincity/lclib.cpp
   trunk/src/lincity/lclib.h
   trunk/src/lincity/lcstring.h
   trunk/src/lincity/lctypes.h
   trunk/src/lincity/ldsvguts.cpp
   trunk/src/lincity/ldsvguts.h
   trunk/src/lincity/lin-city.h
   trunk/src/lincity/lintypes.cpp
   trunk/src/lincity/lintypes.h
   trunk/src/lincity/modules/blacksmith.cpp
   trunk/src/lincity/modules/blacksmith.h
   trunk/src/lincity/modules/coal_power.cpp
   trunk/src/lincity/modules/coal_power.h
   trunk/src/lincity/modules/coalmine.cpp
   trunk/src/lincity/modules/coalmine.h
   trunk/src/lincity/modules/commune.cpp
   trunk/src/lincity/modules/commune.h
   trunk/src/lincity/modules/cricket.cpp
   trunk/src/lincity/modules/cricket.h
   trunk/src/lincity/modules/fire.cpp
   trunk/src/lincity/modules/firestation.cpp
   trunk/src/lincity/modules/firestation.h
   trunk/src/lincity/modules/health_centre.cpp
   trunk/src/lincity/modules/health_centre.h
   trunk/src/lincity/modules/heavy_industry.cpp
   trunk/src/lincity/modules/light_industry.cpp
   trunk/src/lincity/modules/market.cpp
   trunk/src/lincity/modules/mill.cpp
   trunk/src/lincity/modules/mill.h
   trunk/src/lincity/modules/monument.cpp
   trunk/src/lincity/modules/monument.h
   trunk/src/lincity/modules/oremine.cpp
   trunk/src/lincity/modules/oremine.h
   trunk/src/lincity/modules/organic_farm.cpp
   trunk/src/lincity/modules/organic_farm.h
   trunk/src/lincity/modules/parkland.cpp
   trunk/src/lincity/modules/port.cpp
   trunk/src/lincity/modules/port.h
   trunk/src/lincity/modules/pottery.cpp
   trunk/src/lincity/modules/pottery.h
   trunk/src/lincity/modules/power_line.cpp
   trunk/src/lincity/modules/power_line.h
   trunk/src/lincity/modules/rail.cpp
   trunk/src/lincity/modules/recycle.cpp
   trunk/src/lincity/modules/recycle.h
   trunk/src/lincity/modules/residence.cpp
   trunk/src/lincity/modules/road.cpp
   trunk/src/lincity/modules/rocket_pad.cpp
   trunk/src/lincity/modules/rocket_pad.h
   trunk/src/lincity/modules/school.cpp
   trunk/src/lincity/modules/school.h
   trunk/src/lincity/modules/shanty.cpp
   trunk/src/lincity/modules/solar_power.cpp
   trunk/src/lincity/modules/substation.cpp
   trunk/src/lincity/modules/substation.h
   trunk/src/lincity/modules/tip.cpp
   trunk/src/lincity/modules/tip.h
   trunk/src/lincity/modules/track.cpp
   trunk/src/lincity/modules/university.cpp
   trunk/src/lincity/modules/water.cpp
   trunk/src/lincity/modules/water.h
   trunk/src/lincity/modules/waterwell.cpp
   trunk/src/lincity/modules/waterwell.h
   trunk/src/lincity/modules/windmill.cpp
   trunk/src/lincity/power.cpp
   trunk/src/lincity/power.h
   trunk/src/lincity/shrglobs.cpp
   trunk/src/lincity/shrtypes.cpp
   trunk/src/lincity/simulate.cpp
   trunk/src/lincity/simulate.h
   trunk/src/lincity/stats.cpp
   trunk/src/lincity/stats.h
   trunk/src/lincity/transport.cpp
   trunk/src/lincity/transport.h
Log:
reformated engine sources src/lincity/

Modified: trunk/src/lincity/confw32.h
===================================================================
--- trunk/src/lincity/confw32.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/confw32.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -2,95 +2,95 @@
  * confw32.h
  * This file is part of lincity.
  * Lincity is copyright (c) I J Peters 1995-1997, (c) Greg Sharp 1997-2001.
- * ---------------------------------------------------------------------- */
+ * ---------------------------------------------------------------------- */  
 /* This is a config.h file that has been hacked for VC++ 4.0.  You'll 
  * probably need to change if you are using a different compiler.
- * ---------------------------------------------------------------------- */
-
-/* Define to empty if the keyword does not work.  */
-/* #undef const */
-
-/* Define if you have locale.h */
+ * ---------------------------------------------------------------------- */ 
+    
+/* Define to empty if the keyword does not work.  */ 
+/* #undef const */ 
+    
+/* Define if you have locale.h */ 
 #define HAVE_LOCALE_H
-
-/* Define if you want to enable foreign language support */
+    
+/* Define if you want to enable foreign language support */ 
 #undef ENABLE_NLS
-/* #define ENABLE_NLS */
-
-/* Define as __inline if that's what the C compiler calls it.  */
+/* #define ENABLE_NLS */ 
+    
+/* Define as __inline if that's what the C compiler calls it.  */ 
 #define inline __inline
-
-/* This is not yet fixed for UNIX...  */
-/* #define snprintf _snprintf */
-
-/* Define if you need to in order for stat and other things to work.  */
-/* #undef _POSIX_SOURCE */
-
-/* Define if you have the ANSI C header files.  */
-/* #undef STDC_HEADERS */
-
-/* Define if you can safely include both &lt;sys/time.h&gt; and &lt;time.h&gt;.  */
-/* #undef TIME_WITH_SYS_TIME */
-
-/* Define if the X Window System is missing or not being used.  */
-/* #undef X_DISPLAY_MISSING */
-
-/* Define if save files should be compressed with gzip.  */
-/* #undef HAVE_GZIP */
-
-/* The number of bytes in a char.  */
+    
+/* This is not yet fixed for UNIX...  */ 
+/* #define snprintf _snprintf */ 
+    
+/* Define if you need to in order for stat and other things to work.  */ 
+/* #undef _POSIX_SOURCE */ 
+    
+/* Define if you have the ANSI C header files.  */ 
+/* #undef STDC_HEADERS */ 
+    
+/* Define if you can safely include both &lt;sys/time.h&gt; and &lt;time.h&gt;.  */ 
+/* #undef TIME_WITH_SYS_TIME */ 
+    
+/* Define if the X Window System is missing or not being used.  */ 
+/* #undef X_DISPLAY_MISSING */ 
+    
+/* Define if save files should be compressed with gzip.  */ 
+/* #undef HAVE_GZIP */ 
+    
+/* The number of bytes in a char.  */ 
 #define SIZEOF_CHAR 1
-
-/* The number of bytes in a int.  */
+    
+/* The number of bytes in a int.  */ 
 #define SIZEOF_INT 4
-
-/* The number of bytes in a long.  */
+    
+/* The number of bytes in a long.  */ 
 #define SIZEOF_LONG 4
-
-/* The number of bytes in a short.  */
+    
+/* The number of bytes in a short.  */ 
 #define SIZEOF_SHORT 2
-
-/* Define if you have the gettimeofday function.  */
-/* #undef HAVE_GETTIMEOFDAY */
-
-/* Define if you have the mkdir function.  */
-/* #undef HAVE_MKDIR */
-
-/* Define if you have the popen function.  */
-/* #undef HAVE_POPEN */
-
-/* Define if you have the select function.  */
-/* #undef HAVE_SELECT */
-
-/* Define if you have the &lt;dirent.h&gt; header file.  */
-/* #undef HAVE_DIRENT_H */
-
-/* Define if you have the &lt;ndir.h&gt; header file.  */
-/* #undef HAVE_NDIR_H */
-
-/* Define if you have the &lt;string.h&gt; header file.  */
+    
+/* Define if you have the gettimeofday function.  */ 
+/* #undef HAVE_GETTIMEOFDAY */ 
+    
+/* Define if you have the mkdir function.  */ 
+/* #undef HAVE_MKDIR */ 
+    
+/* Define if you have the popen function.  */ 
+/* #undef HAVE_POPEN */ 
+    
+/* Define if you have the select function.  */ 
+/* #undef HAVE_SELECT */ 
+    
+/* Define if you have the &lt;dirent.h&gt; header file.  */ 
+/* #undef HAVE_DIRENT_H */ 
+    
+/* Define if you have the &lt;ndir.h&gt; header file.  */ 
+/* #undef HAVE_NDIR_H */ 
+    
+/* Define if you have the &lt;string.h&gt; header file.  */ 
 #define HAVE_STRING_H 1
-
-/* Define if you have the &lt;strings.h&gt; header file.  */
-/* #undef HAVE_STRINGS_H */
-
-/* Define if you have the &lt;sys/dir.h&gt; header file.  */
-/* #undef HAVE_SYS_DIR_H */
-
-/* Define if you have the &lt;sys/ndir.h&gt; header file.  */
-/* #undef HAVE_SYS_NDIR_H */
-
-/* Define if you have the &lt;sys/time.h&gt; header file.  */
-/* #undef HAVE_SYS_TIME_H */
-
-/* Define if you have the &lt;unistd.h&gt; header file.  */
-/* #undef HAVE_UNISTD_H */
-
-/* Define if you have the &lt;vga.h&gt; header file.  */
-/* #undef HAVE_VGA_H */
-
-/* Name of package */
+    
+/* Define if you have the &lt;strings.h&gt; header file.  */ 
+/* #undef HAVE_STRINGS_H */ 
+    
+/* Define if you have the &lt;sys/dir.h&gt; header file.  */ 
+/* #undef HAVE_SYS_DIR_H */ 
+    
+/* Define if you have the &lt;sys/ndir.h&gt; header file.  */ 
+/* #undef HAVE_SYS_NDIR_H */ 
+    
+/* Define if you have the &lt;sys/time.h&gt; header file.  */ 
+/* #undef HAVE_SYS_TIME_H */ 
+    
+/* Define if you have the &lt;unistd.h&gt; header file.  */ 
+/* #undef HAVE_UNISTD_H */ 
+    
+/* Define if you have the &lt;vga.h&gt; header file.  */ 
+/* #undef HAVE_VGA_H */ 
+    
+/* Name of package */ 
 #define PACKAGE &quot;lincity&quot;
-
-/* Version number of package */
+    
+/* Version number of package */ 
 #define VERSION &quot;1.13.2&quot;

Modified: trunk/src/lincity/engglobs.h
===================================================================
--- trunk/src/lincity/engglobs.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/engglobs.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -13,8 +13,7 @@
 extern int use_waterwell, ldsv_version;
 
 /* GCS -- One of these days I will get this right. */
-struct map_struct
-{
+struct map_struct {
     short type[WORLD_SIDE_LEN][WORLD_SIDE_LEN];
     short group[WORLD_SIDE_LEN][WORLD_SIDE_LEN];
     int pollution[WORLD_SIDE_LEN][WORLD_SIDE_LEN];
@@ -32,7 +31,7 @@
 #define MP_SIZE(x,y)   main_groups[MP_GROUP(x,y)].size
 #define MP_COLOR(x,y)  main_groups[MP_GROUP(x,y)].colour
 #define MP_GROUP_IS_RESIDENCE(x,y)  (GROUP_IS_RESIDENCE(MP_GROUP(x,y)))
-#define HAS_UGWATER(x,y) (MP_INFO(x,y).flags &amp; FLAG_HAS_UNDERGROUND_WATER) 
+#define HAS_UGWATER(x,y) (MP_INFO(x,y).flags &amp; FLAG_HAS_UNDERGROUND_WATER)
 
 extern int mappoint_array_x[WORLD_SIDE_LEN], mappoint_array_y[WORLD_SIDE_LEN];
 extern int numof_shanties, numof_communes;
@@ -43,7 +42,7 @@
 extern int sust_old_money_count, sust_old_population, sust_old_population_count;
 extern int sust_old_tech, sust_old_tech_count, sust_fire_count;
 
-extern int total_time;    /* game time */
+extern int total_time;          /* game time */
 
 extern int population, starving_population;
 extern int housed_population;

Modified: trunk/src/lincity/engine.cpp
===================================================================
--- trunk/src/lincity/engine.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/engine.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -26,25 +26,24 @@
 #include &quot;gui_interface/shared_globals.h&quot;
 
 extern int selected_type_cost;
-static void bulldoze_mappoint (short fill, int x, int y);
-int is_real_river (int x, int y);
+static void bulldoze_mappoint(short fill, int x, int y);
+int is_real_river(int x, int y);
 
 int last_warning_message_group = 0;
 
-void
-fire_area (int xx, int yy)
+void fire_area(int xx, int yy)
 {
     /* this happens when a rocket crashes or on random_fire. */
     int x = xx;
     int y = yy;
     int size;
-    if (MP_GROUP(x,y) == GROUP_WATER || MP_GROUP(x,y) == GROUP_FIRE)
+    if (MP_GROUP(x, y) == GROUP_WATER || MP_GROUP(x, y) == GROUP_FIRE)
         return;
-    if (MP_TYPE(x,y) == CST_USED) {
-        x = MP_INFO(xx,yy).int_1;
-        y = MP_INFO(xx,yy).int_2;
+    if (MP_TYPE(x, y) == CST_USED) {
+        x = MP_INFO(xx, yy).int_1;
+        y = MP_INFO(xx, yy).int_2;
     }
-    size = MP_SIZE(x,y);
+    size = MP_SIZE(x, y);
 
     /* Destroy the content of the building to prevent special management
      * when bulldozed.
@@ -53,138 +52,133 @@
     /* Kill 'only' half of the people (bulldoze item put them in people_pool)
      * lincity NG 1.1 and previous killed all the people!
      */
-    if ((MP_INFO(x,y).flags &amp; FLAG_FIRE_COVER) !=0)
-        MP_INFO(x,y).population = MP_INFO(x,y).population / 2;
+    if ((MP_INFO(x, y).flags &amp; FLAG_FIRE_COVER) != 0)
+        MP_INFO(x, y).population = MP_INFO(x, y).population / 2;
     else
-        MP_INFO(x,y).population = 0;
-    MP_INFO(x,y).flags = 0;
-    MP_INFO(x,y).int_1 = 0;
-    MP_INFO(x,y).int_2 = 0;
-    MP_INFO(x,y).int_3 = 0;
-    MP_INFO(x,y).int_4 = 0;
-    MP_INFO(x,y).int_5 = 0;
-    MP_INFO(x,y).int_6 = 0;
-    MP_INFO(x,y).int_7 = 0;
+        MP_INFO(x, y).population = 0;
+    MP_INFO(x, y).flags = 0;
+    MP_INFO(x, y).int_1 = 0;
+    MP_INFO(x, y).int_2 = 0;
+    MP_INFO(x, y).int_3 = 0;
+    MP_INFO(x, y).int_4 = 0;
+    MP_INFO(x, y).int_5 = 0;
+    MP_INFO(x, y).int_6 = 0;
+    MP_INFO(x, y).int_7 = 0;
 
     /* Correctly remove buildings (substations...) and adjust count,
      * but don't count bulldoze cost
      * */
-    adjust_money(+main_groups[MP_GROUP(x,y)].bul_cost);
+    adjust_money(+main_groups[MP_GROUP(x, y)].bul_cost);
     bulldoze_item(x, y);
 
     /* put fire */
     for (int i = 0; i &lt; size; i++)
         for (int j = 0; j &lt; size; j++) {
-            bulldoze_mappoint (CST_FIRE_1, x + i, y + j);
+            bulldoze_mappoint(CST_FIRE_1, x + i, y + j);
             MP_GROUP(x + i, y + j) = GROUP_FIRE;
         }
 
-
     /* AL1: is it necessary ? It is the only place in lincity/. with such a call
      *  all other are in lincity-ng/.
      */
-    refresh_main_screen ();
+    refresh_main_screen();
 
-  /* 
-    // update transport or we get stuff put in
-    // the area from connected tracks etc.
-    // FIXME: AL1: NG 1.1: do the right thing and/or remove this comment
-  */
+    /* 
+       // update transport or we get stuff put in
+       // the area from connected tracks etc.
+       // FIXME: AL1: NG 1.1: do the right thing and/or remove this comment
+     */
 }
 
-int 
-adjust_money(int value)
+int adjust_money(int value)
 {
     total_money += value;
     print_total_money();
     mps_update();
-    update_pbar (PMONEY, total_money, 0);
-    refresh_pbars(); /* This could be more specific */
+    update_pbar(PMONEY, total_money, 0);
+    refresh_pbars();            /* This could be more specific */
     return total_money;
 }
 
-int
-no_credit_build (int selected_group)
+int no_credit_build(int selected_group)
 {
-  if (total_money &gt;= 0)
-    return (0);
+    if (total_money &gt;= 0)
+        return (0);
 
 #ifdef GROUP_SOLAR_POWER_NO_CREDIT
-  if (selected_group == GROUP_SOLAR_POWER) {
-    return (1);
-  }
+    if (selected_group == GROUP_SOLAR_POWER) {
+        return (1);
+    }
 #endif
 #ifdef GROUP_UNIVERSITY_NO_CREDIT
-  if (selected_group == GROUP_UNIVERSITY) {
-    return (1);
-  }
+    if (selected_group == GROUP_UNIVERSITY) {
+        return (1);
+    }
 #endif
 #ifdef GROUP_PARKLAND_NO_CREDIT
-  if (selected_group == GROUP_PARKLAND) {
-    return (1);
-  }
+    if (selected_group == GROUP_PARKLAND) {
+        return (1);
+    }
 #endif
 #ifdef GROUP_RECYCLE_NO_CREDIT
-  if (selected_group == GROUP_RECYCLE) {
-    return (1);
-  }
+    if (selected_group == GROUP_RECYCLE) {
+        return (1);
+    }
 #endif
 #ifdef GROUP_ROCKET
-  if (selected_group == GROUP_ROCKET) {
-    return (1);
-  }
+    if (selected_group == GROUP_ROCKET) {
+        return (1);
+    }
 #endif
 
-  if (main_groups[selected_group].no_credit == TRUE ) {
-    return (1);
-  }
-  return (0);
+    if (main_groups[selected_group].no_credit == TRUE) {
+        return (1);
+    }
+    return (0);
 }
 
-void 
-no_credit_build_msg_ng (int selected_group)
+void no_credit_build_msg_ng(int selected_group)
 {
-  if (last_warning_message_group == selected_group)
+    if (last_warning_message_group == selected_group)
         return;
-  last_warning_message_group = selected_group;
+    last_warning_message_group = selected_group;
 
 #ifdef GROUP_SOLAR_POWER_NO_CREDIT
-  if (selected_group == GROUP_SOLAR_POWER) {
-    ok_dial_box (&quot;no-credit-solar-power.mes&quot;, BAD, 0L);
-    return;
-  }
+    if (selected_group == GROUP_SOLAR_POWER) {
+        ok_dial_box(&quot;no-credit-solar-power.mes&quot;, BAD, 0L);
+        return;
+    }
 #endif
 #ifdef GROUP_UNIVERSITY_NO_CREDIT
-  if (selected_group == GROUP_UNIVERSITY) {
-    ok_dial_box (&quot;no-credit-university.mes&quot;, BAD, 0L);
-    return;
-  }
+    if (selected_group == GROUP_UNIVERSITY) {
+        ok_dial_box(&quot;no-credit-university.mes&quot;, BAD, 0L);
+        return;
+    }
 #endif
 #ifdef GROUP_PARKLAND_NO_CREDIT
-  if (selected_group == GROUP_PARKLAND) {
-    ok_dial_box (&quot;no-credit-parkland.mes&quot;, BAD, 0L);
-    return;
-  }
+    if (selected_group == GROUP_PARKLAND) {
+        ok_dial_box(&quot;no-credit-parkland.mes&quot;, BAD, 0L);
+        return;
+    }
 #endif
 #ifdef GROUP_RECYCLE_NO_CREDIT
-  if (selected_group == GROUP_RECYCLE) {
-    ok_dial_box (&quot;no-credit-recycle.mes&quot;, BAD, 0L);
-    return;
-  }
+    if (selected_group == GROUP_RECYCLE) {
+        ok_dial_box(&quot;no-credit-recycle.mes&quot;, BAD, 0L);
+        return;
+    }
 #endif
 #ifdef GROUP_ROCKET
-  if (selected_group == GROUP_ROCKET) {
-    ok_dial_box (&quot;no-credit-rocket.mes&quot;, BAD, 0L);
-    return;
-  }
+    if (selected_group == GROUP_ROCKET) {
+        ok_dial_box(&quot;no-credit-rocket.mes&quot;, BAD, 0L);
+        return;
+    }
 #endif
-  return;
+    return;
 }
 
-int 
-place_item (int x, int y, short type)
+int place_item(int x, int y, short type)
 {
-    int i,j;
+    int i, j;
     int prev_tip = 0;
     int group;
     int size;
@@ -192,522 +186,485 @@
     group = get_group_of_type(type);
     if (group &lt; 0) {
 #ifdef DEBUG
-        fprintf(stderr,&quot;Error: group does not exist %i\n&quot;, group);
+        fprintf(stderr, &quot;Error: group does not exist %i\n&quot;, group);
 #endif
-        ok_dial_box (&quot;warning.mes&quot;, BAD,
-                _(&quot;ERROR: group does not exist. This should not happen! Please consider filling a bug report to lincity-ng team, with the saved game and what you did :-) &quot;));
+        ok_dial_box(&quot;warning.mes&quot;, BAD,
+                    _
+                    (&quot;ERROR: group does not exist. This should not happen! Please consider filling a bug report to lincity-ng team, with the saved game and what you did :-) &quot;));
         return -1000;
     }
 
     size = main_groups[group].size;
 
     /* You can't build because credit not available. */
-    if (no_credit_build (group) != 0) {
-        no_credit_build_msg_ng (group);
-	return -1;
+    if (no_credit_build(group) != 0) {
+        no_credit_build_msg_ng(group);
+        return -1;
     }
 
     switch (group) {
     case GROUP_ORGANIC_FARM:
-	MP_INFO(x,y).int_1 = tech_level;
+        MP_INFO(x, y).int_1 = tech_level;
         break;
     case GROUP_TRACK:
     case GROUP_ROAD:
     case GROUP_RAIL:
-	MP_INFO(x,y).flags |= FLAG_IS_TRANSPORT;
+        MP_INFO(x, y).flags |= FLAG_IS_TRANSPORT;
         break;
     case GROUP_PORT:
-	if (is_real_river (x + 4, y) != 1 
-	        || is_real_river (x + 4, y + 1) != 1
-	        || is_real_river (x + 4, y + 2) != 1 
-	        || is_real_river (x + 4, y + 3) != 1) {
+        if (is_real_river(x + 4, y) != 1
+            || is_real_river(x + 4, y + 1) != 1
+            || is_real_river(x + 4, y + 2) != 1 || is_real_river(x + 4, y + 3) != 1) {
             if (last_warning_message_group != group)
-                ok_dial_box (&quot;warning.mes&quot;, BAD,
-                    _(&quot;Port must be connected to river all along right side.&quot;));
+                ok_dial_box(&quot;warning.mes&quot;, BAD, _(&quot;Port must be connected to river all along right side.&quot;));
             last_warning_message_group = group;
             return -2;
         }
         break;
     case GROUP_SUBSTATION:
-        if (add_a_substation (x, y) == 0) {
+        if (add_a_substation(x, y) == 0) {
             /* Not enough slots in the substation array */
             if (last_warning_message_group != group)
-                ok_dial_box (&quot;warning.mes&quot;, BAD,
-                    _(&quot;Too many substations + windmills. You cannot build one more&quot;));
+                ok_dial_box(&quot;warning.mes&quot;, BAD, _(&quot;Too many substations + windmills. You cannot build one more&quot;));
             last_warning_message_group = group;
-	    return -3;
+            return -3;
         }
         break;
     case GROUP_WINDMILL:
-	if (add_a_substation (x, y) == 0) {
+        if (add_a_substation(x, y) == 0) {
             /* Not enough slots in the substation array */
             if (last_warning_message_group != group)
-                ok_dial_box (&quot;warning.mes&quot;, BAD,
-                    _(&quot;Too many substations + windmills. You cannot build one more&quot;));
+                ok_dial_box(&quot;warning.mes&quot;, BAD, _(&quot;Too many substations + windmills. You cannot build one more&quot;));
             last_warning_message_group = group;
-	    return -3;
+            return -3;
         }
-        MP_INFO(x,y).int_2 = tech_level;
-        MP_INFO(x,y).int_1 = (int)(WINDMILL_POWER
-	        + (((double) MP_INFO(x,y).int_2 * WINDMILL_POWER) / MAX_TECH_LEVEL));
+        MP_INFO(x, y).int_2 = tech_level;
+        MP_INFO(x, y).int_1 = (int)(WINDMILL_POWER + (((double)MP_INFO(x, y).int_2 * WINDMILL_POWER) / MAX_TECH_LEVEL));
         /* Make sure that the correct windmill graphic shows up */
-	if (tech_level &gt; MODERN_WINDMILL_TECH)
-	    type = CST_WINDMILL_1_R;
-	else 
-	    type = CST_WINDMILL_1_W;
+        if (tech_level &gt; MODERN_WINDMILL_TECH)
+            type = CST_WINDMILL_1_R;
+        else
+            type = CST_WINDMILL_1_W;
         break;
     case (GROUP_COAL_POWER):
-        MP_INFO(x,y).int_4 = tech_level;
-        MP_INFO(x,y).int_1 = (int)(POWERS_COAL_OUTPUT
-	        + (((double) MP_INFO(x,y).int_4 * POWERS_COAL_OUTPUT)
-	                / MAX_TECH_LEVEL));
+        MP_INFO(x, y).int_4 = tech_level;
+        MP_INFO(x, y).int_1 = (int)(POWERS_COAL_OUTPUT + (((double)MP_INFO(x, y).int_4 * POWERS_COAL_OUTPUT)
+                                                          / MAX_TECH_LEVEL));
         break;
     case (GROUP_SOLAR_POWER):
- 	MP_INFO(x,y).int_2 = tech_level;
-        MP_INFO(x,y).int_1 = (int)(POWERS_SOLAR_OUTPUT
-	        + (((double) MP_INFO(x,y).int_2 * POWERS_SOLAR_OUTPUT)
-	                / MAX_TECH_LEVEL)); /* like other power sources */
-        MP_INFO(x,y).int_3 = MP_INFO(x,y).int_1; /* Int_3 is kept for compatibility */
+        MP_INFO(x, y).int_2 = tech_level;
+        MP_INFO(x, y).int_1 = (int)(POWERS_SOLAR_OUTPUT + (((double)MP_INFO(x, y).int_2 * POWERS_SOLAR_OUTPUT)
+                                                           / MAX_TECH_LEVEL));  /* like other power sources */
+        MP_INFO(x, y).int_3 = MP_INFO(x, y).int_1;      /* Int_3 is kept for compatibility */
         break;
     case GROUP_COMMUNE:
-	numof_communes++;
+        numof_communes++;
         break;
     case GROUP_MARKET:
-	/* Test for enough slots in the market array */
-	if (add_a_market (x, y) == 0) {
+        /* Test for enough slots in the market array */
+        if (add_a_market(x, y) == 0) {
             if (last_warning_message_group != group)
-                ok_dial_box (&quot;warning.mes&quot;, BAD,
-                        _(&quot;Too many markets. You cannot build one more&quot;));
+                ok_dial_box(&quot;warning.mes&quot;, BAD, _(&quot;Too many markets. You cannot build one more&quot;));
             last_warning_message_group = group;
-	    return -4;
+            return -4;
         }
-	MP_INFO(x,y).flags += (FLAG_MB_FOOD | FLAG_MB_JOBS
-			       | FLAG_MB_COAL | FLAG_MB_ORE | FLAG_MB_STEEL
-			       | FLAG_MB_GOODS | FLAG_MS_FOOD | FLAG_MS_JOBS
-			       | FLAG_MS_COAL | FLAG_MS_GOODS | FLAG_MS_ORE
-			       | FLAG_MS_STEEL);
+        MP_INFO(x, y).flags += (FLAG_MB_FOOD | FLAG_MB_JOBS
+                                | FLAG_MB_COAL | FLAG_MB_ORE | FLAG_MB_STEEL
+                                | FLAG_MB_GOODS | FLAG_MS_FOOD | FLAG_MS_JOBS
+                                | FLAG_MS_COAL | FLAG_MS_GOODS | FLAG_MS_ORE | FLAG_MS_STEEL);
         break;
     case GROUP_RECYCLE:
-        MP_INFO(x,y).int_4 = tech_level;
+        MP_INFO(x, y).int_4 = tech_level;
         break;
     case GROUP_TIP:
-	/* Don't build a tip if there has already been one.  If we succeed,
-	   mark the spot permanently by &quot;doubling&quot; the ore reserve */
-	prev_tip = 0;
-	for (i=0; i &lt; size; i++)
-	    for (j=0; j &lt; size; j++)
-		if (MP_INFO(x+i,y+j).ore_reserve &gt; ORE_RESERVE) {
-		    prev_tip = 1;
-		    break;
-		}
-	if (prev_tip) {
-	    ok_dial_box (&quot;warning.mes&quot;, BAD,
-                    _(&quot;You can't build a tip here: this area was once a landfill&quot;));
-	    return -5;
-	} else {
-	    for (i=0; i &lt; size; i++)
-		for (j=0; j &lt; size; j++)
-		    MP_INFO(x+i,y+j).ore_reserve = ORE_RESERVE * 2;
-	}
+        /* Don't build a tip if there has already been one.  If we succeed,
+           mark the spot permanently by &quot;doubling&quot; the ore reserve */
+        prev_tip = 0;
+        for (i = 0; i &lt; size; i++)
+            for (j = 0; j &lt; size; j++)
+                if (MP_INFO(x + i, y + j).ore_reserve &gt; ORE_RESERVE) {
+                    prev_tip = 1;
+                    break;
+                }
+        if (prev_tip) {
+            ok_dial_box(&quot;warning.mes&quot;, BAD, _(&quot;You can't build a tip here: this area was once a landfill&quot;));
+            return -5;
+        } else {
+            for (i = 0; i &lt; size; i++)
+                for (j = 0; j &lt; size; j++)
+                    MP_INFO(x + i, y + j).ore_reserve = ORE_RESERVE * 2;
+        }
         break;
     case GROUP_OREMINE:
-    {
-	/* Don't allow new mines on old mines or old tips */
-	/* GCS: mines over old mines is OK if there is enough remaining 
-	        ore, as is the case when there is partial overlap. */
-	int total_ore = 0;
-	prev_tip = 0;
-	for (i=0;i&lt;size;i++) {
-	    for (j=0;j&lt;size;j++) {
-		total_ore += MP_INFO(x+i,y+j).ore_reserve;
-		if (MP_INFO(x+i,y+j).ore_reserve &gt; ORE_RESERVE) {
-		    prev_tip = 1;
-		    break;
-		}
-	    }
-	}
-	if (prev_tip) {
-	    ok_dial_box (&quot;warning.mes&quot;, BAD,
-                    _(&quot;You can't build a mine here: This area was once a landfill&quot;));
-	    return -6;
-	}
-	if (total_ore &lt; MIN_ORE_RESERVE_FOR_MINE) {
-	    ok_dial_box(&quot;warning.mes&quot;, BAD,
-                    _(&quot;You can't build a mine here: there is no ore left at this site&quot;));
-	    return -7;
-	}
-        break;
-    } 
+        {
+            /* Don't allow new mines on old mines or old tips */
+            /* GCS: mines over old mines is OK if there is enough remaining 
+               ore, as is the case when there is partial overlap. */
+            int total_ore = 0;
+            prev_tip = 0;
+            for (i = 0; i &lt; size; i++) {
+                for (j = 0; j &lt; size; j++) {
+                    total_ore += MP_INFO(x + i, y + j).ore_reserve;
+                    if (MP_INFO(x + i, y + j).ore_reserve &gt; ORE_RESERVE) {
+                        prev_tip = 1;
+                        break;
+                    }
+                }
+            }
+            if (prev_tip) {
+                ok_dial_box(&quot;warning.mes&quot;, BAD, _(&quot;You can't build a mine here: This area was once a landfill&quot;));
+                return -6;
+            }
+            if (total_ore &lt; MIN_ORE_RESERVE_FOR_MINE) {
+                ok_dial_box(&quot;warning.mes&quot;, BAD, _(&quot;You can't build a mine here: there is no ore left at this site&quot;));
+                return -7;
+            }
+            break;
+        }
     case GROUP_WATERWELL:
         if (use_waterwell) {
-            int has_ugw=0;
-            for (i=0;i&lt;size;i++) 
-                for (j=0;j&lt;size;j++) 
-                    has_ugw = has_ugw | HAS_UGWATER(x+i, y+j);
+            int has_ugw = 0;
+            for (i = 0; i &lt; size; i++)
+                for (j = 0; j &lt; size; j++)
+                    has_ugw = has_ugw | HAS_UGWATER(x + i, y + j);
             if (!has_ugw) {
-                ok_dial_box(&quot;warning.mes&quot;, BAD,
-                        _(&quot;You can't build a water well here: it is all desert.&quot;));
+                ok_dial_box(&quot;warning.mes&quot;, BAD, _(&quot;You can't build a water well here: it is all desert.&quot;));
                 return -8;
             } else {
                 numof_waterwell++;
             }
-        } /* else ... is not possible */
+        }                       /* else ... is not possible */
         break;
     case GROUP_PARKLAND:
         if (use_waterwell)
-            if (!HAS_UGWATER(x,y)) {
-                ok_dial_box(&quot;warning.mes&quot;, BAD,
-                        _(&quot;You can't build a park here: it is a desert, parks need water&quot;));
+            if (!HAS_UGWATER(x, y)) {
+                ok_dial_box(&quot;warning.mes&quot;, BAD, _(&quot;You can't build a park here: it is a desert, parks need water&quot;));
                 return -8;
             }
 
-    } /* end case */
+    }                           /* end case */
     last_warning_message_group = 0;
 
     /* Store last_built for refund on &quot;mistakes&quot; */
     last_built_x = x;
     last_built_y = y;
 
-    set_mappoint (x, y, type);
+    set_mappoint(x, y, type);
 
     if (group == GROUP_RIVER)
-	connect_rivers ();
+        connect_rivers();
 
-    connect_transport (x-2,y-2,x+size+1,y+size+1);
+    connect_transport(x - 2, y - 2, x + size + 1, y + size + 1);
 
     adjust_money(-selected_module_cost);
     map_power_grid();
     return 0;
 }
 
-int 
-bulldoze_item (int x, int y)
+int bulldoze_item(int x, int y)
 {
     int g, size;
 
-    if (MP_TYPE(x,y) == CST_USED) {
-	/* This is considered &quot;improper&quot; input.  Silently ignore. */
+    if (MP_TYPE(x, y) == CST_USED) {
+        /* This is considered &quot;improper&quot; input.  Silently ignore. */
 #ifdef DEBUG
-        fprintf(stderr,&quot; try to improperly bulldoze_item CST_USED\n&quot;);
+        fprintf(stderr, &quot; try to improperly bulldoze_item CST_USED\n&quot;);
 #endif
-	return -1;
+        return -1;
     }
 
-    size = MP_SIZE(x,y);
-    g = MP_GROUP(x,y);
-    people_pool += MP_INFO(x,y).population;
+    size = MP_SIZE(x, y);
+    g = MP_GROUP(x, y);
+    people_pool += MP_INFO(x, y).population;
 
     if (g == GROUP_DESERT) {
-	/* Nothing to do. */
-	return -1;
-    }
-    else if (g == GROUP_SHANTY) {
-	remove_a_shanty(x, y);
-	adjust_money(-GROUP_SHANTY_BUL_COST);
+        /* Nothing to do. */
+        return -1;
+    } else if (g == GROUP_SHANTY) {
+        remove_a_shanty(x, y);
+        adjust_money(-GROUP_SHANTY_BUL_COST);
         numof_shanties--;
-    }
-    else if (g == GROUP_FIRE) {
-	if (MP_INFO(x,y).int_2 &gt;= FIRE_LENGTH)
-	    return -1;  /* Can't bulldoze ? */
-	MP_INFO(x,y).int_2 = FIRE_LENGTH + 1;
-	MP_TYPE(x,y) = CST_FIRE_DONE1;
-	MP_GROUP(x,y) = GROUP_BURNT;
-	adjust_money(-GROUP_BURNT_BUL_COST);
-    }
-    else {
-	adjust_money(-main_groups[g].bul_cost);
-         
+    } else if (g == GROUP_FIRE) {
+        if (MP_INFO(x, y).int_2 &gt;= FIRE_LENGTH)
+            return -1;          /* Can't bulldoze ? */
+        MP_INFO(x, y).int_2 = FIRE_LENGTH + 1;
+        MP_TYPE(x, y) = CST_FIRE_DONE1;
+        MP_GROUP(x, y) = GROUP_BURNT;
+        adjust_money(-GROUP_BURNT_BUL_COST);
+    } else {
+        adjust_money(-main_groups[g].bul_cost);
+
         if (g == GROUP_COMMUNE)
-             numof_communes--;
+            numof_communes--;
 
         if (g == GROUP_MARKET)
-            remove_a_market (x, y);
- 
+            remove_a_market(x, y);
+
         if (g == GROUP_SUBSTATION || g == GROUP_WINDMILL)
-             remove_a_substation (x, y);
- 
-	if (g == GROUP_OREMINE)	{
-	    int i, j;
-	    for (j = 0; j &lt; 4; j++)
-		for (i = 0; i &lt; 4; i++)
-		    if (MP_INFO(x + i,y + j).ore_reserve &lt; ORE_RESERVE / 2)
-			do_bulldoze_area (CST_WATER, x + i, y + j);
-	} else {
+            remove_a_substation(x, y);
+
+        if (g == GROUP_OREMINE) {
+            int i, j;
+            for (j = 0; j &lt; 4; j++)
+                for (i = 0; i &lt; 4; i++)
+                    if (MP_INFO(x + i, y + j).ore_reserve &lt; ORE_RESERVE / 2)
+                        do_bulldoze_area(CST_WATER, x + i, y + j);
+        } else {
             /* keep compatibility for saving pre_waterwell loaded game */
             if (use_waterwell)
-                do_bulldoze_area (CST_DESERT, x, y);
+                do_bulldoze_area(CST_DESERT, x, y);
             else
-                do_bulldoze_area (CST_GREEN, x, y);
+                do_bulldoze_area(CST_GREEN, x, y);
         }
     }
 
     /* Tell mps about it, in case its selected */
     mps_update();
-    return size;  /* No longer used... */
+    return size;                /* No longer used... */
 }
 
-void
-do_bulldoze_area (short fill, int xx, int yy)
+void do_bulldoze_area(short fill, int xx, int yy)
 {
-  int size, x, y;
-  if (MP_TYPE(xx,yy) == CST_USED)
-    {
-      x = MP_INFO(xx,yy).int_1;
-      y = MP_INFO(xx,yy).int_2;
+    int size, x, y;
+    if (MP_TYPE(xx, yy) == CST_USED) {
+        x = MP_INFO(xx, yy).int_1;
+        y = MP_INFO(xx, yy).int_2;
+    } else {
+        x = xx;
+        y = yy;
     }
-  else
-    {
-      x = xx;
-      y = yy;
-    }
-  size = MP_SIZE(x,y);
-  for (int i = 0; i &lt; size; i++)
-      for (int j = 0; j &lt; size; j++)  
-          bulldoze_mappoint (fill, x+i, y+j);
+    size = MP_SIZE(x, y);
+    for (int i = 0; i &lt; size; i++)
+        for (int j = 0; j &lt; size; j++)
+            bulldoze_mappoint(fill, x + i, y + j);
 }
 
-static void 
-bulldoze_mappoint (short fill, int x, int y)
+static void bulldoze_mappoint(short fill, int x, int y)
 {
     /* bulldoze preserve underground resources */
-    MP_TYPE(x,y) = fill;
-    MP_GROUP(x,y) = get_group_of_type(fill);
-    if (MP_GROUP(x,y) &lt; 0)
-        MP_GROUP(x,y) = GROUP_BARE;
-    MP_INFO(x,y).population = 0;
-    MP_INFO(x,y).flags &amp;= FLAG_HAS_UNDERGROUND_WATER;
-    MP_INFO(x,y).int_1 = 0;
-    MP_INFO(x,y).int_2 = 0;
-    MP_INFO(x,y).int_3 = 0;
-    MP_INFO(x,y).int_4 = 0;
-    MP_INFO(x,y).int_5 = 0;
-    MP_INFO(x,y).int_6 = 0;
-    MP_INFO(x,y).int_7 = 0;
+    MP_TYPE(x, y) = fill;
+    MP_GROUP(x, y) = get_group_of_type(fill);
+    if (MP_GROUP(x, y) &lt; 0)
+        MP_GROUP(x, y) = GROUP_BARE;
+    MP_INFO(x, y).population = 0;
+    MP_INFO(x, y).flags &amp;= FLAG_HAS_UNDERGROUND_WATER;
+    MP_INFO(x, y).int_1 = 0;
+    MP_INFO(x, y).int_2 = 0;
+    MP_INFO(x, y).int_3 = 0;
+    MP_INFO(x, y).int_4 = 0;
+    MP_INFO(x, y).int_5 = 0;
+    MP_INFO(x, y).int_6 = 0;
+    MP_INFO(x, y).int_7 = 0;
 }
 
 /** Mappoint array shuffles mappoint in order to stop linear simulation effects */
 
 /** this is called on startup */
-void init_mappoint_array (void)
+void init_mappoint_array(void)
 {
     int x;
     for (x = 0; x &lt; WORLD_SIDE_LEN; x++) {
-	mappoint_array_x[x] = x;
-	mappoint_array_y[x] = x;
+        mappoint_array_x[x] = x;
+        mappoint_array_y[x] = x;
     }
 }
 
 /** this is called at the beginning of every frame */
-void shuffle_mappoint_array (void)
+void shuffle_mappoint_array(void)
 {
-  int i, x, a;
-  for (i = 0; i &lt; SHUFFLE_MAPPOINT_COUNT; i++)
-    {
-      x = rand () % WORLD_SIDE_LEN;
-      a = mappoint_array_x[i];
-      mappoint_array_x[i] = mappoint_array_x[x];
-      mappoint_array_x[x] = a;
-      x = rand () % WORLD_SIDE_LEN;
-      a = mappoint_array_y[i];
-      mappoint_array_y[i] = mappoint_array_y[x];
-      mappoint_array_y[x] = a;
+    int i, x, a;
+    for (i = 0; i &lt; SHUFFLE_MAPPOINT_COUNT; i++) {
+        x = rand() % WORLD_SIDE_LEN;
+        a = mappoint_array_x[i];
+        mappoint_array_x[i] = mappoint_array_x[x];
+        mappoint_array_x[x] = a;
+        x = rand() % WORLD_SIDE_LEN;
+        a = mappoint_array_y[i];
+        mappoint_array_y[i] = mappoint_array_y[x];
+        mappoint_array_y[x] = a;
     }
 }
 
-void
-do_pollution ()
+void do_pollution()
 {
-  int x, p;
-  int* pol = &amp;map.pollution[0][0];
+    int x, p;
+    int *pol = &amp;map.pollution[0][0];
 
-  /* Kill pollution from top edge of map */
-  do {
-    if (*pol &gt; 0)
-      *pol /= POL_DIV;
-  } while (++pol &lt; &amp;map.pollution[1][0]);
+    /* Kill pollution from top edge of map */
+    do {
+        if (*pol &gt; 0)
+            *pol /= POL_DIV;
+    } while (++pol &lt; &amp;map.pollution[1][0]);
 
-
-  x= 1;
-  do
-    {
-      /* Kill some pollution from left edge of map */
-      if (*pol++ &gt; 0)
-        *(pol-1) /= POL_DIV;
-      do {
-        if (*pol &gt; 10) {
-	  p = *pol / 16;
-	  *pol -= p;
-	  switch ( rand() % 11)
-	    {         /* prevailing wind is *from* SW */
-	    case 0:
-	    case 1: /* up */
-	    case 2:
-	      *(pol - 1) += p;
-	      break;
-	    case 3:
-	    case 4: /* right */
-	    case 5:
-	      *(pol + WORLD_SIDE_LEN) += p;
-	      break;
-	    case 6: /* down */
-	    case 7:
-	      *(pol + 1) += p;
-	      break;
-	    case 8: /* left */
-	    case 9:
-	      *(pol - WORLD_SIDE_LEN) += p;
-	      break;
-	    case 10:
-	      *pol += p- 2;
-	      break;
-	    }
-	}
-      } while (++pol &lt; &amp;map.pollution[x][WORLD_SIDE_LEN-1]);
-      /* Kill some pollution from right edge of map */
-      if (*pol &gt; 0)
-        *pol /= POL_DIV;
-      ++x;
+    x = 1;
+    do {
+        /* Kill some pollution from left edge of map */
+        if (*pol++ &gt; 0)
+            *(pol - 1) /= POL_DIV;
+        do {
+            if (*pol &gt; 10) {
+                p = *pol / 16;
+                *pol -= p;
+                switch (rand() % 11) {  /* prevailing wind is *from* SW */
+                case 0:
+                case 1:        /* up */
+                case 2:
+                    *(pol - 1) += p;
+                    break;
+                case 3:
+                case 4:        /* right */
+                case 5:
+                    *(pol + WORLD_SIDE_LEN) += p;
+                    break;
+                case 6:        /* down */
+                case 7:
+                    *(pol + 1) += p;
+                    break;
+                case 8:        /* left */
+                case 9:
+                    *(pol - WORLD_SIDE_LEN) += p;
+                    break;
+                case 10:
+                    *pol += p - 2;
+                    break;
+                }
+            }
+        } while (++pol &lt; &amp;map.pollution[x][WORLD_SIDE_LEN - 1]);
+        /* Kill some pollution from right edge of map */
+        if (*pol &gt; 0)
+            *pol /= POL_DIV;
+        ++x;
     }
-  while (++pol &lt; &amp;map.pollution[WORLD_SIDE_LEN-1][0]);
+    while (++pol &lt; &amp;map.pollution[WORLD_SIDE_LEN - 1][0]);
 
-  /* Kill pollution from bottom edge of map */
-  do {
-    if (*pol &gt; 0)
-      *pol /= POL_DIV;
-  } while (++pol &lt; &amp;map.pollution[WORLD_SIDE_LEN][0]);
+    /* Kill pollution from bottom edge of map */
+    do {
+        if (*pol &gt; 0)
+            *pol /= POL_DIV;
+    } while (++pol &lt; &amp;map.pollution[WORLD_SIDE_LEN][0]);
 }
 
-void
-clear_fire_health_and_cricket_cover (void)
+void clear_fire_health_and_cricket_cover(void)
 {
-  int x, y, m;
-  m = 0xffffffff - (FLAG_FIRE_COVER | FLAG_HEALTH_COVER
-		    | FLAG_CRICKET_COVER| FLAG_WATERWELL_COVER
-                    | FLAG_ASKED_FOR_POWER |FLAG_GOT_POWER );
-  for (y = 0; y &lt; WORLD_SIDE_LEN; y++)
-    for (x = 0; x &lt; WORLD_SIDE_LEN; x++)
-      MP_INFO(x,y).flags &amp;= m;
-  /* Wow... chache misses or what! */
+    int x, y, m;
+    m = 0xffffffff - (FLAG_FIRE_COVER | FLAG_HEALTH_COVER
+                      | FLAG_CRICKET_COVER | FLAG_WATERWELL_COVER | FLAG_ASKED_FOR_POWER | FLAG_GOT_POWER);
+    for (y = 0; y &lt; WORLD_SIDE_LEN; y++)
+        for (x = 0; x &lt; WORLD_SIDE_LEN; x++)
+            MP_INFO(x, y).flags &amp;= m;
+    /* Wow... chache misses or what! */
 }
 
-void
-do_fire_health_and_cricket_cover (void)
+void do_fire_health_and_cricket_cover(void)
 {
-  int x, y;
-  for (y = 0; y &lt; WORLD_SIDE_LEN; y++)
-    for (x = 0; x &lt; WORLD_SIDE_LEN; x++)
-      {
-	/*  The next few lines need changing to test for */
-	/*  the group if these areas are animated. */
+    int x, y;
+    for (y = 0; y &lt; WORLD_SIDE_LEN; y++)
+        for (x = 0; x &lt; WORLD_SIDE_LEN; x++) {
+            /*  The next few lines need changing to test for */
+            /*  the group if these areas are animated. */
 
-	if (MP_GROUP(x,y) == GROUP_FIRESTATION)
-	  do_fire_cover (x, y);
-	else if (MP_TYPE(x,y) == CST_HEALTH)
-	  do_health_cover (x, y);
-	else if (MP_GROUP(x,y) == GROUP_CRICKET)
-	  do_cricket_cover (x, y);
-	else if (MP_GROUP(x,y) == GROUP_WATERWELL)
-	  do_waterwell_cover (x, y);
-      }
+            if (MP_GROUP(x, y) == GROUP_FIRESTATION)
+                do_fire_cover(x, y);
+            else if (MP_TYPE(x, y) == CST_HEALTH)
+                do_health_cover(x, y);
+            else if (MP_GROUP(x, y) == GROUP_CRICKET)
+                do_cricket_cover(x, y);
+            else if (MP_GROUP(x, y) == GROUP_WATERWELL)
+                do_waterwell_cover(x, y);
+        }
 }
 
-void
-do_random_fire (int x, int y, int pwarning)	/* well random if x=y=-1 */
-{
-  int xx, yy;
-  if (x == -1 &amp;&amp; y == -1)
-    {
-      x = rand () % WORLD_SIDE_LEN;
-      y = rand () % WORLD_SIDE_LEN;
+void do_random_fire(int x, int y, int pwarning)
+{                               /* well random if x=y=-1 */
+    int xx, yy;
+    if (x == -1 &amp;&amp; y == -1) {
+        x = rand() % WORLD_SIDE_LEN;
+        y = rand() % WORLD_SIDE_LEN;
+    } else {
+        if (x &lt; 0 || x &gt;= WORLD_SIDE_LEN || y &lt; 0 || y &gt;= WORLD_SIDE_LEN)
+            return;
     }
-  else
-    {
-      if (x &lt; 0 || x &gt;= WORLD_SIDE_LEN || y &lt; 0 || y &gt;= WORLD_SIDE_LEN)
-	return;
+    if (MP_TYPE(x, y) == CST_USED) {
+        xx = MP_INFO(x, y).int_1;
+        yy = MP_INFO(x, y).int_2;
+        x = xx;
+        y = yy;
     }
-  if (MP_TYPE(x,y) == CST_USED)
-    {
-      xx = MP_INFO(x,y).int_1;
-      yy = MP_INFO(x,y).int_2;
-      x = xx;
-      y = yy;
+    xx = rand() % 100;
+    if (xx &gt;= (main_groups[MP_GROUP(x, y)].fire_chance))
+        return;
+    if ((MP_INFO(x, y).flags &amp; FLAG_FIRE_COVER) != 0)
+        return;
+    if (pwarning) {
+        if (MP_GROUP(x, y) == GROUP_POWER_LINE)
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at a power line.&quot;));
+        else if (MP_GROUP(x, y) == GROUP_SOLAR_POWER)
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at a solar power station.&quot;));
+        else if (MP_GROUP(x, y) == GROUP_SUBSTATION)
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at a substation.&quot;));
+        else if (MP_GROUP_IS_RESIDENCE(x, y))
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at a residential area.&quot;));
+        else if (MP_GROUP(x, y) == GROUP_ORGANIC_FARM)
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at a farm.&quot;));
+        else if (MP_GROUP(x, y) == GROUP_MARKET)
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at a market.&quot;));
+        else if (MP_GROUP(x, y) == GROUP_TRACK)
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at a track.&quot;));
+        else if (MP_GROUP(x, y) == GROUP_COALMINE)
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at a coal mine.&quot;));
+        else if (MP_GROUP(x, y) == GROUP_RAIL)
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at a railway.&quot;));
+        else if (MP_GROUP(x, y) == GROUP_COAL_POWER)
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at a coal power station.&quot;));
+        else if (MP_GROUP(x, y) == GROUP_ROAD)
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at a road.&quot;));
+        else if (MP_GROUP(x, y) == GROUP_INDUSTRY_L)
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at light industry.&quot;));
+        else if (MP_GROUP(x, y) == GROUP_UNIVERSITY)
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at a university.&quot;));
+        else if (MP_GROUP(x, y) == GROUP_COMMUNE)
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at a commune.&quot;));
+        else if (MP_GROUP(x, y) == GROUP_TIP)
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at a tip.&quot;));
+        else if (MP_GROUP(x, y) == GROUP_PORT)
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at a port.&quot;));
+        else if (MP_GROUP(x, y) == GROUP_INDUSTRY_H)
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at a steel works.&quot;));
+        else if (MP_GROUP(x, y) == GROUP_RECYCLE)
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at a recycle centre.&quot;));
+        else if (MP_GROUP(x, y) == GROUP_HEALTH)
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at a health centre.&quot;));
+        else if (MP_GROUP(x, y) == GROUP_ROCKET)
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at a rocket site.&quot;));
+        else if (MP_GROUP(x, y) == GROUP_WINDMILL)
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at a windmill.&quot;));
+        else if (MP_GROUP(x, y) == GROUP_SCHOOL)
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at a school.&quot;));
+        else if (MP_GROUP(x, y) == GROUP_BLACKSMITH)
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at a blacksmith.&quot;));
+        else if (MP_GROUP(x, y) == GROUP_MILL)
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at a mill.&quot;));
+        else if (MP_GROUP(x, y) == GROUP_POTTERY)
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at a pottery.&quot;));
+        else if (MP_GROUP(x, y) == GROUP_FIRESTATION)
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at a fire station!!!.&quot;));
+        else if (MP_GROUP(x, y) == GROUP_CRICKET)
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at a sports field!!!.&quot;));
+        else if (MP_GROUP(x, y) == GROUP_SHANTY)
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;It's at a shanty town.&quot;));
+        else
+            ok_dial_box(&quot;fire.mes&quot;, BAD, _(&quot;UNKNOWN!&quot;));
     }
-  xx = rand () % 100;
-  if (xx &gt;= (main_groups[MP_GROUP(x,y)].fire_chance))
-    return;
-  if ((MP_INFO(x,y).flags &amp; FLAG_FIRE_COVER) != 0)
-    return;
-  if (pwarning)
-    {
-      if (MP_GROUP(x,y) == GROUP_POWER_LINE)
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at a power line.&quot;));
-      else if (MP_GROUP(x,y) == GROUP_SOLAR_POWER)
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at a solar power station.&quot;));
-      else if (MP_GROUP(x,y) == GROUP_SUBSTATION)
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at a substation.&quot;));
-      else if (MP_GROUP_IS_RESIDENCE(x,y))
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at a residential area.&quot;));
-      else if (MP_GROUP(x,y) == GROUP_ORGANIC_FARM)
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at a farm.&quot;));
-      else if (MP_GROUP(x,y) == GROUP_MARKET)
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at a market.&quot;));
-      else if (MP_GROUP(x,y) == GROUP_TRACK)
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at a track.&quot;));
-      else if (MP_GROUP(x,y) == GROUP_COALMINE)
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at a coal mine.&quot;));
-      else if (MP_GROUP(x,y) == GROUP_RAIL)
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at a railway.&quot;));
-      else if (MP_GROUP(x,y) == GROUP_COAL_POWER)
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at a coal power station.&quot;));
-      else if (MP_GROUP(x,y) == GROUP_ROAD)
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at a road.&quot;));
-      else if (MP_GROUP(x,y) == GROUP_INDUSTRY_L)
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at light industry.&quot;));
-      else if (MP_GROUP(x,y) == GROUP_UNIVERSITY)
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at a university.&quot;));
-      else if (MP_GROUP(x,y) == GROUP_COMMUNE)
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at a commune.&quot;));
-      else if (MP_GROUP(x,y) == GROUP_TIP)
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at a tip.&quot;));
-      else if (MP_GROUP(x,y) == GROUP_PORT)
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at a port.&quot;));
-      else if (MP_GROUP(x,y) == GROUP_INDUSTRY_H)
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at a steel works.&quot;));
-      else if (MP_GROUP(x,y) == GROUP_RECYCLE)
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at a recycle centre.&quot;));
-      else if (MP_GROUP(x,y) == GROUP_HEALTH)
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at a health centre.&quot;));
-      else if (MP_GROUP(x,y) == GROUP_ROCKET)
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at a rocket site.&quot;));
-      else if (MP_GROUP(x,y) == GROUP_WINDMILL)
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at a windmill.&quot;));
-      else if (MP_GROUP(x,y) == GROUP_SCHOOL)
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at a school.&quot;));
-      else if (MP_GROUP(x,y) == GROUP_BLACKSMITH)
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at a blacksmith.&quot;));
-      else if (MP_GROUP(x,y) == GROUP_MILL)
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at a mill.&quot;));
-      else if (MP_GROUP(x,y) == GROUP_POTTERY)
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at a pottery.&quot;));
-      else if (MP_GROUP(x,y) == GROUP_FIRESTATION)
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at a fire station!!!.&quot;));
-      else if (MP_GROUP(x,y) == GROUP_CRICKET)
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at a sports field!!!.&quot;));
-      else if (MP_GROUP(x,y) == GROUP_SHANTY)
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;It's at a shanty town.&quot;));
-      else
-	ok_dial_box (&quot;fire.mes&quot;, BAD, _(&quot;UNKNOWN!&quot;));
-    }
-  fire_area (x, y);
+    fire_area(x, y);
 }
 
-void do_daily_ecology ()
+void do_daily_ecology()
 {
     for (int x = 0; x &lt; WORLD_SIDE_LEN; x++)
         for (int y = 0; y &lt; WORLD_SIDE_LEN; y++) {
             /* approximately 3 monthes needed to turn bulldoze area into green */
-            if (MP_GROUP(x,y) == GROUP_DESERT &amp;&amp; HAS_UGWATER(x,y) 
-                    &amp;&amp; rand() %300 == 1)
+            if (MP_GROUP(x, y) == GROUP_DESERT &amp;&amp; HAS_UGWATER(x, y)
+                &amp;&amp; rand() % 300 == 1)
                 do_bulldoze_area(CST_GREEN, x, y);
         }
 }
@@ -717,46 +674,40 @@
    // return the x y coords encoded as x+y*WORLD_SIDE_LEN
    // return -1 if we don't find one.
  */
-int
-spiral_find_group (int startx, int starty, int group)
+int spiral_find_group(int startx, int starty, int group)
 {
-  int i, j, x, y;
-  x = startx;
-  y = starty;
-  /* let's just do a complete spiral for now, work out the bounds later */
-  for (i = 1; i &lt; (WORLD_SIDE_LEN + WORLD_SIDE_LEN); i++)
-    {
-      for (j = 0; j &lt; i; j++)
-	{
-	  x--;
-	  if (x &gt; 0 &amp;&amp; x &lt; WORLD_SIDE_LEN &amp;&amp; y &gt; 0 &amp;&amp; y &lt; WORLD_SIDE_LEN)
-	    if (MP_GROUP(x,y) == group)
-	      return (x + y * WORLD_SIDE_LEN);
-	}
-      for (j = 0; j &lt; i; j++)
-	{
-	  y--;
-	  if (x &gt; 0 &amp;&amp; x &lt; WORLD_SIDE_LEN &amp;&amp; y &gt; 0 &amp;&amp; y &lt; WORLD_SIDE_LEN)
-	    if (MP_GROUP(x,y) == group)
-	      return (x + y * WORLD_SIDE_LEN);
-	}
-      i++;
-      for (j = 0; j &lt; i; j++)
-	{
-	  x++;
-	  if (x &gt; 0 &amp;&amp; x &lt; WORLD_SIDE_LEN &amp;&amp; y &gt; 0 &amp;&amp; y &lt; WORLD_SIDE_LEN)
-	    if (MP_GROUP(x,y) == group)
-	      return (x + y * WORLD_SIDE_LEN);
-	}
-      for (j = 0; j &lt; i; j++)
-	{
-	  y++;
-	  if (x &gt; 0 &amp;&amp; x &lt; WORLD_SIDE_LEN &amp;&amp; y &gt; 0 &amp;&amp; y &lt; WORLD_SIDE_LEN)
-	    if (MP_GROUP(x,y) == group)
-	      return (x + y * WORLD_SIDE_LEN);
-	}
+    int i, j, x, y;
+    x = startx;
+    y = starty;
+    /* let's just do a complete spiral for now, work out the bounds later */
+    for (i = 1; i &lt; (WORLD_SIDE_LEN + WORLD_SIDE_LEN); i++) {
+        for (j = 0; j &lt; i; j++) {
+            x--;
+            if (x &gt; 0 &amp;&amp; x &lt; WORLD_SIDE_LEN &amp;&amp; y &gt; 0 &amp;&amp; y &lt; WORLD_SIDE_LEN)
+                if (MP_GROUP(x, y) == group)
+                    return (x + y * WORLD_SIDE_LEN);
+        }
+        for (j = 0; j &lt; i; j++) {
+            y--;
+            if (x &gt; 0 &amp;&amp; x &lt; WORLD_SIDE_LEN &amp;&amp; y &gt; 0 &amp;&amp; y &lt; WORLD_SIDE_LEN)
+                if (MP_GROUP(x, y) == group)
+                    return (x + y * WORLD_SIDE_LEN);
+        }
+        i++;
+        for (j = 0; j &lt; i; j++) {
+            x++;
+            if (x &gt; 0 &amp;&amp; x &lt; WORLD_SIDE_LEN &amp;&amp; y &gt; 0 &amp;&amp; y &lt; WORLD_SIDE_LEN)
+                if (MP_GROUP(x, y) == group)
+                    return (x + y * WORLD_SIDE_LEN);
+        }
+        for (j = 0; j &lt; i; j++) {
+            y++;
+            if (x &gt; 0 &amp;&amp; x &lt; WORLD_SIDE_LEN &amp;&amp; y &gt; 0 &amp;&amp; y &lt; WORLD_SIDE_LEN)
+                if (MP_GROUP(x, y) == group)
+                    return (x + y * WORLD_SIDE_LEN);
+        }
     }
-  return (-1);
+    return (-1);
 }
 
 /*
@@ -764,121 +715,101 @@
    // return the x y coords encoded as x+y*WORLD_SIDE_LEN
    // return -1 if we don't find one.
  */
-int
-spiral_find_2x2 (int startx, int starty)
+int spiral_find_2x2(int startx, int starty)
 {
-  int i, j, x, y;
-  x = startx;
-  y = starty;
-  /* let's just do a complete spiral for now, work out the bounds later */
-  for (i = 1; i &lt; (WORLD_SIDE_LEN + WORLD_SIDE_LEN); i++)
-    {
-      for (j = 0; j &lt; i; j++)
-	{
-	  x--;
-	  if (x &gt; 1 &amp;&amp; x &lt; WORLD_SIDE_LEN - 2 &amp;&amp; y &gt; 1
-	      &amp;&amp; y &lt; WORLD_SIDE_LEN - 2)
-	    if (GROUP_IS_BARE(MP_GROUP(x,y))
-		&amp;&amp; GROUP_IS_BARE(MP_GROUP(x + 1,y))
-		&amp;&amp; GROUP_IS_BARE(MP_GROUP(x,y + 1))
-		&amp;&amp; GROUP_IS_BARE(MP_GROUP(x + 1,y + 1)) )
-	      return (x + y * WORLD_SIDE_LEN);
-	}
-      for (j = 0; j &lt; i; j++)
-	{
-	  y--;
-	  if (x &gt; 1 &amp;&amp; x &lt; WORLD_SIDE_LEN - 2 &amp;&amp; y &gt; 1
-	      &amp;&amp; y &lt; WORLD_SIDE_LEN - 2)
-	    if (GROUP_IS_BARE(MP_GROUP(x,y))
-		&amp;&amp; GROUP_IS_BARE(MP_GROUP(x + 1,y))
-		&amp;&amp; GROUP_IS_BARE(MP_GROUP(x,y + 1))
-		&amp;&amp; GROUP_IS_BARE(MP_GROUP(x + 1,y + 1)))
-	      return (x + y * WORLD_SIDE_LEN);
-	}
-      i++;
-      for (j = 0; j &lt; i; j++)
-	{
-	  x++;
-	  if (x &gt; 1 &amp;&amp; x &lt; WORLD_SIDE_LEN - 2 &amp;&amp; y &gt; 1
-	      &amp;&amp; y &lt; WORLD_SIDE_LEN - 2)
-	    if (GROUP_IS_BARE(MP_GROUP(x,y))
-		&amp;&amp; GROUP_IS_BARE(MP_GROUP(x + 1,y))
-		&amp;&amp; GROUP_IS_BARE(MP_GROUP(x,y + 1))
-		&amp;&amp; GROUP_IS_BARE(MP_GROUP(x + 1,y + 1)))
-	      return (x + y * WORLD_SIDE_LEN);
-	}
-      for (j = 0; j &lt; i; j++)
-	{
-	  y++;
-	  if (x &gt; 1 &amp;&amp; x &lt; WORLD_SIDE_LEN - 2 &amp;&amp; y &gt; 1
-	      &amp;&amp; y &lt; WORLD_SIDE_LEN - 2)
-	    if (GROUP_IS_BARE(MP_GROUP(x,y))
-		&amp;&amp; GROUP_IS_BARE(MP_GROUP(x + 1,y))
-		&amp;&amp; GROUP_IS_BARE(MP_GROUP(x,y + 1))
-		&amp;&amp; GROUP_IS_BARE(MP_GROUP(x + 1,y + 1)))
-	      return (x + y * WORLD_SIDE_LEN);
-	}
+    int i, j, x, y;
+    x = startx;
+    y = starty;
+    /* let's just do a complete spiral for now, work out the bounds later */
+    for (i = 1; i &lt; (WORLD_SIDE_LEN + WORLD_SIDE_LEN); i++) {
+        for (j = 0; j &lt; i; j++) {
+            x--;
+            if (x &gt; 1 &amp;&amp; x &lt; WORLD_SIDE_LEN - 2 &amp;&amp; y &gt; 1 &amp;&amp; y &lt; WORLD_SIDE_LEN - 2)
+                if (GROUP_IS_BARE(MP_GROUP(x, y))
+                    &amp;&amp; GROUP_IS_BARE(MP_GROUP(x + 1, y))
+                    &amp;&amp; GROUP_IS_BARE(MP_GROUP(x, y + 1))
+                    &amp;&amp; GROUP_IS_BARE(MP_GROUP(x + 1, y + 1)))
+                    return (x + y * WORLD_SIDE_LEN);
+        }
+        for (j = 0; j &lt; i; j++) {
+            y--;
+            if (x &gt; 1 &amp;&amp; x &lt; WORLD_SIDE_LEN - 2 &amp;&amp; y &gt; 1 &amp;&amp; y &lt; WORLD_SIDE_LEN - 2)
+                if (GROUP_IS_BARE(MP_GROUP(x, y))
+                    &amp;&amp; GROUP_IS_BARE(MP_GROUP(x + 1, y))
+                    &amp;&amp; GROUP_IS_BARE(MP_GROUP(x, y + 1))
+                    &amp;&amp; GROUP_IS_BARE(MP_GROUP(x + 1, y + 1)))
+                    return (x + y * WORLD_SIDE_LEN);
+        }
+        i++;
+        for (j = 0; j &lt; i; j++) {
+            x++;
+            if (x &gt; 1 &amp;&amp; x &lt; WORLD_SIDE_LEN - 2 &amp;&amp; y &gt; 1 &amp;&amp; y &lt; WORLD_SIDE_LEN - 2)
+                if (GROUP_IS_BARE(MP_GROUP(x, y))
+                    &amp;&amp; GROUP_IS_BARE(MP_GROUP(x + 1, y))
+                    &amp;&amp; GROUP_IS_BARE(MP_GROUP(x, y + 1))
+                    &amp;&amp; GROUP_IS_BARE(MP_GROUP(x + 1, y + 1)))
+                    return (x + y * WORLD_SIDE_LEN);
+        }
+        for (j = 0; j &lt; i; j++) {
+            y++;
+            if (x &gt; 1 &amp;&amp; x &lt; WORLD_SIDE_LEN - 2 &amp;&amp; y &gt; 1 &amp;&amp; y &lt; WORLD_SIDE_LEN - 2)
+                if (GROUP_IS_BARE(MP_GROUP(x, y))
+                    &amp;&amp; GROUP_IS_BARE(MP_GROUP(x + 1, y))
+                    &amp;&amp; GROUP_IS_BARE(MP_GROUP(x, y + 1))
+                    &amp;&amp; GROUP_IS_BARE(MP_GROUP(x + 1, y + 1)))
+                    return (x + y * WORLD_SIDE_LEN);
+        }
     }
-  return (-1);
+    return (-1);
 }
 
-void
-connect_rivers (void)
+void connect_rivers(void)
 {
-  int x, y, count;
-  count = 1;
-  while (count &gt; 0)
-    {
-      count = 0;
-      for (y = 0; y &lt; WORLD_SIDE_LEN; y++)
-	for (x = 0; x &lt; WORLD_SIDE_LEN; x++)
-	  {
-	    if (is_real_river (x, y) == 1)
-	      {
-		if (is_real_river (x - 1, y) == -1)
-		  {
-		    MP_INFO(x - 1,y).flags |= FLAG_IS_RIVER;
-		    count++;
-		  }
-		if (is_real_river (x, y - 1) == -1)
-		  {
-		    MP_INFO(x,y - 1).flags |= FLAG_IS_RIVER;
-		    count++;
-		  }
-		if (is_real_river (x + 1, y) == -1)
-		  {
-		    MP_INFO(x + 1,y).flags |= FLAG_IS_RIVER;
-		    count++;
-		  }
-		if (is_real_river (x, y + 1) == -1)
-		  {
-		    MP_INFO(x,y + 1).flags |= FLAG_IS_RIVER;
-		    count++;
-		  }
-	      }
-	  }
+    int x, y, count;
+    count = 1;
+    while (count &gt; 0) {
+        count = 0;
+        for (y = 0; y &lt; WORLD_SIDE_LEN; y++)
+            for (x = 0; x &lt; WORLD_SIDE_LEN; x++) {
+                if (is_real_river(x, y) == 1) {
+                    if (is_real_river(x - 1, y) == -1) {
+                        MP_INFO(x - 1, y).flags |= FLAG_IS_RIVER;
+                        count++;
+                    }
+                    if (is_real_river(x, y - 1) == -1) {
+                        MP_INFO(x, y - 1).flags |= FLAG_IS_RIVER;
+                        count++;
+                    }
+                    if (is_real_river(x + 1, y) == -1) {
+                        MP_INFO(x + 1, y).flags |= FLAG_IS_RIVER;
+                        count++;
+                    }
+                    if (is_real_river(x, y + 1) == -1) {
+                        MP_INFO(x, y + 1).flags |= FLAG_IS_RIVER;
+                        count++;
+                    }
+                }
+            }
     }
 }
 
-int
-is_real_river (int x, int y)
+int is_real_river(int x, int y)
 {
-  /* returns zero if not water at all or if out of bounds. */
-  if (x &lt; 0 || x &gt;= WORLD_SIDE_LEN || y &lt; 0 || y &gt;= WORLD_SIDE_LEN)
-    return (0);
-  if (MP_GROUP(x,y) != GROUP_WATER)
-    return (0);
-  if (MP_INFO(x,y).flags &amp; FLAG_IS_RIVER)
-    return (1);
-  return (-1);
+    /* returns zero if not water at all or if out of bounds. */
+    if (x &lt; 0 || x &gt;= WORLD_SIDE_LEN || y &lt; 0 || y &gt;= WORLD_SIDE_LEN)
+        return (0);
+    if (MP_GROUP(x, y) != GROUP_WATER)
+        return (0);
+    if (MP_INFO(x, y).flags &amp; FLAG_IS_RIVER)
+        return (1);
+    return (-1);
 }
 
 /* Feature: coal survey should vary in price and accuracy with technology */
-void 
-do_coal_survey (void)
+void do_coal_survey(void)
 {
     if (coal_survey_done == 0) {
-	adjust_money(-1000000);
-	coal_survey_done = 1;
+        adjust_money(-1000000);
+        coal_survey_done = 1;
     }
 }

Modified: trunk/src/lincity/engine.h
===================================================================
--- trunk/src/lincity/engine.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/engine.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -6,16 +6,16 @@
 #ifndef __engine_h__
 #define __engine_h__
 
-int place_item (int x, int y, short type);
-int bulldoze_item (int x, int y);
-void do_coal_survey (void);
-void do_bulldoze_area (short fill, int xx, int yy);
-void launch_rocket (int x, int y);
-void connect_rivers (void);
+int place_item(int x, int y, short type);
+int bulldoze_item(int x, int y);
+void do_coal_survey(void);
+void do_bulldoze_area(short fill, int xx, int yy);
+void launch_rocket(int x, int y);
+void connect_rivers(void);
 int adjust_money(int value);
-void fire_area (int x, int y);
-void do_daily_ecology (void);
+void fire_area(int x, int y);
+void do_daily_ecology(void);
 
 extern long real_time;
 
-#endif	/* __engine_h__ */
+#endif /* __engine_h__ */

Modified: trunk/src/lincity/fileutil.cpp
===================================================================
--- trunk/src/lincity/fileutil.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/fileutil.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -1,12 +1,12 @@
  /* ---------------------------------------------------------------------- *
- * fileutil.c
- * This file is part of lincity.
- * Lincity is copyright (c) I J Peters 1995-1997, (c) Greg Sharp 1997-2001.
- * ---------------------------------------------------------------------- */
+  * fileutil.c
+  * This file is part of lincity.
+  * Lincity is copyright (c) I J Peters 1995-1997, (c) Greg Sharp 1997-2001.
+  * ---------------------------------------------------------------------- */
 #include &lt;config.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
-#include &lt;stdarg.h&gt; /* XXX: GCS FIX: What does configure need to know? */
+#include &lt;stdarg.h&gt;             /* XXX: GCS FIX: What does configure need to know? */
 #include &quot;lcintl.h&quot;
 #include &lt;string.h&gt;
 //#include &quot;ldsvgui.h&quot;
@@ -18,7 +18,7 @@
 /* this is for OS/2 - RVI */
 #ifdef __EMX__
 #include &lt;sys/select.h&gt;
-#include &lt;X11/Xlibint.h&gt;      /* required for __XOS2RedirRoot */
+#include &lt;X11/Xlibint.h&gt;        /* required for __XOS2RedirRoot */
 #define chown(x,y,z)
 #define OS2_DEFAULT_LIBDIR &quot;/XFree86/lib/X11/lincity&quot;
 #endif
@@ -103,15 +103,14 @@
 #endif
 
 #define DEBUG_PRINTF_TO_FILE 0
-void debug_printf (char* fmt, ...);
+void debug_printf(char *fmt, ...);
 
 /* ---------------------------------------------------------------------- *
  * Private Fn Prototypes
  * ---------------------------------------------------------------------- */
-void dump_screen (void);
-void verify_package (void);
-static const char *guess_category_value (int category, 
-					 const char *categoryname);
+void dump_screen(void);
+void verify_package(void);
+static const char *guess_category_value(int category, const char *categoryname);
 
 /* ---------------------------------------------------------------------- *
  * Public Global Variables
@@ -154,154 +153,141 @@
  * Public Functions
  * ---------------------------------------------------------------------- */
 #if defined (__BORLANDC__)
-int
-_chdir (const char *dirname)
+int _chdir(const char *dirname)
 {
-    return chdir (dirname);
+    return chdir(dirname);
 }
 
-int 
-_access (const char *path, int mode)
+int _access(const char *path, int mode)
 {
-    return access (path, mode)
+    return access(path, mode)
 }
 #endif
 
 /* Executes a system command */
-int
-execute_command (char *cmd, char *p1, char *p2, char *p3)
+int execute_command(char *cmd, char *p1, char *p2, char *p3)
 {
-  char *sys_cmd = (char *) malloc (strlen (cmd) + strlen (p1) + strlen (p2)
-				   + strlen (p3) + 4);
-  int ret_value;
+    char *sys_cmd = (char *)malloc(strlen(cmd) + strlen(p1) + strlen(p2)
+                                   + strlen(p3) + 4);
+    int ret_value;
 
-  if (sys_cmd == 0) {
-    malloc_failure ();
-  }
-  sprintf (sys_cmd, &quot;%s %s %s %s&quot;, cmd, p1, p2, p3);
-  ret_value = system (sys_cmd);
+    if (sys_cmd == 0) {
+        malloc_failure();
+    }
+    sprintf(sys_cmd, &quot;%s %s %s %s&quot;, cmd, p1, p2, p3);
+    ret_value = system(sys_cmd);
 /* fprintf(stderr, &quot;system(%s)=%i\n&quot;, sys_cmd, ret_value); */
-  free (sys_cmd);
-  return ret_value;
+    free(sys_cmd);
+    return ret_value;
 }
 
-void
-copy_file (char *f1, char *f2)
+void copy_file(char *f1, char *f2)
 {
-  int ret_value = execute_command (&quot;cp&quot;, f1, f2, &quot;&quot;);
-  if (ret_value != 0)
-    {
-      /* GCS FIX:  Need to make do_error into var_args fn? */
-      printf (&quot;Tried to cp %s %s\n&quot;, f1, f2);
-      do_error (&quot;Can't copy requested file&quot;);
+    int ret_value = execute_command(&quot;cp&quot;, f1, f2, &quot;&quot;);
+    if (ret_value != 0) {
+        /* GCS FIX:  Need to make do_error into var_args fn? */
+        printf(&quot;Tried to cp %s %s\n&quot;, f1, f2);
+        do_error(&quot;Can't copy requested file&quot;);
     }
 }
 
 #if 0
-void //unused function
-gunzip_file (char *f1, char *f2)
+void                            //unused function
+gunzip_file(char *f1, char *f2)
 {
-  int ret_value = execute_command (&quot;gzip -c -d&quot;, f1, &quot;&gt;&quot;, f2);
-  if (ret_value != 0)
-    {
-      /* GCS FIX:  Need to make do_error into var_args fn? */
-      printf (&quot;Tried to gzip -c -d %s &gt; %s\n&quot;, f1, f2);
-      do_error (&quot;Can't gunzip requested file&quot;);
+    int ret_value = execute_command(&quot;gzip -c -d&quot;, f1, &quot;&gt;&quot;, f2);
+    if (ret_value != 0) {
+        /* GCS FIX:  Need to make do_error into var_args fn? */
+        printf(&quot;Tried to gzip -c -d %s &gt; %s\n&quot;, f1, f2);
+        do_error(&quot;Can't gunzip requested file&quot;);
     }
 }
 
-FILE* 
-fopen_read_gzipped (char* fn)
+FILE *fopen_read_gzipped(char *fn)
 {
-    FILE* fp;
+    FILE *fp;
 
-    const char* cmd_str = &quot;gzip -d -c &lt; %s 2&gt; /dev/null&quot;;
-    char *cmd = (char*) malloc (strlen (cmd_str) + strlen (fn) + 1);
-    
-    sprintf (cmd, cmd_str, fn);
-    fp=popen(cmd,&quot;r&quot;);
-    if (fp==NULL) {
-       fprintf(stderr, &quot;Failed to open pipe cmd: %s\n&quot;, cmd);
+    const char *cmd_str = &quot;gzip -d -c &lt; %s 2&gt; /dev/null&quot;;
+    char *cmd = (char *)malloc(strlen(cmd_str) + strlen(fn) + 1);
+
+    sprintf(cmd, cmd_str, fn);
+    fp = popen(cmd, &quot;r&quot;);
+    if (fp == NULL) {
+        fprintf(stderr, &quot;Failed to open pipe cmd: %s\n&quot;, cmd);
     }
     free(cmd);
 
     return fp;
 }
 
-void 
-fclose_read_gzipped (FILE* fp)
+void fclose_read_gzipped(FILE * fp)
 {
-    pclose (fp);
+    pclose(fp);
 }
 #endif
 
-int
-directory_exists (char *dir)
+int directory_exists(char *dir)
 {
 #if defined (WIN32)
     struct stat s;
     if (stat(dir, &amp;s) != 0 || !(s.st_mode &amp; S_IFDIR)) {
-	return 0;
+        return 0;
     }
 #else /* UNIX */
     DIR *dp;
-    if ((dp = opendir (dir)) == NULL) {
-	return 0;
+    if ((dp = opendir(dir)) == NULL) {
+        return 0;
     }
-    closedir (dp);
+    closedir(dp);
 #endif
     return 1;
 }
 
-int
-file_exists (char *filename)
+int file_exists(char *filename)
 {
-    FILE* fp;
-    fp = fopen (filename,&quot;rb&quot;);
+    FILE *fp;
+    fp = fopen(filename, &quot;rb&quot;);
     if (fp == NULL) {
-	return 0;
+        return 0;
     }
-    fclose (fp);
+    fclose(fp);
     return 1;
 }
 
 #if defined (WIN32)
-void
-find_libdir (void)
+void find_libdir(void)
 {
     const char searchfile[] = &quot;Colour.pal&quot;;
     /* default_dir will be something like &quot;C:\\LINCITY1.11&quot; */
     const char default_dir[] = &quot;C:\\LINCITY&quot; PACKAGE_VERSION;
-//    const char default_dir[] = &quot;D:\\LINCITY&quot;;	/* For GCS's use */
+//    const char default_dir[] = &quot;D:\\LINCITY&quot;; /* For GCS's use */
 
     /* Check 1: environment variable */
-    _searchenv (searchfile, &quot;LINCITY_HOME&quot;, LIBDIR);
+    _searchenv(searchfile, &quot;LINCITY_HOME&quot;, LIBDIR);
     if (*LIBDIR != '\0') {
-	int endofpath_offset = strlen (LIBDIR) - strlen (searchfile) - 1;
-	LIBDIR[endofpath_offset] = '\0';
-	return;
+        int endofpath_offset = strlen(LIBDIR) - strlen(searchfile) - 1;
+        LIBDIR[endofpath_offset] = '\0';
+        return;
     }
 
     /* Check 2: default location */
-    if ((_access (default_dir, 0)) != -1) {
-	strcpy (LIBDIR, default_dir);
-	return;
+    if ((_access(default_dir, 0)) != -1) {
+        strcpy(LIBDIR, default_dir);
+        return;
     }
 
     /* Finally give up */
-    HandleError (_(&quot;Error. Can't find LINCITY_HOME&quot;), FATAL);
+    HandleError(_(&quot;Error. Can't find LINCITY_HOME&quot;), FATAL);
 }
 
 #elif defined (__EMX__)
-void
-find_libdir (void)
+void find_libdir(void)
 {
     strcpy(LIBDIR, __XOS2RedirRoot(OS2_DEFAULT_LIBDIR));
 }
 
 #else /* Unix with configure */
-void
-find_libdir (void)
+void find_libdir(void)
 {
     const char searchfile[] = &quot;colour.pal&quot;;
     char *home_dir, *cwd;
@@ -309,80 +295,75 @@
     char filename_buf[LC_PATH_MAX];
 
     /* Check 1: environment variable */
-    home_dir = getenv (&quot;LINCITY_HOME&quot;);
+    home_dir = getenv(&quot;LINCITY_HOME&quot;);
     if (home_dir) {
-	snprintf (filename_buf, LC_PATH_MAX, &quot;%s%c%s&quot;, 
-		  home_dir, PATH_SLASH, searchfile);
-	if (file_exists(filename_buf)) {
-	    strncpy (LIBDIR, home_dir, LC_PATH_MAX);
-	    return;
-	}
+        snprintf(filename_buf, LC_PATH_MAX, &quot;%s%c%s&quot;, home_dir, PATH_SLASH, searchfile);
+        if (file_exists(filename_buf)) {
+            strncpy(LIBDIR, home_dir, LC_PATH_MAX);
+            return;
+        }
     }
 
     /* Check 2: current working directory */
-    cwd = getcwd (cwd_buf, LC_PATH_MAX);
+    cwd = getcwd(cwd_buf, LC_PATH_MAX);
     if (cwd) {
-	snprintf (filename_buf, LC_PATH_MAX, &quot;%s%c%s&quot;, 
-		  cwd_buf, PATH_SLASH, searchfile);
-	if (file_exists(filename_buf)) {
-	    strncpy (LIBDIR, cwd_buf, LC_PATH_MAX);
-	    return;
-	}
+        snprintf(filename_buf, LC_PATH_MAX, &quot;%s%c%s&quot;, cwd_buf, PATH_SLASH, searchfile);
+        if (file_exists(filename_buf)) {
+            strncpy(LIBDIR, cwd_buf, LC_PATH_MAX);
+            return;
+        }
     }
 
-    snprintf (filename_buf, LC_PATH_MAX, &quot;%s%c%s&quot;, 
-	      DEFAULT_LIBDIR, PATH_SLASH, searchfile);
+    snprintf(filename_buf, LC_PATH_MAX, &quot;%s%c%s&quot;, DEFAULT_LIBDIR, PATH_SLASH, searchfile);
     if (file_exists(filename_buf)) {
-	strncpy (LIBDIR, DEFAULT_LIBDIR, LC_PATH_MAX);
-	return;
+        strncpy(LIBDIR, DEFAULT_LIBDIR, LC_PATH_MAX);
+        return;
     }
 
     /* Finally give up */
-    HandleError (_(&quot;Error. Can't find LINCITY_HOME&quot;), FATAL);
+    HandleError(_(&quot;Error. Can't find LINCITY_HOME&quot;), FATAL);
 }
 #endif
 
-
 /* GCS:  This function comes from dcgettext.c in the gettext package.      */
 /* Guess value of current locale from value of the environment variables.  */
 /* GCS Feb 23, 2003.  This was updated in gettext, but I'm going with the  */
 /* old version here. */
-static const char *
-guess_category_value (int category, const char *categoryname)
+static const char *guess_category_value(int category, const char *categoryname)
 {
-    (void) category;
+    (void)category;
     const char *retval;
 
     /* The highest priority value is the `LANGUAGE' environment
        variable.  This is a GNU extension.  */
-    retval = getenv (&quot;LANGUAGE&quot;);
+    retval = getenv(&quot;LANGUAGE&quot;);
     if (retval != NULL &amp;&amp; retval[0] != '\0')
-	return retval;
+        return retval;
 
     /* `LANGUAGE' is not set.  So we have to proceed with the POSIX
        methods of looking to `LC_ALL', `LC_xxx', and `LANG'.  On some
        systems this can be done by the `setlocale' function itself.  */
 #if defined HAVE_SETLOCALE &amp;&amp; defined HAVE_LC_MESSAGES &amp;&amp; defined HAVE_LOCALE_NULL
-    retval = setlocale (category, NULL);
+    retval = setlocale(category, NULL);
     if (retval != NULL)
-      return retval;
+        return retval;
     else
-      return &quot;C&quot;;
+        return &quot;C&quot;;
 #else
     /* Setting of LC_ALL overwrites all other.  */
-    retval = getenv (&quot;LC_ALL&quot;);
+    retval = getenv(&quot;LC_ALL&quot;);
     if (retval != NULL &amp;&amp; retval[0] != '\0')
-	return retval;
+        return retval;
 
     /* Next comes the name of the desired category.  */
-    retval = getenv (categoryname);
+    retval = getenv(categoryname);
     if (retval != NULL &amp;&amp; retval[0] != '\0')
-	return retval;
+        return retval;
 
     /* Last possibility is the LANG environment variable.  */
-    retval = getenv (&quot;LANG&quot;);
+    retval = getenv(&quot;LANG&quot;);
     if (retval != NULL &amp;&amp; retval[0] != '\0')
-	return retval;
+        return retval;
 
     /* We use C as the default domain.  POSIX says this is implementation
        defined.  */
@@ -392,179 +373,168 @@
 
 /* GCS:  This function is modified from gettext.  It finds the language 
    portion of the locale. */
-static void 
-lincity_nl_find_language (char *name)
+static void lincity_nl_find_language(char *name)
 {
-  while (name[0] != '\0' &amp;&amp; name[0] != '_' &amp;&amp; name[0] != '@'
-	 &amp;&amp; name[0] != '+' &amp;&amp; name[0] != ',')
-    ++name;
+    while (name[0] != '\0' &amp;&amp; name[0] != '_' &amp;&amp; name[0] != '@' &amp;&amp; name[0] != '+' &amp;&amp; name[0] != ',')
+        ++name;
 
-  *name = '\0';
+    *name = '\0';
 }
 
-void
-find_localized_paths (void)
+void find_localized_paths(void)
 {
-  int messages_done = 0;
-  int help_done = 0;
+    int messages_done = 0;
+    int help_done = 0;
 
-  const char* intl_suffix = &quot;&quot;;
-  char intl_lang[128];
+    const char *intl_suffix = &quot;&quot;;
+    char intl_lang[128];
 
-  /* First, try the locale &quot;as is&quot; */
+    /* First, try the locale &quot;as is&quot; */
 #if defined (ENABLE_NLS) &amp;&amp; defined (HAVE_LC_MESSAGES)
-  intl_suffix = guess_category_value(LC_MESSAGES,&quot;LC_MESSAGES&quot;);
+    intl_suffix = guess_category_value(LC_MESSAGES, &quot;LC_MESSAGES&quot;);
 #else
-  intl_suffix = guess_category_value(0,&quot;LC_MESSAGES&quot;);
+    intl_suffix = guess_category_value(0, &quot;LC_MESSAGES&quot;);
 #endif
-  debug_printf (&quot;GUESS 1 -- intl_suffix is %s\n&quot;, intl_suffix);
-  if (strcmp(intl_suffix,&quot;C&quot;) &amp;&amp; strcmp(intl_suffix,&quot;&quot;)) {
-    snprintf (message_path, sizeof(message_path), &quot;%s%c%s%c%s%c&quot;, LIBDIR,
-	      PATH_SLASH, &quot;messages&quot;, PATH_SLASH, intl_suffix, PATH_SLASH);
-    debug_printf (&quot;Trying Message Path %s\n&quot;, message_path);
-    if (directory_exists(message_path)) {
-      debug_printf (&quot;Set Message Path %s\n&quot;, message_path);
-      messages_done = 1;
+    debug_printf(&quot;GUESS 1 -- intl_suffix is %s\n&quot;, intl_suffix);
+    if (strcmp(intl_suffix, &quot;C&quot;) &amp;&amp; strcmp(intl_suffix, &quot;&quot;)) {
+        snprintf(message_path, sizeof(message_path), &quot;%s%c%s%c%s%c&quot;, LIBDIR,
+                 PATH_SLASH, &quot;messages&quot;, PATH_SLASH, intl_suffix, PATH_SLASH);
+        debug_printf(&quot;Trying Message Path %s\n&quot;, message_path);
+        if (directory_exists(message_path)) {
+            debug_printf(&quot;Set Message Path %s\n&quot;, message_path);
+            messages_done = 1;
+        }
+        snprintf(help_path, sizeof(help_path), &quot;%s%c%s%c%s%c&quot;, LIBDIR, PATH_SLASH,
+                 &quot;help&quot;, PATH_SLASH, intl_suffix, PATH_SLASH);
+        debug_printf(&quot;Trying Help Path %s\n&quot;, help_path);
+        if (directory_exists(help_path)) {
+            debug_printf(&quot;Set Help Path %s\n&quot;, help_path);
+            help_done = 1;
+        }
     }
-    snprintf (help_path, sizeof(help_path), &quot;%s%c%s%c%s%c&quot;, LIBDIR, PATH_SLASH,
-	      &quot;help&quot;, PATH_SLASH, intl_suffix, PATH_SLASH);
-    debug_printf (&quot;Trying Help Path %s\n&quot;, help_path);
-    if (directory_exists(help_path)) {
-      debug_printf (&quot;Set Help Path %s\n&quot;, help_path);
-      help_done = 1;
+    if (messages_done &amp;&amp; help_done)
+        return;
+
+    /* Next, try stripping off the country suffix */
+    strncpy(intl_lang, intl_suffix, 128);
+    intl_lang[127] = '\0';
+    lincity_nl_find_language(intl_lang);
+    intl_suffix = intl_lang;
+    debug_printf(&quot;GUESS 2 -- intl_suffix is %s\n&quot;, intl_suffix);
+    if (strcmp(intl_suffix, &quot;C&quot;) &amp;&amp; strcmp(intl_suffix, &quot;&quot;)) {
+        if (!messages_done) {
+            sprintf(message_path, &quot;%s%c%s%c%s%c&quot;, LIBDIR, PATH_SLASH, &quot;messages&quot;, PATH_SLASH, intl_suffix, PATH_SLASH);
+            debug_printf(&quot;Trying Message Path %s\n&quot;, message_path);
+            if (directory_exists(message_path)) {
+                debug_printf(&quot;Set Message Path %s\n&quot;, message_path);
+                messages_done = 1;
+            }
+        }
+        if (!help_done) {
+            sprintf(help_path, &quot;%s%c%s%c%s%c&quot;, LIBDIR, PATH_SLASH, &quot;help&quot;, PATH_SLASH, intl_suffix, PATH_SLASH);
+            debug_printf(&quot;Trying Help Path %s\n&quot;, help_path);
+            if (directory_exists(help_path)) {
+                debug_printf(&quot;Set Help Path %s\n&quot;, help_path);
+                help_done = 1;
+            }
+        }
     }
-  }
-  if (messages_done &amp;&amp; help_done) return;
+    if (messages_done &amp;&amp; help_done)
+        return;
 
-  /* Next, try stripping off the country suffix */
-  strncpy (intl_lang, intl_suffix, 128);
-  intl_lang[127] = '\0';
-  lincity_nl_find_language (intl_lang);
-  intl_suffix = intl_lang;
-  debug_printf (&quot;GUESS 2 -- intl_suffix is %s\n&quot;, intl_suffix);
-  if (strcmp(intl_suffix,&quot;C&quot;) &amp;&amp; strcmp(intl_suffix,&quot;&quot;)) {
+    /* Finally, settle for default English messages */
     if (!messages_done) {
-      sprintf (message_path, &quot;%s%c%s%c%s%c&quot;, LIBDIR, PATH_SLASH, &quot;messages&quot;,
-	       PATH_SLASH, intl_suffix, PATH_SLASH);
-      debug_printf (&quot;Trying Message Path %s\n&quot;, message_path);
-      if (directory_exists(message_path)) {
-	debug_printf (&quot;Set Message Path %s\n&quot;, message_path);
-	messages_done = 1;
-      }
+        sprintf(message_path, &quot;%s%c%s%c&quot;, LIBDIR, PATH_SLASH, &quot;messages&quot;, PATH_SLASH);
+        debug_printf(&quot;Settling for message Path %s\n&quot;, message_path);
     }
     if (!help_done) {
-      sprintf (help_path, &quot;%s%c%s%c%s%c&quot;, LIBDIR, PATH_SLASH, &quot;help&quot;,
-	       PATH_SLASH, intl_suffix, PATH_SLASH);
-      debug_printf (&quot;Trying Help Path %s\n&quot;, help_path);
-      if (directory_exists(help_path)) {
-	debug_printf (&quot;Set Help Path %s\n&quot;, help_path);
-	help_done = 1;
-      }
+        sprintf(help_path, &quot;%s%c%s%c&quot;, LIBDIR, PATH_SLASH, &quot;help&quot;, PATH_SLASH);
+        debug_printf(&quot;Settling for help Path %s\n&quot;, help_path);
     }
-  }
-  if (messages_done &amp;&amp; help_done) return;
-    
-  /* Finally, settle for default English messages */
-  if (!messages_done) {
-    sprintf (message_path, &quot;%s%c%s%c&quot;, LIBDIR, PATH_SLASH, &quot;messages&quot;,
-	     PATH_SLASH);
-    debug_printf (&quot;Settling for message Path %s\n&quot;, message_path);
-  }
-  if (!help_done) {
-    sprintf (help_path, &quot;%s%c%s%c&quot;, LIBDIR, PATH_SLASH, &quot;help&quot;,
-	     PATH_SLASH);
-    debug_printf (&quot;Settling for help Path %s\n&quot;, help_path);
-  }
 }
 
-void
-init_path_strings (void)
+void init_path_strings(void)
 {
-    char* homedir = NULL;
+    char *homedir = NULL;
 
-    find_libdir ();
+    find_libdir();
 
 #if defined (WIN32)
     homedir = LIBDIR;
 #elif defined (__EMX__)
-    homedir = getenv (&quot;HOME&quot;);
+    homedir = getenv(&quot;HOME&quot;);
 #else
-    homedir = getenv (&quot;HOME&quot;);
+    homedir = getenv(&quot;HOME&quot;);
 #endif
 
     /* Various dirs and files */
-    lc_save_dir_len = strlen (homedir) + strlen (LC_SAVE_DIR) + 1;
-    if ((lc_save_dir = (char *) malloc (lc_save_dir_len + 1)) == 0)
-	malloc_failure ();
-    sprintf (lc_save_dir, &quot;%s%c%s&quot;, homedir, PATH_SLASH, LC_SAVE_DIR);
-    sprintf (colour_pal_file, &quot;%s%c%s&quot;, LIBDIR, PATH_SLASH, &quot;colour.pal&quot;);
-    sprintf (opening_path, &quot;%s%c%s&quot;, LIBDIR, PATH_SLASH, &quot;opening&quot;);
+    lc_save_dir_len = strlen(homedir) + strlen(LC_SAVE_DIR) + 1;
+    if ((lc_save_dir = (char *)malloc(lc_save_dir_len + 1)) == 0)
+        malloc_failure();
+    sprintf(lc_save_dir, &quot;%s%c%s&quot;, homedir, PATH_SLASH, LC_SAVE_DIR);
+    sprintf(colour_pal_file, &quot;%s%c%s&quot;, LIBDIR, PATH_SLASH, &quot;colour.pal&quot;);
+    sprintf(opening_path, &quot;%s%c%s&quot;, LIBDIR, PATH_SLASH, &quot;opening&quot;);
 #if defined (WIN32)
-    sprintf (opening_pic, &quot;%s%c%s&quot;,opening_path,PATH_SLASH,&quot;open.tga&quot;);
+    sprintf(opening_pic, &quot;%s%c%s&quot;, opening_path, PATH_SLASH, &quot;open.tga&quot;);
 #else
-    sprintf (opening_pic, &quot;%s%c%s&quot;,opening_path,PATH_SLASH,&quot;open.tga.gz&quot;);
+    sprintf(opening_pic, &quot;%s%c%s&quot;, opening_path, PATH_SLASH, &quot;open.tga.gz&quot;);
 #endif
-    sprintf (graphic_path, &quot;%s%c%s%c&quot;, LIBDIR, PATH_SLASH, &quot;icons&quot;,
-	     PATH_SLASH);
-    sprintf (lincityrc_file, &quot;%s%c%s&quot;, homedir, PATH_SLASH, 
-	LINCITYRC_FILENAME);
+    sprintf(graphic_path, &quot;%s%c%s%c&quot;, LIBDIR, PATH_SLASH, &quot;icons&quot;, PATH_SLASH);
+    sprintf(lincityrc_file, &quot;%s%c%s&quot;, homedir, PATH_SLASH, LINCITYRC_FILENAME);
 
     /* Paths for message &amp; help files, etc */
-    find_localized_paths ();
+    find_localized_paths();
 
     /* Font stuff */
-    sprintf (fontfile, &quot;%s%c%s&quot;, opening_path, PATH_SLASH,
-	     &quot;iso8859-1-8x8.raw&quot;);
+    sprintf(fontfile, &quot;%s%c%s&quot;, opening_path, PATH_SLASH, &quot;iso8859-1-8x8.raw&quot;);
 #if defined (WIN32)
     /* GCS: Use windows font for extra speed */
-    strcpy (windowsfontfile, LIBDIR);
+    strcpy(windowsfontfile, LIBDIR);
 #if defined (commentout)
     if (!pix_double)
-	strcat (windowsfontfile, &quot;\\opening\\iso8859-1-8x8.fnt&quot;);
+        strcat(windowsfontfile, &quot;\\opening\\iso8859-1-8x8.fnt&quot;);
     else
-	strcat (windowsfontfile, &quot;\\opening\\iso8859-1-9x15.fnt&quot;);
+        strcat(windowsfontfile, &quot;\\opening\\iso8859-1-9x15.fnt&quot;);
 #endif
     if (!pix_double)
-	strcat (windowsfontfile, &quot;\\opening\\winfont_8x8.fnt&quot;);
+        strcat(windowsfontfile, &quot;\\opening\\winfont_8x8.fnt&quot;);
     else
-	strcat (windowsfontfile, &quot;\\opening\\winfont_16x16.fnt&quot;);
+        strcat(windowsfontfile, &quot;\\opening\\winfont_16x16.fnt&quot;);
 #endif
 
     /* Temp file for results */
-    lc_temp_filename = (char *) malloc (lc_save_dir_len + 16);
+    lc_temp_filename = (char *)malloc(lc_save_dir_len + 16);
     if (lc_temp_filename == 0) {
-	malloc_failure ();
+        malloc_failure();
     }
-    sprintf (lc_temp_filename, &quot;%s%c%s&quot;, lc_save_dir, PATH_SLASH, &quot;tmp-file&quot;);
+    sprintf(lc_temp_filename, &quot;%s%c%s&quot;, lc_save_dir, PATH_SLASH, &quot;tmp-file&quot;);
 
     /* Path for localization */
 #if defined (ENABLE_NLS)
 #if defined (WIN32)
-    sprintf (lc_textdomain_directory, &quot;%s%c%s&quot;, LIBDIR, PATH_SLASH, &quot;locale&quot;);
+    sprintf(lc_textdomain_directory, &quot;%s%c%s&quot;, LIBDIR, PATH_SLASH, &quot;locale&quot;);
 #else
-    strcpy (lc_textdomain_directory, LOCALEDIR);
+    strcpy(lc_textdomain_directory, LOCALEDIR);
 #endif
-    char* dm = NULL;
-    char* td = NULL;    
-    dm = bindtextdomain (PACKAGE, lc_textdomain_directory);
-    debug_printf (&quot;Bound textdomain directory is %s\n&quot;, dm);
-    td = textdomain (PACKAGE);
-    debug_printf (&quot;Textdomain is %s\n&quot;, td);
+    char *dm = NULL;
+    char *td = NULL;
+    dm = bindtextdomain(PACKAGE, lc_textdomain_directory);
+    debug_printf(&quot;Bound textdomain directory is %s\n&quot;, dm);
+    td = textdomain(PACKAGE);
+    debug_printf(&quot;Textdomain is %s\n&quot;, td);
 #endif
 }
 
-void
-verify_package (void)
+void verify_package(void)
 {
-    FILE *fp = fopen (colour_pal_file,&quot;rb&quot;);
+    FILE *fp = fopen(colour_pal_file, &quot;rb&quot;);
     if (!fp) {
-	do_error (_(&quot;Error verifying package. Can't find colour.pal.&quot;));
+        do_error(_(&quot;Error verifying package. Can't find colour.pal.&quot;));
     }
-    fclose (fp);
+    fclose(fp);
 }
 
-void
-make_savedir (void)
+void make_savedir(void)
 {
 #if !defined (WIN32)
     DIR *dp;
@@ -572,24 +542,23 @@
 
 #if defined (commentout)
     if (make_dir_ok_flag == 0)
-	return;
+        return;
 #endif
 
 #if defined (WIN32)
-    if (_mkdir (lc_save_dir) == -1 &amp;&amp; errno != EEXIST) {
-	printf (_(&quot;Couldn't create the save directory '%s'\n&quot;), lc_save_dir);
-	exit (-1);
+    if (_mkdir(lc_save_dir) == -1 &amp;&amp; errno != EEXIST) {
+        printf(_(&quot;Couldn't create the save directory '%s'\n&quot;), lc_save_dir);
+        exit(-1);
     }
 #else
-    mkdir (lc_save_dir, 0755);
-    chown (lc_save_dir, getuid (), getgid ());
-    if ((dp = opendir (lc_save_dir)) == NULL)
-    {
-	/* change this to a screen message. */
-	printf (_(&quot;Couldn't create the save directory '%s'\n&quot;), lc_save_dir);
-	exit (1);
+    mkdir(lc_save_dir, 0755);
+    chown(lc_save_dir, getuid(), getgid());
+    if ((dp = opendir(lc_save_dir)) == NULL) {
+        /* change this to a screen message. */
+        printf(_(&quot;Couldn't create the save directory '%s'\n&quot;), lc_save_dir);
+        exit(1);
     }
-    closedir (dp);
+    closedir(dp);
 #endif
 
 #if defined (commentout)
@@ -597,70 +566,65 @@
 #endif
 }
 
-void
-check_savedir (void)
+void check_savedir(void)
 {
 #if defined (commentout)
     int i = 0, j, k, r, l;
 #endif
 
-    if (!directory_exists (lc_save_dir)) {
-	make_savedir ();
+    if (!directory_exists(lc_save_dir)) {
+        make_savedir();
 #if defined (commentout)
-	l = lc_save_dir_len;
-	if (l &gt; 160) {
-	    i = l - 160;
-	    l = 160;
-	}
-	askdir_lines = l / 40 + ((l % 40) ? 1 : 0);
-	r = l / askdir_lines + ((l % askdir_lines) ? 1 : 0);
-	for (j = 0; j &lt; askdir_lines; j++) {
-	    if ((askdir_path[j] = (char *) malloc (r + 1)) == 0)
-		malloc_failure ();
-	    for (k = 0; k &lt; r; k++, i++)
-		*(askdir_path[j] + k) = lc_save_dir[i];
-	    *(askdir_path[j] + k) = 0;
-	}
-	return;
+        l = lc_save_dir_len;
+        if (l &gt; 160) {
+            i = l - 160;
+            l = 160;
+        }
+        askdir_lines = l / 40 + ((l % 40) ? 1 : 0);
+        r = l / askdir_lines + ((l % askdir_lines) ? 1 : 0);
+        for (j = 0; j &lt; askdir_lines; j++) {
+            if ((askdir_path[j] = (char *)malloc(r + 1)) == 0)
+                malloc_failure();
+            for (k = 0; k &lt; r; k++, i++)
+                *(askdir_path[j] + k) = lc_save_dir[i];
+            *(askdir_path[j] + k) = 0;
+        }
+        return;
 #endif
     }
 #if defined (commentout)
-    make_dir_ok_flag = 0;		/* don't load the ask-dir */
+    make_dir_ok_flag = 0;       /* don't load the ask-dir */
 #endif
 }
 
-void
-malloc_failure (void)
+void malloc_failure(void)
 {
-  printf (_(&quot;Out of memory: malloc failure\n&quot;));
-  exit (1);
+    printf(_(&quot;Out of memory: malloc failure\n&quot;));
+    exit(1);
 }
 
-char*
-load_graphic(char *s)
+char *load_graphic(char *s)
 {
-    int x,l;
-    char ss[LC_PATH_MAX],*graphic;
+    int x, l;
+    char ss[LC_PATH_MAX], *graphic;
     FILE *inf;
-    strcpy(ss,graphic_path);
-    strcat(ss,s);
-    if ((inf=fopen(ss,&quot;rb&quot;))==NULL)
-    {
-	strcat(ss,&quot; -- UNABLE TO LOAD&quot;);
-	do_error(ss);
+    strcpy(ss, graphic_path);
+    strcat(ss, s);
+    if ((inf = fopen(ss, &quot;rb&quot;)) == NULL) {
+        strcat(ss, &quot; -- UNABLE TO LOAD&quot;);
+        do_error(ss);
     }
-    fseek(inf,0L,SEEK_END);
-    l=ftell(inf);
-    fseek(inf,0L,SEEK_SET);
-    graphic=(char *)malloc(l);
-    for (x=0;x&lt;l;x++)
-	*(graphic+x)=fgetc(inf);
+    fseek(inf, 0L, SEEK_END);
+    l = ftell(inf);
+    fseek(inf, 0L, SEEK_SET);
+    graphic = (char *)malloc(l);
+    for (x = 0; x &lt; l; x++)
+        *(graphic + x) = fgetc(inf);
     fclose(inf);
-    return(graphic);
+    return (graphic);
 }
 
-void
-load_lincityrc (void)
+void load_lincityrc(void)
 {
     //FIXME: this whole function should be moved to oldgui/*, because it contains only things concerning the old gui 
 #if 0
@@ -668,191 +632,159 @@
     int arg;
     char buf[128];
 
-    if ((fp = fopen (lincityrc_file, &quot;r&quot;)) == 0) {
-	save_lincityrc();
-	return;
+    if ((fp = fopen(lincityrc_file, &quot;r&quot;)) == 0) {
+        save_lincityrc();
+        return;
     }
     //FIXME: this whole function should be moved to oldgui/*, because it contains only things concerning the old gui 
 
-    while (fgets (buf,128,fp)) {
-	if (sscanf(buf,&quot;overwrite_transport=%d&quot;,&amp;arg)==1) {
-	    overwrite_transport_flag = !!arg;
-	    continue;
-	}
-	if (sscanf(buf,&quot;no_init_help=%d&quot;,&amp;arg)==1) {
-	// Careful here ... 
-	    no_init_help = !!arg;
-	    continue;
-	}
-	if (sscanf(buf,&quot;skip_splash_screen=%d&quot;,&amp;arg)==1) {
-	    skip_splash_screen = !!arg;
-	    continue;
-	}
-	if (sscanf(buf,&quot;suppress_firsttime_module_help=%d&quot;,&amp;arg)==1) {
-	    suppress_firsttime_module_help = !!arg;
-	    continue;
-	}
-	if (sscanf(buf,&quot;suppress_popups=%d&quot;,&amp;arg)==1) {
-	    suppress_popups = !!arg;
-	    continue;
-	}
-	if (sscanf(buf,&quot;time_multiplex_stats=%d&quot;,&amp;arg)==1) {
-	    time_multiplex_stats = !!arg;
-	    continue;
-	}
-	if (sscanf(buf,&quot;x_confine_pointer=%d&quot;,&amp;arg)==1) {
-	    confine_flag = !!arg;
-	    continue;
-	}
-	if (sscanf(buf,&quot;pix_double=%d&quot;,&amp;arg)==1) {
-	    pix_double = !!arg;
-	    continue;
-	}
-	if (sscanf(buf,&quot;borderx=%d&quot;,&amp;arg)==1) {
-	    if (borderx &gt;= 0) {
-		borderx = arg;
-	    }
-	    continue;
-	}
-	if (sscanf(buf,&quot;bordery=%d&quot;,&amp;arg)==1) {
-	    if (bordery &gt;= 0) {
-		bordery = arg;
-	    }
-	    continue;
-	}
+    while (fgets(buf, 128, fp)) {
+        if (sscanf(buf, &quot;overwrite_transport=%d&quot;, &amp;arg) == 1) {
+            overwrite_transport_flag = !!arg;
+            continue;
+        }
+        if (sscanf(buf, &quot;no_init_help=%d&quot;, &amp;arg) == 1) {
+            // Careful here ... 
+            no_init_help = !!arg;
+            continue;
+        }
+        if (sscanf(buf, &quot;skip_splash_screen=%d&quot;, &amp;arg) == 1) {
+            skip_splash_screen = !!arg;
+            continue;
+        }
+        if (sscanf(buf, &quot;suppress_firsttime_module_help=%d&quot;, &amp;arg) == 1) {
+            suppress_firsttime_module_help = !!arg;
+            continue;
+        }
+        if (sscanf(buf, &quot;suppress_popups=%d&quot;, &amp;arg) == 1) {
+            suppress_popups = !!arg;
+            continue;
+        }
+        if (sscanf(buf, &quot;time_multiplex_stats=%d&quot;, &amp;arg) == 1) {
+            time_multiplex_stats = !!arg;
+            continue;
+        }
+        if (sscanf(buf, &quot;x_confine_pointer=%d&quot;, &amp;arg) == 1) {
+            confine_flag = !!arg;
+            continue;
+        }
+        if (sscanf(buf, &quot;pix_double=%d&quot;, &amp;arg) == 1) {
+            pix_double = !!arg;
+            continue;
+        }
+        if (sscanf(buf, &quot;borderx=%d&quot;, &amp;arg) == 1) {
+            if (borderx &gt;= 0) {
+                borderx = arg;
+            }
+            continue;
+        }
+        if (sscanf(buf, &quot;bordery=%d&quot;, &amp;arg) == 1) {
+            if (bordery &gt;= 0) {
+                bordery = arg;
+            }
+            continue;
+        }
     }
-    fclose (fp);
+    fclose(fp);
 #endif
 }
 
-void
-save_lincityrc (void)
+void save_lincityrc(void)
 {
     //FIXME: this whole function should be moved to oldgui/*, because it contains only things concerning the old gui 
-    
+
 #if 0
     FILE *fp;
 
-    if ((fp = fopen (lincityrc_file, &quot;w&quot;)) == 0) {
-	return;
+    if ((fp = fopen(lincityrc_file, &quot;w&quot;)) == 0) {
+        return;
     }
 
-    fprintf (fp, 
-	&quot;# Set this if you want to be able to overwrite one\n&quot;
-	&quot;# kind of transport with another.\n&quot;
-	&quot;overwrite_transport=%d\n\n&quot;,
-	overwrite_transport_flag);
-    fprintf (fp, 
-	&quot;# Set this if you don't want the opening help screen.\n&quot;
-	&quot;no_init_help=%d\n\n&quot;,
-	no_init_help
-	);
-    fprintf (fp,
-	&quot;# Set this if you don't want the opening splash screen.\n&quot;
-	&quot;skip_splash_screen=%d\n\n&quot;,
-	skip_splash_screen
-	);
-    fprintf (fp,
-	&quot;# Set this if you don't want help the first time you\n&quot;
-	&quot;# click to place an item.\n&quot;
-	&quot;suppress_firsttime_module_help=%d\n\n&quot;, 
-	suppress_firsttime_module_help
-	);
-    fprintf (fp,
-	&quot;# Set this if don't want modal dialog boxes which you\n&quot;
-	&quot;# are required to click OK.  Instead, report the dialog\n&quot;
-	&quot;# box information to the message area.\n&quot;
-	&quot;suppress_popups=%d\n\n&quot;,
-	suppress_popups
-	);
-    fprintf (fp,
-	&quot;# Set this if want the different statistic windows to cycle\n&quot;
-	&quot;# through the right panel.\n&quot;
-	&quot;time_multiplex_stats=%d\n\n&quot;,
-	time_multiplex_stats
-	);
-    fprintf (fp,
-	&quot;# (X Windows and WIN32 only) Set this if you want pix doubling,\n&quot;
-	&quot;# where each pixel is drawn as a 2x2 square.\n&quot;
-	&quot;pix_double=%d\n\n&quot;,
-	pix_double
-	);
-    fprintf (fp,
-	&quot;# (X Windows and WIN32 only) Set this if you want a blank area\n&quot;
-	&quot;# around the playing area.\n&quot;
-	&quot;borderx=%d\n&quot;
-	&quot;bordery=%d\n\n&quot;,
-	borderx,
-	bordery
-	);
-    fprintf (fp,
-	&quot;# (X Windows only) Set this if you want to confine the pointer\n&quot;
-	&quot;# to within the window.\n&quot;
-	&quot;x_confine_pointer=%d\n\n&quot;,
-	confine_flag
-	);
-    fclose (fp);
+    fprintf(fp,
+            &quot;# Set this if you want to be able to overwrite one\n&quot;
+            &quot;# kind of transport with another.\n&quot; &quot;overwrite_transport=%d\n\n&quot;, overwrite_transport_flag);
+    fprintf(fp, &quot;# Set this if you don't want the opening help screen.\n&quot; &quot;no_init_help=%d\n\n&quot;, no_init_help);
+    fprintf(fp,
+            &quot;# Set this if you don't want the opening splash screen.\n&quot;
+            &quot;skip_splash_screen=%d\n\n&quot;, skip_splash_screen);
+    fprintf(fp,
+            &quot;# Set this if you don't want help the first time you\n&quot;
+            &quot;# click to place an item.\n&quot; &quot;suppress_firsttime_module_help=%d\n\n&quot;, suppress_firsttime_module_help);
+    fprintf(fp,
+            &quot;# Set this if don't want modal dialog boxes which you\n&quot;
+            &quot;# are required to click OK.  Instead, report the dialog\n&quot;
+            &quot;# box information to the message area.\n&quot; &quot;suppress_popups=%d\n\n&quot;, suppress_popups);
+    fprintf(fp,
+            &quot;# Set this if want the different statistic windows to cycle\n&quot;
+            &quot;# through the right panel.\n&quot; &quot;time_multiplex_stats=%d\n\n&quot;, time_multiplex_stats);
+    fprintf(fp,
+            &quot;# (X Windows and WIN32 only) Set this if you want pix doubling,\n&quot;
+            &quot;# where each pixel is drawn as a 2x2 square.\n&quot; &quot;pix_double=%d\n\n&quot;, pix_double);
+    fprintf(fp,
+            &quot;# (X Windows and WIN32 only) Set this if you want a blank area\n&quot;
+            &quot;# around the playing area.\n&quot; &quot;borderx=%d\n&quot; &quot;bordery=%d\n\n&quot;, borderx, bordery);
+    fprintf(fp,
+            &quot;# (X Windows only) Set this if you want to confine the pointer\n&quot;
+            &quot;# to within the window.\n&quot; &quot;x_confine_pointer=%d\n\n&quot;, confine_flag);
+    fclose(fp);
 #endif
 }
 
-void
-undosify_string (char *s)
+void undosify_string(char *s)
 {
     /* Convert '\r\n' to '\n' in string */
     char prev_char = 0;
     char *p = s, *q = s;
     while (*p) {
-	if (*p != '\r') {
-	    if (prev_char == '\r' &amp;&amp; *p != '\n') {
-		*q++ = '\n';
-	    }
-	    *q++ = *p;
-	}
-	prev_char = *p;
+        if (*p != '\r') {
+            if (prev_char == '\r' &amp;&amp; *p != '\n') {
+                *q++ = '\n';
+            }
+            *q++ = *p;
+        }
+        prev_char = *p;
         p++;
     }
     if (prev_char == '\r') {
-	*q++ = '\n';
+        *q++ = '\n';
     }
     *q = '\0';
 }
 
-void
-debug_printf (char* fmt, ...)
+void debug_printf(char *fmt, ...)
 {
-    (void) fmt;
+    (void)fmt;
 #if (DEBUG_PRINTF_TO_FILE)
     static int initialized = 0;
-    char* filename = &quot;debug.txt&quot;;
-    FILE* fp;
+    char *filename = &quot;debug.txt&quot;;
+    FILE *fp;
 #endif
     va_list argptr;
-    (void) argptr;
+    (void)argptr;
 
 #if (DEBUG_PRINTF_TO_FILE)
-    va_start (argptr, fmt);
+    va_start(argptr, fmt);
     fp = fopen(filename, &quot;a&quot;);
     if (!initialized) {
-	initialized = 1;
-	fprintf (fp, &quot;=========================\n&quot;);
+        initialized = 1;
+        fprintf(fp, &quot;=========================\n&quot;);
     }
-    vfprintf (fp, fmt, argptr);
+    vfprintf(fp, fmt, argptr);
 #endif
 
     /* FIXME: maybe uncomment this 
-    if (command_line_debug) {
-#if (!DEBUG_PRINTF_TO_FILE)
-      va_start (argptr, fmt);
-#endif
-      vprintf (fmt, argptr);
-#if (!DEBUG_PRINTF_TO_FILE)
-      va_end (argptr);
-#endif
-    }
-    */
+       if (command_line_debug) {
+       #if (!DEBUG_PRINTF_TO_FILE)
+       va_start (argptr, fmt);
+       #endif
+       vprintf (fmt, argptr);
+       #if (!DEBUG_PRINTF_TO_FILE)
+       va_end (argptr);
+       #endif
+       }
+     */
 #if (DEBUG_PRINTF_TO_FILE)
-    va_end (argptr);
-    fclose (fp);
+    va_end(argptr);
+    fclose(fp);
 #endif
 }
-

Modified: trunk/src/lincity/fileutil.h
===================================================================
--- trunk/src/lincity/fileutil.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/fileutil.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -12,11 +12,11 @@
 //extern int make_dir_ok_flag;
 
 /* Try to find the maximum file name from OS */
-#if defined (_POSIX_PATH_MAX)          /* Posix */
+#if defined (_POSIX_PATH_MAX)   /* Posix */
 #define LC_PATH_MAX _POSIX_PATH_MAX
-#elif defined (_MAX_PATH)              /* Win32 */
+#elif defined (_MAX_PATH)       /* Win32 */
 #define LC_PATH_MAX _MAX_PATH
-#elif defined (PATH_MAX)               /* X Windows */
+#elif defined (PATH_MAX)        /* X Windows */
 #define LC_PATH_MAX PATH_MAX
 #else
 #define LC_PATH_MAX 4096
@@ -34,13 +34,13 @@
 extern char given_scene[LC_PATH_MAX];
 
 //void gunzip_file (char *f1, char *f2); //unused function
-int file_exists (char *filename);
-int directory_exists (char *dir);
-char* load_graphic(char *s);
+int file_exists(char *filename);
+int directory_exists(char *dir);
+char *load_graphic(char *s);
 void undosify_string(char *s);
-void load_lincityrc (void);
-void save_lincityrc (void);
+void load_lincityrc(void);
+void save_lincityrc(void);
 
-void debug_printf (char* fmt, ...);
+void debug_printf(char *fmt, ...);
 
-#endif	/* __fileutil_h__ */
+#endif /* __fileutil_h__ */

Modified: trunk/src/lincity/getopt.cpp
===================================================================
--- trunk/src/lincity/getopt.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/getopt.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -29,8 +29,8 @@
  *                 John Q. Walker II, Ph.D. (JOHHQ at RALVM6) 
  *                 Internet: <A HREF="https://lists.berlios.de/mailman/listinfo/lincity-ng-commit">johnq at ralvm6.vnet.ibm.com</A> 
  * 
- *****************************************************************************/ 
- 
+ *****************************************************************************/
+
 /****************************************************************************** 
  * getopt() 
  * 
@@ -66,112 +66,105 @@
  * Options are marked by either a minus sign (-) or a slash (/). 
  * 
  * No errors are defined. 
- *****************************************************************************/ 
- 
-#include &lt;stdio.h&gt;                  /* for EOF */ 
-#include &lt;string.h&gt;                 /* for strchr() */ 
- 
- 
-/* static (global) variables that are specified as exported by getopt() */ 
-char *optarg = NULL;    /* pointer to the start of the option argument  */ 
-int   optind = 1;       /* number of the next argv[] to be evaluated    */ 
-int   opterr = 1;       /* non-zero if a question mark should be returned 
-                           when a non-valid option character is detected */ 
- 
-/* handle possible future character set concerns by putting this in a macro */ 
-#define _next_char(string)  (char)(*(string+1)) 
- 
-int getopt(int argc, char *argv[], char *opstring) 
-{ 
-    static char *pIndexPosition = NULL; /* place inside current argv string */ 
-    char *pArgString = NULL;        /* where to start from next */ 
-    char *pOptString;               /* the string in our program */ 
- 
- 
-    if (pIndexPosition != NULL) { 
-        /* we last left off inside an argv string */ 
-        if (*(++pIndexPosition)) { 
-            /* there is more to come in the most recent argv */ 
-            pArgString = pIndexPosition; 
-        } 
-    } 
- 
-    if (pArgString == NULL) { 
-        /* we didn't leave off in the middle of an argv string */ 
-        if (optind &gt;= argc) { 
-            /* more command-line arguments than the argument count */ 
-            pIndexPosition = NULL;  /* not in the middle of anything */ 
-            return EOF;             /* used up all command-line arguments */ 
-        } 
- 
+ *****************************************************************************/
+
+#include &lt;stdio.h&gt;              /* for EOF */
+#include &lt;string.h&gt;             /* for strchr() */
+
+/* static (global) variables that are specified as exported by getopt() */
+char *optarg = NULL;            /* pointer to the start of the option argument  */
+int optind = 1;                 /* number of the next argv[] to be evaluated    */
+int opterr = 1;                 /* non-zero if a question mark should be returned 
+                                   when a non-valid option character is detected */
+
+/* handle possible future character set concerns by putting this in a macro */
+#define _next_char(string)  (char)(*(string+1))
+
+int getopt(int argc, char *argv[], char *opstring)
+{
+    static char *pIndexPosition = NULL; /* place inside current argv string */
+    char *pArgString = NULL;    /* where to start from next */
+    char *pOptString;           /* the string in our program */
+
+    if (pIndexPosition != NULL) {
+        /* we last left off inside an argv string */
+        if (*(++pIndexPosition)) {
+            /* there is more to come in the most recent argv */
+            pArgString = pIndexPosition;
+        }
+    }
+
+    if (pArgString == NULL) {
+        /* we didn't leave off in the middle of an argv string */
+        if (optind &gt;= argc) {
+            /* more command-line arguments than the argument count */
+            pIndexPosition = NULL;      /* not in the middle of anything */
+            return EOF;         /* used up all command-line arguments */
+        }
+
         /*--------------------------------------------------------------------- 
          * If the next argv[] is not an option, there can be no more options. 
-         *-------------------------------------------------------------------*/ 
-        pArgString = argv[optind++]; /* set this to the next argument ptr */ 
- 
-        if (('/' != *pArgString) &amp;&amp; /* doesn't start with a slash or a dash? */ 
-            ('-' != *pArgString)) { 
-            --optind;               /* point to current arg once we're done */ 
-            optarg = NULL;          /* no argument follows the option */ 
-            pIndexPosition = NULL;  /* not in the middle of anything */ 
-            return EOF;             /* used up all the command-line flags */ 
-        } 
- 
-        /* check for special end-of-flags markers */ 
-        if ((strcmp(pArgString, &quot;-&quot;) == 0) || 
-            (strcmp(pArgString, &quot;--&quot;) == 0)) { 
-            optarg = NULL;          /* no argument follows the option */ 
-            pIndexPosition = NULL;  /* not in the middle of anything */ 
-            return EOF;             /* encountered the special flag */ 
-        } 
- 
-        pArgString++;               /* look past the / or - */ 
-    } 
- 
-    if (':' == *pArgString) {       /* is it a colon? */ 
+         *-------------------------------------------------------------------*/
+        pArgString = argv[optind++];    /* set this to the next argument ptr */
+
+        if (('/' != *pArgString) &amp;&amp;     /* doesn't start with a slash or a dash? */
+            ('-' != *pArgString)) {
+            --optind;           /* point to current arg once we're done */
+            optarg = NULL;      /* no argument follows the option */
+            pIndexPosition = NULL;      /* not in the middle of anything */
+            return EOF;         /* used up all the command-line flags */
+        }
+
+        /* check for special end-of-flags markers */
+        if ((strcmp(pArgString, &quot;-&quot;) == 0) || (strcmp(pArgString, &quot;--&quot;) == 0)) {
+            optarg = NULL;      /* no argument follows the option */
+            pIndexPosition = NULL;      /* not in the middle of anything */
+            return EOF;         /* encountered the special flag */
+        }
+
+        pArgString++;           /* look past the / or - */
+    }
+
+    if (':' == *pArgString) {   /* is it a colon? */
         /*--------------------------------------------------------------------- 
          * Rare case: if opterr is non-zero, return a question mark; 
          * otherwise, just return the colon we're on. 
-         *-------------------------------------------------------------------*/ 
-        return (opterr ? (int)'?' : (int)':'); 
-    } 
-    else if ((pOptString = strchr(opstring, *pArgString)) == 0) { 
+         *-------------------------------------------------------------------*/
+        return (opterr ? (int)'?' : (int)':');
+    } else if ((pOptString = strchr(opstring, *pArgString)) == 0) {
         /*--------------------------------------------------------------------- 
          * The letter on the command-line wasn't any good. 
-         *-------------------------------------------------------------------*/ 
-        optarg = NULL;              /* no argument follows the option */ 
-        pIndexPosition = NULL;      /* not in the middle of anything */ 
-        return (opterr ? (int)'?' : (int)*pArgString); 
-    } 
-    else { 
+         *-------------------------------------------------------------------*/
+        optarg = NULL;          /* no argument follows the option */
+        pIndexPosition = NULL;  /* not in the middle of anything */
+        return (opterr ? (int)'?' : (int)*pArgString);
+    } else {
         /*--------------------------------------------------------------------- 
          * The letter on the command-line matches one we expect to see 
-         *-------------------------------------------------------------------*/ 
-        if (':' == _next_char(pOptString)) { /* is the next letter a colon? */ 
-            /* It is a colon.  Look for an argument string. */ 
-            if ('\0' != _next_char(pArgString)) {  /* argument in this argv? */ 
-                optarg = &amp;pArgString[1];   /* Yes, it is */ 
-            } 
-            else { 
+         *-------------------------------------------------------------------*/
+        if (':' == _next_char(pOptString)) {    /* is the next letter a colon? */
+            /* It is a colon.  Look for an argument string. */
+            if ('\0' != _next_char(pArgString)) {       /* argument in this argv? */
+                optarg = &amp;pArgString[1];        /* Yes, it is */
+            } else {
                 /*------------------------------------------------------------- 
                  * The argument string must be in the next argv. 
                  * But, what if there is none (bad input from the user)? 
                  * In that case, return the letter, and optarg as NULL. 
-                 *-----------------------------------------------------------*/ 
-                if (optind &lt; argc) 
-                    optarg = argv[optind++]; 
-                else { 
-                    optarg = NULL; 
-                    return (opterr ? (int)'?' : (int)*pArgString); 
-                } 
-            } 
-            pIndexPosition = NULL;  /* not in the middle of anything */ 
-        } 
-        else { 
-            /* it's not a colon, so just return the letter */ 
-            optarg = NULL;          /* no argument follows the option */ 
-            pIndexPosition = pArgString;    /* point to the letter we're on */ 
-        } 
-        return (int)*pArgString;    /* return the letter that matched */ 
-    } 
-} 
+                 *-----------------------------------------------------------*/
+                if (optind &lt; argc)
+                    optarg = argv[optind++];
+                else {
+                    optarg = NULL;
+                    return (opterr ? (int)'?' : (int)*pArgString);
+                }
+            }
+            pIndexPosition = NULL;      /* not in the middle of anything */
+        } else {
+            /* it's not a colon, so just return the letter */
+            optarg = NULL;      /* no argument follows the option */
+            pIndexPosition = pArgString;        /* point to the letter we're on */
+        }
+        return (int)*pArgString;        /* return the letter that matched */
+    }
+}

Modified: trunk/src/lincity/lc_common.h
===================================================================
--- trunk/src/lincity/lc_common.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/lc_common.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -31,4 +31,4 @@
 #include &quot;lcsdl.h&quot;
 #endif
 
-#endif	/* __common_h__ */
+#endif /* __common_h__ */

Modified: trunk/src/lincity/lc_locale.cpp
===================================================================
--- trunk/src/lincity/lc_locale.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/lc_locale.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -1,35 +1,34 @@
 #include &quot;lc_locale.h&quot;
 #include &lt;stdlib.h&gt;
 
-void
-lincity_set_locale (void)
+void lincity_set_locale(void)
 {
-    char* locale = NULL;
-    char* localem = NULL;
+    char *locale = NULL;
+    char *localem = NULL;
 #if defined (WIN32)
 #define MAX_LANG_BUF 1024
-    char* language = NULL;
+    char *language = NULL;
     char language_buf[MAX_LANG_BUF];
 #endif
 
 #if defined (ENABLE_NLS)
 #if defined (WIN32)
     /* Some special stoopid way of setting locale for microsoft gettext */
-    language = getenv (&quot;LANGUAGE&quot;);
+    language = getenv(&quot;LANGUAGE&quot;);
     if (language) {
-	debug_printf (&quot;Environment variable LANGUAGE is %s\n&quot;, language);
-	snprintf (language_buf, MAX_LANG_BUF, &quot;LANGUAGE=%s&quot;, language);
-	gettext_putenv(language_buf);
+        debug_printf(&quot;Environment variable LANGUAGE is %s\n&quot;, language);
+        snprintf(language_buf, MAX_LANG_BUF, &quot;LANGUAGE=%s&quot;, language);
+        gettext_putenv(language_buf);
     } else {
-	debug_printf (&quot;Environment variable LANGUAGE not set.\n&quot;);
+        debug_printf(&quot;Environment variable LANGUAGE not set.\n&quot;);
     }
 #else
-    locale = setlocale (LC_ALL, &quot;&quot;);
-    debug_printf (&quot;Setting entire locale to %s\n&quot;, locale);
-    locale = setlocale (LC_MESSAGES, &quot;&quot;);
-    debug_printf (&quot;Setting messages locale to %s\n&quot;, locale);
-    localem = setlocale (LC_MESSAGES, NULL);
-    debug_printf (&quot;Query locale is %s\n&quot;, localem);
+    locale = setlocale(LC_ALL, &quot;&quot;);
+    debug_printf(&quot;Setting entire locale to %s\n&quot;, locale);
+    locale = setlocale(LC_MESSAGES, &quot;&quot;);
+    debug_printf(&quot;Setting messages locale to %s\n&quot;, locale);
+    localem = setlocale(LC_MESSAGES, NULL);
+    debug_printf(&quot;Query locale is %s\n&quot;, localem);
 #endif
 #endif /* ENABLE_NLS */
     return;

Modified: trunk/src/lincity/lc_locale.h
===================================================================
--- trunk/src/lincity/lc_locale.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/lc_locale.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -1,7 +1,6 @@
 #ifndef __LC_LOCALE_H__
 #define __LC_LOCALE_H__
 
-void lincity_set_locale (void);
+void lincity_set_locale(void);
 
-
 #endif

Modified: trunk/src/lincity/lcconfig.h
===================================================================
--- trunk/src/lincity/lcconfig.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/lcconfig.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -18,4 +18,4 @@
 #pragma message(__FILE__ &quot;: deprecated header&quot;)
 #endif
 
-#endif	/* __lcconfig_h__ */
+#endif /* __lcconfig_h__ */

Modified: trunk/src/lincity/lclib.cpp
===================================================================
--- trunk/src/lincity/lclib.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/lclib.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -13,128 +13,147 @@
 #include &quot;lcintl.h&quot;
 #include &quot;lin-city.h&quot;
 
-char *months[] =
-{N_(&quot;Jan&quot;), N_(&quot;Feb&quot;), N_(&quot;Mar&quot;), N_(&quot;Apr&quot;),
-N_(&quot;May&quot;), N_(&quot;Jun&quot;), N_(&quot;Jul&quot;), N_(&quot;Aug&quot;),
-N_(&quot;Sep&quot;), N_(&quot;Oct&quot;), N_(&quot;Nov&quot;), N_(&quot;Dec&quot;)};
+char *months[] = { N_(&quot;Jan&quot;), N_(&quot;Feb&quot;), N_(&quot;Mar&quot;), N_(&quot;Apr&quot;),
+    N_(&quot;May&quot;), N_(&quot;Jun&quot;), N_(&quot;Jul&quot;), N_(&quot;Aug&quot;),
+    N_(&quot;Sep&quot;), N_(&quot;Oct&quot;), N_(&quot;Nov&quot;), N_(&quot;Dec&quot;)
+};
 
-
-const char* 
-current_month (int current_time)
+const char *current_month(int current_time)
 {
     static bool doinit = true;
     if (doinit) {
-	doinit = false;
-	for (int i = 0; i &lt; 12; ++i) {
-	    months[i] = strdup(_(months[i]));
-	}
+        doinit = false;
+        for (int i = 0; i &lt; 12; ++i) {
+            months[i] = strdup(_(months[i]));
+        }
     }
     return months[(current_time % NUMOF_DAYS_IN_YEAR) / NUMOF_DAYS_IN_MONTH];
 }
 
-int 
-current_year (int current_time)
+int current_year(int current_time)
 {
     return current_time / NUMOF_DAYS_IN_YEAR;
 }
 
-void 
-format_number5 (char* str, int num)
+void format_number5(char *str, int num)
 {
     int num_sign = num &gt;= 0 ? 1 : -1;
     if (num_sign == 1) {
-	if (num &lt; 99999) {
-	    sprintf (str, &quot;%5d&quot;, num);
-	} else if (num &lt; 9999999) {
-	    sprintf (str, &quot;%4dK&quot;, num / 1000);
-	} else {
-	    sprintf (str, &quot;%4dM&quot;, num / 1000000);
-	}
+        if (num &lt; 99999) {
+            sprintf(str, &quot;%5d&quot;, num);
+        } else if (num &lt; 9999999) {
+            sprintf(str, &quot;%4dK&quot;, num / 1000);
+        } else {
+            sprintf(str, &quot;%4dM&quot;, num / 1000000);
+        }
     } else {
-	int num_absval = num_sign * num;
-	if (num_absval &lt; 9999) {
-	    sprintf (str, &quot;%5d&quot;, num);
-	} else if (num_absval &lt; 999999) {
-	    sprintf (str, &quot;%4dK&quot;, num_sign * (num_absval / 1000));
-	} else {
-	    sprintf (str, &quot;%4dM&quot;, num_sign * (num_absval / 1000000));
-	}
+        int num_absval = num_sign * num;
+        if (num_absval &lt; 9999) {
+            sprintf(str, &quot;%5d&quot;, num);
+        } else if (num_absval &lt; 999999) {
+            sprintf(str, &quot;%4dK&quot;, num_sign * (num_absval / 1000));
+        } else {
+            sprintf(str, &quot;%4dM&quot;, num_sign * (num_absval / 1000000));
+        }
     }
 }
 
-void 
-num_to_ansi(char * s, size_t size, long num) 
+void num_to_ansi(char *s, size_t size, long num)
 {
-  int triplets = 0;
-  float numf = (float)num;  
+    int triplets = 0;
+    float numf = (float)num;
 
-  while (numf &gt; 1000 || numf &lt; -1000) {
-    numf /= 1000;
-    triplets++;
-  }
+    while (numf &gt; 1000 || numf &lt; -1000) {
+        numf /= 1000;
+        triplets++;
+    }
 
-  switch(triplets) 
-    {
-    case 0: triplets = ' '; break;
-    case 1: triplets = 'k'; break; // kila
-    case 2: triplets = 'm'; break; // mega
-    case 3: triplets = 'g'; break; // giga 
-    case 4: triplets = 't'; break; // tera 
-    case 5: triplets = 'p'; break; // peta
-    default: triplets = '?'; break;
+    switch (triplets) {
+    case 0:
+        triplets = ' ';
+        break;
+    case 1:
+        triplets = 'k';
+        break;                  // kila
+    case 2:
+        triplets = 'm';
+        break;                  // mega
+    case 3:
+        triplets = 'g';
+        break;                  // giga 
+    case 4:
+        triplets = 't';
+        break;                  // tera 
+    case 5:
+        triplets = 'p';
+        break;                  // peta
+    default:
+        triplets = '?';
+        break;
     }
-      
-  if (size == 4) { /* to make up for format_pos_number4.  Eeewwwwwww. */ 
-      if (numf &lt; 10) { 
-	  snprintf(s, size + 1, &quot;%1.1f%c&quot;, numf, triplets);
-      } else {
-	  snprintf(s,size + 1, &quot;%3.0f%c&quot;, numf, triplets);
-      }
-  } else {
-      if (triplets == ' ') {
-	  snprintf(s, size, &quot;%3.1f&quot;, numf);
-      } else {
-	  snprintf(s, size, &quot;%3.1f%c&quot;, numf, triplets);
-      }
-  }
+
+    if (size == 4) {            /* to make up for format_pos_number4.  Eeewwwwwww. */
+        if (numf &lt; 10) {
+            snprintf(s, size + 1, &quot;%1.1f%c&quot;, numf, triplets);
+        } else {
+            snprintf(s, size + 1, &quot;%3.0f%c&quot;, numf, triplets);
+        }
+    } else {
+        if (triplets == ' ') {
+            snprintf(s, size, &quot;%3.1f&quot;, numf);
+        } else {
+            snprintf(s, size, &quot;%3.1f%c&quot;, numf, triplets);
+        }
+    }
 }
 
-void 
-num_to_ansi_unit(char * s, size_t size, long num, char unit) 
+void num_to_ansi_unit(char *s, size_t size, long num, char unit)
 {
-  int triplets = 0;
-  float numf = (float)num;
+    int triplets = 0;
+    float numf = (float)num;
 
-  while (numf &gt; 1000) {
-    numf /= 1000;
-    triplets++;
-  }
+    while (numf &gt; 1000) {
+        numf /= 1000;
+        triplets++;
+    }
 
-  switch(triplets) 
-    {
-    case 0: triplets = ' '; break;
-    case 1: triplets = 'k'; break; // kila
-    case 2: triplets = 'M'; break; // mega
-    case 3: triplets = 'G'; break; // giga 
-    case 4: triplets = 'T'; break; // tera 
-    case 5: triplets = 'P'; break; // peta
-    default: triplets = '?'; break;
+    switch (triplets) {
+    case 0:
+        triplets = ' ';
+        break;
+    case 1:
+        triplets = 'k';
+        break;                  // kila
+    case 2:
+        triplets = 'M';
+        break;                  // mega
+    case 3:
+        triplets = 'G';
+        break;                  // giga 
+    case 4:
+        triplets = 'T';
+        break;                  // tera 
+    case 5:
+        triplets = 'P';
+        break;                  // peta
+    default:
+        triplets = '?';
+        break;
     }
-      
-  if (size == 4)  /* to make up for format_pos_number4 */
-    if (numf &lt; 10) 
-      snprintf(s, size, &quot;%4.1f%c%c&quot;, numf, triplets, unit);
-    else 
-      snprintf(s,size, &quot;%4.0f%c%c&quot;, numf, triplets, unit);
-  else
-    snprintf(s, size, &quot;%5.1f%c%c&quot;, numf, triplets, unit);
+
+    if (size == 4)              /* to make up for format_pos_number4 */
+        if (numf &lt; 10)
+            snprintf(s, size, &quot;%4.1f%c%c&quot;, numf, triplets, unit);
+        else
+            snprintf(s, size, &quot;%4.0f%c%c&quot;, numf, triplets, unit);
+    else
+        snprintf(s, size, &quot;%5.1f%c%c&quot;, numf, triplets, unit);
 }
 
 /* commify: take a number and convert it to a string grouped into triplets
    with commas; returns number of characters written, excluding trailing zero
 */
-int 
-commify (char *str, size_t size, int argnum)
+int commify(char *str, size_t size, int argnum)
 {
     size_t count = 0;
     int i = 0;
@@ -142,87 +161,78 @@
     int num = argnum;
     int kludge = 1;
 
-    if (num &lt; 0) 
-	count += snprintf(str, size, &quot;-&quot;);
+    if (num &lt; 0)
+        count += snprintf(str, size, &quot;-&quot;);
 
     num = abs(argnum);
-    
-    for (; num &gt;= 1000; num /= 1000, triad++, kludge *= 1000);
 
+    for (; num &gt;= 1000; num /= 1000, triad++, kludge *= 1000) ;
+
     num = abs(argnum);
 
     for (; triad &gt; 0; i++, triad--) {
 
-	if (i == 0) 
-	    if (triad == 1)
-		count += snprintf(str + count, size - count, &quot;%d&quot;, num);
-	    else
-		count += snprintf(str + count, size - count, &quot;%d,&quot;, 
-				  num ? num / kludge : num);
-	else if (triad == 1)
-	    count += snprintf(str + count, size - count, &quot;%03d&quot;, 
-			      num ? num / kludge : num);
-	else
-	    count += snprintf(str + count, size - count, &quot;%03d,&quot;,
-			      num ? num / kludge : num);
+        if (i == 0)
+            if (triad == 1)
+                count += snprintf(str + count, size - count, &quot;%d&quot;, num);
+            else
+                count += snprintf(str + count, size - count, &quot;%d,&quot;, num ? num / kludge : num);
+        else if (triad == 1)
+            count += snprintf(str + count, size - count, &quot;%03d&quot;, num ? num / kludge : num);
+        else
+            count += snprintf(str + count, size - count, &quot;%03d,&quot;, num ? num / kludge : num);
 
-	if (num) /* don't divide by zero */
-	    num %= kludge;
+        if (num)                /* don't divide by zero */
+            num %= kludge;
 
-	kludge /= 1000;
+        kludge /= 1000;
     }
 
     return count;
 }
 
 /* GCS - make sure that the string has length at least size-1 */
-void
-pad_with_blanks (char* str, int size)
+void pad_with_blanks(char *str, int size)
 {
-  while (*str) {
-    size--;
-    str++;
-  }
-  while (size-- &gt; 1) {
-    *str++ = ' ';
-  }
-  *str = '\0';
+    while (*str) {
+        size--;
+        str++;
+    }
+    while (size-- &gt; 1) {
+        *str++ = ' ';
+    }
+    *str = '\0';
 }
 
-void 
-format_pos_number4 (char* str, int num)
+void format_pos_number4(char *str, int num)
 {
-  num_to_ansi(str, 4, num);
+    num_to_ansi(str, 4, num);
 }
 
-void 
-format_power(char * str, size_t size, long power)
+void format_power(char *str, size_t size, long power)
 {
-  /* Lincity power unit is 1kW */
-  num_to_ansi_unit(str, size, power*1000, 'W');
+    /* Lincity power unit is 1kW */
+    num_to_ansi_unit(str, size, power * 1000, 'W');
 }
 
-int
-min_int (int i1, int i2)
+int min_int(int i1, int i2)
 {
-  return i1 &lt; i2 ? i1 : i2;
+    return i1 &lt; i2 ? i1 : i2;
 }
 
-int
-max_int (int i1, int i2)
+int max_int(int i1, int i2)
 {
-  return i1 &gt; i2 ? i1 : i2;
+    return i1 &gt; i2 ? i1 : i2;
 }
 
-void * 
-lcalloc (size_t size) 
+void *lcalloc(size_t size)
 {
-  void * tmp;
-  tmp = malloc(size);
-  if (tmp == NULL) {
-    printf(&quot;couldn't malloc %d bytes!  Dying.\n&quot;,size);
-    exit(-1);
-  }
-  
-  return tmp;
+    void *tmp;
+    tmp = malloc(size);
+    if (tmp == NULL) {
+        printf(&quot;couldn't malloc %d bytes!  Dying.\n&quot;, size);
+        exit(-1);
+    }
+
+    return tmp;
 }

Modified: trunk/src/lincity/lclib.h
===================================================================
--- trunk/src/lincity/lclib.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/lclib.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -11,19 +11,17 @@
 // FIXME: is this necessary to export this?
 extern char *months[];
 
+const char *current_month(int current_time);
+int current_year(int current_time);
+void format_number5(char *str, int num);
+void format_pos_number4(char *str, int num);
+void format_power(char *str, size_t size, long power);
+void *lcalloc(size_t size);
+int commify(char *str, size_t size, int argnum);
+void pad_with_blanks(char *str, int size);
+void num_to_ansi(char *s, size_t size, long num);
 
-const char * current_month(int current_time);
-int current_year (int current_time);
-void format_number5 (char* str, int num);
-void format_pos_number4 (char* str, int num);
-void format_power(char * str, size_t size, long power);
-void * lcalloc (size_t size);
-int commify(char * str, size_t size, int argnum);
-void pad_with_blanks (char* str, int size);
-void num_to_ansi(char * s, size_t size, long num);
+int min_int(int i1, int i2);
+int max_int(int i1, int i2);
 
-int min_int (int i1, int i2);
-int max_int (int i1, int i2);
-
 #endif
-

Modified: trunk/src/lincity/lcstring.h
===================================================================
--- trunk/src/lincity/lcstring.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/lcstring.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -17,4 +17,4 @@
 #pragma message(__FILE__ &quot;: deprecated header&quot;)
 #endif
 
-#endif	/* __lcstring_h__ */
+#endif /* __lcstring_h__ */

Modified: trunk/src/lincity/lctypes.h
===================================================================
--- trunk/src/lincity/lctypes.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/lctypes.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -103,7 +103,6 @@
 #define CST_POWERS_COAL_FULL_G  &quot;powerscoal-full.csi&quot;
 #define LCT_POWERS_COAL_FULL_G  &quot;powerscoal-full&quot;
 
-
 #define CST_BURNT		49
 #define CST_BURNT_G		&quot;burnt_land.csi&quot;
 #define LCT_BURNT_G		&quot;burnt_land&quot;
@@ -141,7 +140,6 @@
 #define CST_RESIDENCE_HH_G      &quot;reshihi.csi&quot;
 #define LCT_RESIDENCE_HH_G      &quot;reshihi&quot;
 
-
 #define CST_MARKET_EMPTY	71
 #define CST_MARKET_EMPTY_G	&quot;market-empty.csi&quot;
 #define LCT_MARKET_EMPTY_G	&quot;market-empty&quot;
@@ -155,7 +153,6 @@
 #define CST_MARKET_FULL_G       &quot;market-full.csi&quot;
 #define LCT_MARKET_FULL_G       &quot;market-full&quot;
 
-
 #define CST_RECYCLE		79
 #define CST_RECYCLE_G		&quot;recycle-centre.csi&quot;
 #define LCT_RECYCLE_G		&quot;recycle-centre&quot;
@@ -220,7 +217,6 @@
 #define CST_MONUMENT_5_G        &quot;monument5.csi&quot;
 #define LCT_MONUMENT_5_G        &quot;monument5&quot;
 
-
 #define CST_COALMINE_EMPTY	100
 #define CST_COALMINE_EMPTY_G	&quot;coalmine-empty.csi&quot;
 #define LCT_COALMINE_EMPTY_G	&quot;coalmine-empty&quot;
@@ -296,7 +292,6 @@
 #define CST_FIRE_DONE4_G       &quot;firedone4.csi&quot;
 #define LCT_FIRE_DONE4_G       &quot;firedone4&quot;
 
-
 #define CST_ROAD_LR            130
 #define CST_ROAD_LR_G          &quot;roadlr.csi&quot;
 #define LCT_ROAD_LR_G          &quot;roadlr&quot;
@@ -331,7 +326,6 @@
 #define CST_ROAD_LUDR_G        &quot;roadludr.csi&quot;
 #define LCT_ROAD_LUDR_G        &quot;roadludr&quot;
 
-
 #define CST_OREMINE_5           146
 #define CST_OREMINE_5_G         &quot;oremine5.csi&quot;
 #define LCT_OREMINE_5_G         &quot;oremine5&quot;
@@ -358,7 +352,6 @@
 #define CST_OREMINE_4_G		&quot;oremine4.csi&quot;
 #define LCT_OREMINE_4_G		&quot;oremine4&quot;
 
-
 #define CST_HEALTH		155
 #define CST_HEALTH_G		&quot;health.csi&quot;
 #define LCT_HEALTH_G		&quot;health&quot;
@@ -393,7 +386,6 @@
 #define CST_MILL_6_G            &quot;mill6.csi&quot;
 #define LCT_MILL_6_G            &quot;mill6&quot;
 
-
 #define CST_ROCKET_1		180
 #define CST_ROCKET_1_G          &quot;rocket1.csi&quot;
 #define LCT_ROCKET_1_G          &quot;rocket1&quot;
@@ -459,7 +451,6 @@
 #define CST_WINDMILL_3_W_G      &quot;windmill3w.csi&quot;
 #define LCT_WINDMILL_3_W_G      &quot;windmill3w&quot;
 
-
 #define CST_BLACKSMITH_0          202
 #define CST_BLACKSMITH_0_G        &quot;blacksmith0.csi&quot;
 #define LCT_BLACKSMITH_0_G        &quot;blacksmith0&quot;
@@ -650,7 +641,6 @@
 #define CST_TIP_8_G             &quot;tip8.csi&quot;
 #define LCT_TIP_8_G             &quot;tip8&quot;
 
-
 #define CST_COMMUNE_1           270
 #define CST_COMMUNE_1_G         &quot;commune1.csi&quot;
 #define LCT_COMMUNE_1_G         &quot;commune1&quot;
@@ -694,7 +684,6 @@
 #define CST_COMMUNE_14_G        &quot;commune14.csi&quot;
 #define LCT_COMMUNE_14_G        &quot;commune14&quot;
 
-
 #define CST_INDUSTRY_H_C        290
 #define CST_INDUSTRY_H_C_G      &quot;industryhc.csi&quot;
 #define LCT_INDUSTRY_H_C_G      &quot;industryhc&quot;

Modified: trunk/src/lincity/ldsvguts.cpp
===================================================================
--- trunk/src/lincity/ldsvguts.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/ldsvguts.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -95,8 +95,8 @@
 /* ---------------------------------------------------------------------- *
  * Private Fn Prototypes
  * ---------------------------------------------------------------------- */
-void dump_screen (void);
-int verify_city (char *cname);
+void dump_screen(void);
+int verify_city(char *cname);
 
 /* ---------------------------------------------------------------------- *
  * Private Global Variables
@@ -107,228 +107,216 @@
 /* ---------------------------------------------------------------------- *
  * Public functions
  * ---------------------------------------------------------------------- */
-void
-remove_scene (char *cname)
+void remove_scene(char *cname)
 {
     char *s;
     int l;
-    if ((l = strlen (cname)) &lt; 2)	/* Thanks to Chris J. Kiick */
-	return;
+    if ((l = strlen(cname)) &lt; 2)        /* Thanks to Chris J. Kiick */
+        return;
 
-    if ((s = (char *) malloc (lc_save_dir_len + l + 16)) == 0)
-	malloc_failure ();
-    sprintf (s, &quot;%s%c%s&quot;, lc_save_dir, PATH_SLASH, cname);
-    remove (s);
-    free (s);
+    if ((s = (char *)malloc(lc_save_dir_len + l + 16)) == 0)
+        malloc_failure();
+    sprintf(s, &quot;%s%c%s&quot;, lc_save_dir, PATH_SLASH, cname);
+    remove(s);
+    free(s);
 }
 
-void
-save_city_raw (char *cname)
+void save_city_raw(char *cname)
 {
     int x, y, z, q, n, p;
     gzFile ofile = gzopen(cname, &quot;wb&quot;);
     if (ofile == NULL) {
-	printf (_(&quot;Save file &lt;%s&gt; - &quot;), cname);
-	do_error (_(&quot;Can't open save file!&quot;));
+        printf(_(&quot;Save file &lt;%s&gt; - &quot;), cname);
+        do_error(_(&quot;Can't open save file!&quot;));
     }
     /* save without waterwell are in NG 1.1 format, eg scenario good_time is ver 98 when loaded */
     if (ldsv_version &lt; VERSION_INT)
-    	ldsv_version = VERSION_INT;
+        ldsv_version = VERSION_INT;
 
-    gzprintf (ofile, &quot;%d\n&quot;, ldsv_version);
-    q = sizeof (Map_Point_Info);
-    prog_box (_(&quot;Saving scene&quot;), 0);
-    check_endian ();
+    gzprintf(ofile, &quot;%d\n&quot;, ldsv_version);
+    q = sizeof(Map_Point_Info);
+    prog_box(_(&quot;Saving scene&quot;), 0);
+    check_endian();
     for (x = 0; x &lt; WORLD_SIDE_LEN; x++) {
-	for (y = 0; y &lt; WORLD_SIDE_LEN; y++) {
-	    for (z = 0; z &lt; sizeof(int); z++) {
-		n = *(((unsigned char *) &amp;MP_INFO(x,y).population) + z);
-		gzprintf (ofile, &quot;%d\n&quot;, n);
-	    }
-	    for (z = 0; z &lt; sizeof(int); z++) {
-		n = *(((unsigned char *) &amp;MP_INFO(x,y).flags) + z);
-		gzprintf (ofile, &quot;%d\n&quot;, n);
-	    }
-	    for (z = 0; z &lt; sizeof(unsigned short); z++) {
-		n = *(((unsigned char *) &amp;MP_INFO(x,y).coal_reserve) + z);
-		gzprintf (ofile, &quot;%d\n&quot;, n);
-	    }
-	    for (z = 0; z &lt; sizeof(unsigned short); z++) {
-		n = *(((unsigned char *) &amp;MP_INFO(x,y).ore_reserve) + z);
-		gzprintf (ofile, &quot;%d\n&quot;, n);
-	    }
-	    for (z = 0; z &lt; sizeof(int); z++) {
-		n = *(((unsigned char *) &amp;MP_INFO(x,y).int_1) + z);
-		gzprintf (ofile, &quot;%d\n&quot;, n);
-	    }
-	    for (z = 0; z &lt; sizeof(int); z++) {
-		n = *(((unsigned char *) &amp;MP_INFO(x,y).int_2) + z);
-		gzprintf (ofile, &quot;%d\n&quot;, n);
-	    }
-	    for (z = 0; z &lt; sizeof(int); z++) {
-		n = *(((unsigned char *) &amp;MP_INFO(x,y).int_3) + z);
-		gzprintf (ofile, &quot;%d\n&quot;, n);
-	    }
-	    for (z = 0; z &lt; sizeof(int); z++) {
-		n = *(((unsigned char *) &amp;MP_INFO(x,y).int_4) + z);
-		gzprintf (ofile, &quot;%d\n&quot;, n);
-	    }
-	    for (z = 0; z &lt; sizeof(int); z++) {
-		n = *(((unsigned char *) &amp;MP_INFO(x,y).int_5) + z);
-		gzprintf (ofile, &quot;%d\n&quot;, n);
-	    }
-	    for (z = 0; z &lt; sizeof(int); z++) {
-		n = *(((unsigned char *) &amp;MP_INFO(x,y).int_6) + z);
-		gzprintf (ofile, &quot;%d\n&quot;, n);
-	    }
-	    for (z = 0; z &lt; sizeof(int); z++) {
-		n = *(((unsigned char *) &amp;MP_INFO(x,y).int_7) + z);
-		gzprintf (ofile, &quot;%d\n&quot;, n);
-	    }
-	    gzprintf (ofile, &quot;%d\n&quot;, (int) MP_POL(x,y));
-	    gzprintf (ofile, &quot;%d\n&quot;, (int) MP_TYPE(x,y));
-	}
-	prog_box (&quot;&quot;, (90 * x) / WORLD_SIDE_LEN);
+        for (y = 0; y &lt; WORLD_SIDE_LEN; y++) {
+            for (z = 0; z &lt; sizeof(int); z++) {
+                n = *(((unsigned char *)&amp;MP_INFO(x, y).population) + z);
+                gzprintf(ofile, &quot;%d\n&quot;, n);
+            }
+            for (z = 0; z &lt; sizeof(int); z++) {
+                n = *(((unsigned char *)&amp;MP_INFO(x, y).flags) + z);
+                gzprintf(ofile, &quot;%d\n&quot;, n);
+            }
+            for (z = 0; z &lt; sizeof(unsigned short); z++) {
+                n = *(((unsigned char *)&amp;MP_INFO(x, y).coal_reserve) + z);
+                gzprintf(ofile, &quot;%d\n&quot;, n);
+            }
+            for (z = 0; z &lt; sizeof(unsigned short); z++) {
+                n = *(((unsigned char *)&amp;MP_INFO(x, y).ore_reserve) + z);
+                gzprintf(ofile, &quot;%d\n&quot;, n);
+            }
+            for (z = 0; z &lt; sizeof(int); z++) {
+                n = *(((unsigned char *)&amp;MP_INFO(x, y).int_1) + z);
+                gzprintf(ofile, &quot;%d\n&quot;, n);
+            }
+            for (z = 0; z &lt; sizeof(int); z++) {
+                n = *(((unsigned char *)&amp;MP_INFO(x, y).int_2) + z);
+                gzprintf(ofile, &quot;%d\n&quot;, n);
+            }
+            for (z = 0; z &lt; sizeof(int); z++) {
+                n = *(((unsigned char *)&amp;MP_INFO(x, y).int_3) + z);
+                gzprintf(ofile, &quot;%d\n&quot;, n);
+            }
+            for (z = 0; z &lt; sizeof(int); z++) {
+                n = *(((unsigned char *)&amp;MP_INFO(x, y).int_4) + z);
+                gzprintf(ofile, &quot;%d\n&quot;, n);
+            }
+            for (z = 0; z &lt; sizeof(int); z++) {
+                n = *(((unsigned char *)&amp;MP_INFO(x, y).int_5) + z);
+                gzprintf(ofile, &quot;%d\n&quot;, n);
+            }
+            for (z = 0; z &lt; sizeof(int); z++) {
+                n = *(((unsigned char *)&amp;MP_INFO(x, y).int_6) + z);
+                gzprintf(ofile, &quot;%d\n&quot;, n);
+            }
+            for (z = 0; z &lt; sizeof(int); z++) {
+                n = *(((unsigned char *)&amp;MP_INFO(x, y).int_7) + z);
+                gzprintf(ofile, &quot;%d\n&quot;, n);
+            }
+            gzprintf(ofile, &quot;%d\n&quot;, (int)MP_POL(x, y));
+            gzprintf(ofile, &quot;%d\n&quot;, (int)MP_TYPE(x, y));
+        }
+        prog_box(&quot;&quot;, (90 * x) / WORLD_SIDE_LEN);
     }
-    check_endian ();		/* we have to put the byte order back. */
+    check_endian();             /* we have to put the byte order back. */
 
-    gzprintf (ofile, &quot;%d\n&quot;, main_screen_originx);
-    gzprintf (ofile, &quot;%d\n&quot;, main_screen_originy);
-    gzprintf (ofile, &quot;%d\n&quot;, total_time);
-    for (x = 0; x &lt; MAX_NUMOF_SUBSTATIONS; x++)
-    {
-	gzprintf (ofile, &quot;%d\n&quot;, substationx[x]);
-	gzprintf (ofile, &quot;%d\n&quot;, substationy[x]);
+    gzprintf(ofile, &quot;%d\n&quot;, main_screen_originx);
+    gzprintf(ofile, &quot;%d\n&quot;, main_screen_originy);
+    gzprintf(ofile, &quot;%d\n&quot;, total_time);
+    for (x = 0; x &lt; MAX_NUMOF_SUBSTATIONS; x++) {
+        gzprintf(ofile, &quot;%d\n&quot;, substationx[x]);
+        gzprintf(ofile, &quot;%d\n&quot;, substationy[x]);
     }
-    prog_box (&quot;&quot;, 92);
-    gzprintf (ofile, &quot;%d\n&quot;, numof_substations);
-    for (x = 0; x &lt; MAX_NUMOF_MARKETS; x++)
-    {
-	gzprintf (ofile, &quot;%d\n&quot;, marketx[x]);
-	gzprintf (ofile, &quot;%d\n&quot;, markety[x]);
+    prog_box(&quot;&quot;, 92);
+    gzprintf(ofile, &quot;%d\n&quot;, numof_substations);
+    for (x = 0; x &lt; MAX_NUMOF_MARKETS; x++) {
+        gzprintf(ofile, &quot;%d\n&quot;, marketx[x]);
+        gzprintf(ofile, &quot;%d\n&quot;, markety[x]);
     }
-    prog_box (&quot;&quot;, 94);
-    gzprintf (ofile, &quot;%d\n&quot;, numof_markets);
-    gzprintf (ofile, &quot;%d\n&quot;, people_pool);
-    gzprintf (ofile, &quot;%d\n&quot;, total_money);
-    gzprintf (ofile, &quot;%d\n&quot;, income_tax_rate);
-    gzprintf (ofile, &quot;%d\n&quot;, coal_tax_rate);
-    gzprintf (ofile, &quot;%d\n&quot;, dole_rate);
-    gzprintf (ofile, &quot;%d\n&quot;, transport_cost_rate);
-    gzprintf (ofile, &quot;%d\n&quot;, goods_tax_rate);
-    gzprintf (ofile, &quot;%d\n&quot;, export_tax);
-    gzprintf (ofile, &quot;%d\n&quot;, export_tax_rate);
-    gzprintf (ofile, &quot;%d\n&quot;, import_cost);
-    gzprintf (ofile, &quot;%d\n&quot;, import_cost_rate);
-    gzprintf (ofile, &quot;%d\n&quot;, tech_level);
-    gzprintf (ofile, &quot;%d\n&quot;, tpopulation);
-    gzprintf (ofile, &quot;%d\n&quot;, tstarving_population);
-    gzprintf (ofile, &quot;%d\n&quot;, tunemployed_population);
-    gzprintf (ofile, &quot;%d\n&quot;, 0); /* waste_goods is obsolete */
-    gzprintf (ofile, &quot;%d\n&quot;, power_made);
-    gzprintf (ofile, &quot;%d\n&quot;, power_used);
-    gzprintf (ofile, &quot;%d\n&quot;, coal_made);
-    gzprintf (ofile, &quot;%d\n&quot;, coal_used);
-    gzprintf (ofile, &quot;%d\n&quot;, goods_made);
-    gzprintf (ofile, &quot;%d\n&quot;, goods_used);
-    gzprintf (ofile, &quot;%d\n&quot;, ore_made);
-    gzprintf (ofile, &quot;%d\n&quot;, ore_used);
-    gzprintf (ofile, &quot;%d\n&quot;, 0); /* Removed diff_old_population, version 1.12 */
+    prog_box(&quot;&quot;, 94);
+    gzprintf(ofile, &quot;%d\n&quot;, numof_markets);
+    gzprintf(ofile, &quot;%d\n&quot;, people_pool);
+    gzprintf(ofile, &quot;%d\n&quot;, total_money);
+    gzprintf(ofile, &quot;%d\n&quot;, income_tax_rate);
+    gzprintf(ofile, &quot;%d\n&quot;, coal_tax_rate);
+    gzprintf(ofile, &quot;%d\n&quot;, dole_rate);
+    gzprintf(ofile, &quot;%d\n&quot;, transport_cost_rate);
+    gzprintf(ofile, &quot;%d\n&quot;, goods_tax_rate);
+    gzprintf(ofile, &quot;%d\n&quot;, export_tax);
+    gzprintf(ofile, &quot;%d\n&quot;, export_tax_rate);
+    gzprintf(ofile, &quot;%d\n&quot;, import_cost);
+    gzprintf(ofile, &quot;%d\n&quot;, import_cost_rate);
+    gzprintf(ofile, &quot;%d\n&quot;, tech_level);
+    gzprintf(ofile, &quot;%d\n&quot;, tpopulation);
+    gzprintf(ofile, &quot;%d\n&quot;, tstarving_population);
+    gzprintf(ofile, &quot;%d\n&quot;, tunemployed_population);
+    gzprintf(ofile, &quot;%d\n&quot;, 0); /* waste_goods is obsolete */
+    gzprintf(ofile, &quot;%d\n&quot;, power_made);
+    gzprintf(ofile, &quot;%d\n&quot;, power_used);
+    gzprintf(ofile, &quot;%d\n&quot;, coal_made);
+    gzprintf(ofile, &quot;%d\n&quot;, coal_used);
+    gzprintf(ofile, &quot;%d\n&quot;, goods_made);
+    gzprintf(ofile, &quot;%d\n&quot;, goods_used);
+    gzprintf(ofile, &quot;%d\n&quot;, ore_made);
+    gzprintf(ofile, &quot;%d\n&quot;, ore_used);
+    gzprintf(ofile, &quot;%d\n&quot;, 0); /* Removed diff_old_population, version 1.12 */
 
-    prog_box (&quot;&quot;, 96);
+    prog_box(&quot;&quot;, 96);
     /* Changed, version 1.12 */
-    gzprintf (ofile, &quot;%d\n&quot;, monthgraph_size);
+    gzprintf(ofile, &quot;%d\n&quot;, monthgraph_size);
     for (x = 0; x &lt; monthgraph_size; x++) {
-	gzprintf (ofile, &quot;%d\n&quot;, monthgraph_pop[x]);
-	gzprintf (ofile, &quot;%d\n&quot;, monthgraph_starve[x]);
-	gzprintf (ofile, &quot;%d\n&quot;, monthgraph_nojobs[x]);
-	gzprintf (ofile, &quot;%d\n&quot;, monthgraph_ppool[x]);
+        gzprintf(ofile, &quot;%d\n&quot;, monthgraph_pop[x]);
+        gzprintf(ofile, &quot;%d\n&quot;, monthgraph_starve[x]);
+        gzprintf(ofile, &quot;%d\n&quot;, monthgraph_nojobs[x]);
+        gzprintf(ofile, &quot;%d\n&quot;, monthgraph_ppool[x]);
     }
-    prog_box (&quot;&quot;, 98);
-    gzprintf (ofile, &quot;%d\n&quot;, rockets_launched);
-    gzprintf (ofile, &quot;%d\n&quot;, rockets_launched_success);
-    gzprintf (ofile, &quot;%d\n&quot;, coal_survey_done);
+    prog_box(&quot;&quot;, 98);
+    gzprintf(ofile, &quot;%d\n&quot;, rockets_launched);
+    gzprintf(ofile, &quot;%d\n&quot;, rockets_launched_success);
+    gzprintf(ofile, &quot;%d\n&quot;, coal_survey_done);
     for (x = 0; x &lt; PBAR_DATA_SIZE; x++)
-	for (p = 0; p &lt; NUM_PBARS; p++)
-	    gzprintf(ofile, &quot;%d\n&quot;, pbars[p].data[x]);
+        for (p = 0; p &lt; NUM_PBARS; p++)
+            gzprintf(ofile, &quot;%d\n&quot;, pbars[p].data[x]);
 
-    prog_box (&quot;&quot;, 99);
+    prog_box(&quot;&quot;, 99);
 
     for (p = 0; p &lt; NUM_PBARS; p++) {
-	gzprintf(ofile, &quot;%d\n&quot;, pbars[p].oldtot);
-	gzprintf(ofile, &quot;%d\n&quot;, pbars[p].diff);
+        gzprintf(ofile, &quot;%d\n&quot;, pbars[p].oldtot);
+        gzprintf(ofile, &quot;%d\n&quot;, pbars[p].diff);
     }
 
-    gzprintf (ofile, &quot;%d\n&quot;, cheat_flag);
-    gzprintf (ofile, &quot;%d\n&quot;, total_pollution_deaths);
-    gzprintf (ofile, &quot;%f\n&quot;, pollution_deaths_history);
-    gzprintf (ofile, &quot;%d\n&quot;, total_starve_deaths);
-    gzprintf (ofile, &quot;%f\n&quot;, starve_deaths_history);
-    gzprintf (ofile, &quot;%d\n&quot;, total_unemployed_years);
-    gzprintf (ofile, &quot;%f\n&quot;, unemployed_history);
-    gzprintf (ofile, &quot;%d\n&quot;, max_pop_ever);
-    gzprintf (ofile, &quot;%d\n&quot;, total_evacuated);
-    gzprintf (ofile, &quot;%d\n&quot;, total_births);
+    gzprintf(ofile, &quot;%d\n&quot;, cheat_flag);
+    gzprintf(ofile, &quot;%d\n&quot;, total_pollution_deaths);
+    gzprintf(ofile, &quot;%f\n&quot;, pollution_deaths_history);
+    gzprintf(ofile, &quot;%d\n&quot;, total_starve_deaths);
+    gzprintf(ofile, &quot;%f\n&quot;, starve_deaths_history);
+    gzprintf(ofile, &quot;%d\n&quot;, total_unemployed_years);
+    gzprintf(ofile, &quot;%f\n&quot;, unemployed_history);
+    gzprintf(ofile, &quot;%d\n&quot;, max_pop_ever);
+    gzprintf(ofile, &quot;%d\n&quot;, total_evacuated);
+    gzprintf(ofile, &quot;%d\n&quot;, total_births);
     for (x = 0; x &lt; NUMOF_MODULES; x++)
-	gzprintf (ofile, &quot;%d\n&quot;, module_help_flag[x]);
-    gzprintf (ofile, &quot;%d\n&quot;, 0);	/* dummy values */
+        gzprintf(ofile, &quot;%d\n&quot;, module_help_flag[x]);
+    gzprintf(ofile, &quot;%d\n&quot;, 0); /* dummy values */
 
-    gzprintf (ofile, &quot;%d\n&quot;, 0);	/* backward compatibility */
+    gzprintf(ofile, &quot;%d\n&quot;, 0); /* backward compatibility */
 
-    if (strlen (given_scene) &gt; 1)
-	gzprintf (ofile, &quot;%s\n&quot;, given_scene);
+    if (strlen(given_scene) &gt; 1)
+        gzprintf(ofile, &quot;%s\n&quot;, given_scene);
     else
-	gzprintf (ofile, &quot;dummy\n&quot;);	/* 1 */
+        gzprintf(ofile, &quot;dummy\n&quot;);     /* 1 */
 
-    gzprintf (ofile, &quot;%d\n&quot;, highest_tech_level);	/* 2 */
+    gzprintf(ofile, &quot;%d\n&quot;, highest_tech_level);        /* 2 */
 
-    gzprintf (ofile, &quot;sust %d %d %d %d %d %d %d %d %d %d\n&quot;
-	     ,sust_dig_ore_coal_count, sust_port_count
-	     ,sust_old_money_count, sust_old_population_count
-	     ,sust_old_tech_count, sust_fire_count
-	     ,sust_old_money, sust_old_population, sust_old_tech
-	     ,sustain_flag);	/* 3 */
+    gzprintf(ofile, &quot;sust %d %d %d %d %d %d %d %d %d %d\n&quot;, sust_dig_ore_coal_count, sust_port_count, sust_old_money_count, sust_old_population_count, sust_old_tech_count, sust_fire_count, sust_old_money, sust_old_population, sust_old_tech, sustain_flag); /* 3 */
 
     if (use_waterwell == true) {
     } else {
-	    gzprintf (ofile, &quot;dummy\n&quot;);	/* 4 */
+        gzprintf(ofile, &quot;dummy\n&quot;);     /* 4 */
     }
-    gzprintf (ofile, &quot;dummy\n&quot;);	/* 5 */
+    gzprintf(ofile, &quot;dummy\n&quot;); /* 5 */
 
-    gzprintf (ofile, &quot;dummy\n&quot;);	/* 6 */
+    gzprintf(ofile, &quot;dummy\n&quot;); /* 6 */
 
-    gzprintf (ofile, &quot;dummy\n&quot;);	/* 7 */
+    gzprintf(ofile, &quot;dummy\n&quot;); /* 7 */
 
-    gzprintf (ofile, &quot;dummy\n&quot;);	/* 8 */
+    gzprintf(ofile, &quot;dummy\n&quot;); /* 8 */
 
-    gzprintf (ofile, &quot;dummy\n&quot;);	/* 9 */
+    gzprintf(ofile, &quot;dummy\n&quot;); /* 9 */
 
-    gzprintf (ofile, &quot;dummy\n&quot;);	/* 10 */
+    gzprintf(ofile, &quot;dummy\n&quot;); /* 10 */
 
-    gzclose (ofile);
-    prog_box (&quot;&quot;, 100);
+    gzclose(ofile);
+    prog_box(&quot;&quot;, 100);
 }
 
-
-void
-save_city (char *cname)
+void save_city(char *cname)
 {
     char *s;
     int l;
 
-    if ((l = strlen (cname)) &lt; 2)
-	return;
-    if ((s = (char *) malloc (lc_save_dir_len + l + 16)) == 0)
-	malloc_failure ();
+    if ((l = strlen(cname)) &lt; 2)
+        return;
+    if ((s = (char *)malloc(lc_save_dir_len + l + 16)) == 0)
+        malloc_failure();
 
-    sprintf (s, &quot;%s%c%s&quot;, lc_save_dir, PATH_SLASH, cname);
+    sprintf(s, &quot;%s%c%s&quot;, lc_save_dir, PATH_SLASH, cname);
 
-    save_city_raw (s);
-    free (s);
+    save_city_raw(s);
+    free(s);
 }
 
-void
-load_city (char *cname)
+void load_city(char *cname)
 {
     unsigned long q;
     int i, x, y, z, n, p;
@@ -337,28 +325,28 @@
     int dummy;
     gzFile gzfile;
     char s[256];
-    gzfile = gzopen( cname, &quot;rb&quot; ); 
-    if ( gzfile == NULL) {
-	    printf (_(&quot;Can't open &lt;%s&gt; (gzipped)&quot;), cname);
-	    do_error (&quot;Can't open it!&quot;);
+    gzfile = gzopen(cname, &quot;rb&quot;);
+    if (gzfile == NULL) {
+        printf(_(&quot;Can't open &lt;%s&gt; (gzipped)&quot;), cname);
+        do_error(&quot;Can't open it!&quot;);
     }
     /* Add version to shared global variables for playing/saving games without waterwell */
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;ldsv_version);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;ldsv_version);
     if (ldsv_version &lt; MIN_LOAD_VERSION) {
-	    ok_dial_box (&quot;too-old.mes&quot;, BAD, 0L);
-	    gzclose( gzfile );
-	return;
+        ok_dial_box(&quot;too-old.mes&quot;, BAD, 0L);
+        gzclose(gzfile);
+        return;
     }
 
-    fprintf(stderr,&quot; ldsv_version = %i \n&quot;, ldsv_version);
+    fprintf(stderr, &quot; ldsv_version = %i \n&quot;, ldsv_version);
     if (ldsv_version &lt; MIN_WATERWELL_VERSION) {
-	/* ok_dial_box (&quot;no-waterwell.mes&quot;, GOOD, 0L);*/
-	use_waterwell=false;
+        /* ok_dial_box (&quot;no-waterwell.mes&quot;, GOOD, 0L); */
+        use_waterwell = false;
     } else {
-    	use_waterwell=true; 
-	/* needed until it is written in the saved file
-	 * in case of load after having played an old game
-	 */
+        use_waterwell = true;
+        /* needed until it is written in the saved file
+         * in case of load after having played an old game
+         */
     }
 
     init_pbars();
@@ -366,258 +354,248 @@
     pbar_data_size = PBAR_DATA_SIZE;
 
     init_inventory();
-    
+
     print_time_for_year();
-    q = (unsigned long) sizeof (Map_Point_Info);
-    prog_box (_(&quot;Loading scene&quot;), 0);
+    q = (unsigned long)sizeof(Map_Point_Info);
+    prog_box(_(&quot;Loading scene&quot;), 0);
 
     for (x = 0; x &lt; WORLD_SIDE_LEN; x++) {
-	for (y = 0; y &lt; WORLD_SIDE_LEN; y++) {
-	    for (z = 0; z &lt; sizeof(int); z++) {
-		sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;n);
-		*(((unsigned char *) &amp;MP_INFO(x,y).population) + z) = n;
-	    }
-	    for (z = 0; z &lt; sizeof(int); z++) {
-		sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;n);
-		*(((unsigned char *) &amp;MP_INFO(x,y).flags) + z) = n;
-	    }
-	    for (z = 0; z &lt; sizeof(unsigned short); z++) {
-		sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;n);
-		*(((unsigned char *) &amp;MP_INFO(x,y).coal_reserve) + z) = n;
-	    }
-	    for (z = 0; z &lt; sizeof(unsigned short); z++) {
-		sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;n);
-		*(((unsigned char *) &amp;MP_INFO(x,y).ore_reserve) + z) = n;
-	    }
-	    for (z = 0; z &lt; sizeof(int); z++) {
-		sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;n);
-		*(((unsigned char *) &amp;MP_INFO(x,y).int_1) + z) = n;
-	    }
-	    for (z = 0; z &lt; sizeof(int); z++) {
-		sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;n);
-		*(((unsigned char *) &amp;MP_INFO(x,y).int_2) + z) = n;
-	    }
-	    for (z = 0; z &lt; sizeof(int); z++) {
-		sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;n);
-		*(((unsigned char *) &amp;MP_INFO(x,y).int_3) + z) = n;
-	    }
-	    for (z = 0; z &lt; sizeof(int); z++) {
-		sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;n);
-		*(((unsigned char *) &amp;MP_INFO(x,y).int_4) + z) = n;
-	    }
-	    for (z = 0; z &lt; sizeof(int); z++) {
-		sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;n);
-		*(((unsigned char *) &amp;MP_INFO(x,y).int_5) + z) = n;
-	    }
-	    for (z = 0; z &lt; sizeof(int); z++) {
-		sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;n);
-		*(((unsigned char *) &amp;MP_INFO(x,y).int_6) + z) = n;
-	    }
-	    for (z = 0; z &lt; sizeof(int); z++) {
-		sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;n);
-		*(((unsigned char *) &amp;MP_INFO(x,y).int_7) + z) = n;
-	    }
-	    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;n);
-	    MP_POL(x,y) = (unsigned short) n;
-	    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;n);
-	    MP_TYPE(x,y) = (short) n;
+        for (y = 0; y &lt; WORLD_SIDE_LEN; y++) {
+            for (z = 0; z &lt; sizeof(int); z++) {
+                sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;n);
+                *(((unsigned char *)&amp;MP_INFO(x, y).population) + z) = n;
+            }
+            for (z = 0; z &lt; sizeof(int); z++) {
+                sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;n);
+                *(((unsigned char *)&amp;MP_INFO(x, y).flags) + z) = n;
+            }
+            for (z = 0; z &lt; sizeof(unsigned short); z++) {
+                sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;n);
+                *(((unsigned char *)&amp;MP_INFO(x, y).coal_reserve) + z) = n;
+            }
+            for (z = 0; z &lt; sizeof(unsigned short); z++) {
+                sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;n);
+                *(((unsigned char *)&amp;MP_INFO(x, y).ore_reserve) + z) = n;
+            }
+            for (z = 0; z &lt; sizeof(int); z++) {
+                sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;n);
+                *(((unsigned char *)&amp;MP_INFO(x, y).int_1) + z) = n;
+            }
+            for (z = 0; z &lt; sizeof(int); z++) {
+                sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;n);
+                *(((unsigned char *)&amp;MP_INFO(x, y).int_2) + z) = n;
+            }
+            for (z = 0; z &lt; sizeof(int); z++) {
+                sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;n);
+                *(((unsigned char *)&amp;MP_INFO(x, y).int_3) + z) = n;
+            }
+            for (z = 0; z &lt; sizeof(int); z++) {
+                sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;n);
+                *(((unsigned char *)&amp;MP_INFO(x, y).int_4) + z) = n;
+            }
+            for (z = 0; z &lt; sizeof(int); z++) {
+                sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;n);
+                *(((unsigned char *)&amp;MP_INFO(x, y).int_5) + z) = n;
+            }
+            for (z = 0; z &lt; sizeof(int); z++) {
+                sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;n);
+                *(((unsigned char *)&amp;MP_INFO(x, y).int_6) + z) = n;
+            }
+            for (z = 0; z &lt; sizeof(int); z++) {
+                sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;n);
+                *(((unsigned char *)&amp;MP_INFO(x, y).int_7) + z) = n;
+            }
+            sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;n);
+            MP_POL(x, y) = (unsigned short)n;
+            sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;n);
+            MP_TYPE(x, y) = (short)n;
 
-	    if (get_group_of_type(MP_TYPE(x,y)) == GROUP_MARKET)
-		inventory(x,y);
-	}
-	if (((93 * x) / WORLD_SIDE_LEN) % 3 == 0)
-	    prog_box (&quot;&quot;, (93 * x) / WORLD_SIDE_LEN);
+            if (get_group_of_type(MP_TYPE(x, y)) == GROUP_MARKET)
+                inventory(x, y);
+        }
+        if (((93 * x) / WORLD_SIDE_LEN) % 3 == 0)
+            prog_box(&quot;&quot;, (93 * x) / WORLD_SIDE_LEN);
     }
-    check_endian ();
-    set_map_groups ();
+    check_endian();
+    set_map_groups();
 
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;main_screen_originx);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;main_screen_originy);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;main_screen_originx);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;main_screen_originy);
     if (main_screen_originx &gt; WORLD_SIDE_LEN - getMainWindowWidth() / 16 - 1)
-	main_screen_originx = WORLD_SIDE_LEN - getMainWindowWidth() / 16 - 1;
+        main_screen_originx = WORLD_SIDE_LEN - getMainWindowWidth() / 16 - 1;
 
     if (main_screen_originy &gt; WORLD_SIDE_LEN - getMainWindowHeight() / 16 - 1)
-	main_screen_originy = WORLD_SIDE_LEN - getMainWindowHeight() / 16 - 1;
+        main_screen_originy = WORLD_SIDE_LEN - getMainWindowHeight() / 16 - 1;
 
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;total_time);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;total_time);
     if (ldsv_version &lt;= MM_MS_C_VER)
-	i = OLD_MAX_NUMOF_SUBSTATIONS;
+        i = OLD_MAX_NUMOF_SUBSTATIONS;
     else
-	i = MAX_NUMOF_SUBSTATIONS;
-    for (x = 0; x &lt; i; x++)
-    {
-	sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;substationx[x]);
-	sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;substationy[x]);
+        i = MAX_NUMOF_SUBSTATIONS;
+    for (x = 0; x &lt; i; x++) {
+        sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;substationx[x]);
+        sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;substationy[x]);
     }
-    prog_box (&quot;&quot;, 92);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;numof_substations);
+    prog_box(&quot;&quot;, 92);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;numof_substations);
     if (ldsv_version &lt;= MM_MS_C_VER)
-	i = OLD_MAX_NUMOF_MARKETS;
+        i = OLD_MAX_NUMOF_MARKETS;
     else
-	i = MAX_NUMOF_MARKETS;
-    for (x = 0; x &lt; i; x++)
-    {
-	sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;marketx[x]);
-	sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;markety[x]);
+        i = MAX_NUMOF_MARKETS;
+    for (x = 0; x &lt; i; x++) {
+        sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;marketx[x]);
+        sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;markety[x]);
     }
-    prog_box (&quot;&quot;, 94);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;numof_markets);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;people_pool);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;total_money);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;income_tax_rate);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;coal_tax_rate);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;dole_rate);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;transport_cost_rate);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;goods_tax_rate);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;export_tax);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;export_tax_rate);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;import_cost);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;import_cost_rate);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;tech_level);
+    prog_box(&quot;&quot;, 94);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;numof_markets);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;people_pool);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;total_money);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;income_tax_rate);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;coal_tax_rate);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;dole_rate);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;transport_cost_rate);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;goods_tax_rate);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;export_tax);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;export_tax_rate);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;import_cost);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;import_cost_rate);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;tech_level);
     if (tech_level &gt; MODERN_WINDMILL_TECH)
-	modern_windmill_flag = 1;
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;tpopulation);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;tstarving_population);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;tunemployed_population);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;x);  /* waste_goods obsolete */
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;power_made);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;power_used);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;coal_made);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;coal_used);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;goods_made);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;goods_used);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;ore_made);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;ore_used);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;dummy); /* &amp;diff_old_population */
+        modern_windmill_flag = 1;
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;tpopulation);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;tstarving_population);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;tunemployed_population);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;x);   /* waste_goods obsolete */
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;power_made);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;power_used);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;coal_made);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;coal_used);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;goods_made);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;goods_used);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;ore_made);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;ore_used);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;dummy);       /* &amp;diff_old_population */
 
     /* Update variables calculated from those above */
     housed_population = tpopulation / NUMOF_DAYS_IN_MONTH;
 
-    prog_box (&quot;&quot;, 96);
+    prog_box(&quot;&quot;, 96);
     /* Get size of monthgraph array */
     if (ldsv_version &lt;= MG_C_VER) {
-	i = 120;
+        i = 120;
     } else {
-	sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;i);
+        sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;i);
     }
     for (x = 0; x &lt; i; x++) {
-	/* If more entries in file than will fit on screen, 
-	   then we need to skip past them. */
-	if (x &gt;= monthgraph_size) {
-	    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;dummy); /* &amp;monthgraph_pop[x] */
-	    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;dummy); /* &amp;monthgraph_starve[x] */
-	    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;dummy); /* &amp;monthgraph_nojobs[x] */
-	    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;dummy); /* &amp;monthgraph_ppool[x] */
-	} else {
-	    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;monthgraph_pop[x]);
-	    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;monthgraph_starve[x]);
-	    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;monthgraph_nojobs[x]);
-	    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;monthgraph_ppool[x]);
-	}
-	/* If our save file is old, skip past obsolete diffgraph entries */
-	if (ldsv_version &lt;= MG_C_VER) {
-	    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;dummy); /* &amp;diffgraph_power[x] */
-	    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;dummy); /* &amp;diffgraph_coal[x] */
-	    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;dummy); /* &amp;diffgraph_goods[x] */
-	    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;dummy); /* &amp;diffgraph_ore[x] */
-	    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;dummy); /* &amp;diffgraph_population[x] */
-	}
+        /* If more entries in file than will fit on screen, 
+           then we need to skip past them. */
+        if (x &gt;= monthgraph_size) {
+            sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;dummy);       /* &amp;monthgraph_pop[x] */
+            sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;dummy);       /* &amp;monthgraph_starve[x] */
+            sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;dummy);       /* &amp;monthgraph_nojobs[x] */
+            sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;dummy);       /* &amp;monthgraph_ppool[x] */
+        } else {
+            sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;monthgraph_pop[x]);
+            sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;monthgraph_starve[x]);
+            sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;monthgraph_nojobs[x]);
+            sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;monthgraph_ppool[x]);
+        }
+        /* If our save file is old, skip past obsolete diffgraph entries */
+        if (ldsv_version &lt;= MG_C_VER) {
+            sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;dummy);       /* &amp;diffgraph_power[x] */
+            sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;dummy);       /* &amp;diffgraph_coal[x] */
+            sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;dummy);       /* &amp;diffgraph_goods[x] */
+            sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;dummy);       /* &amp;diffgraph_ore[x] */
+            sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;dummy);       /* &amp;diffgraph_population[x] */
+        }
     }
     /* If screen bigger than number of entries in file, pad with zeroes */
     while (x &lt; monthgraph_size) {
-	monthgraph_pop[x] = 0;
-	monthgraph_starve[x] = 0;
-	monthgraph_nojobs[x] = 0;
-	monthgraph_ppool[x] = 0;
-	x++;
+        monthgraph_pop[x] = 0;
+        monthgraph_starve[x] = 0;
+        monthgraph_nojobs[x] = 0;
+        monthgraph_ppool[x] = 0;
+        x++;
     }
-    prog_box (&quot;&quot;, 98);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;rockets_launched);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;rockets_launched_success);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;coal_survey_done);
-    
+    prog_box(&quot;&quot;, 98);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;rockets_launched);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;rockets_launched_success);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;coal_survey_done);
+
     for (x = 0; x &lt; pbar_data_size; x++) {
-	for (p = 0; p &lt; num_pbars; p++) {
-	    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;(pbar_tmp));
-	    update_pbar(p,pbar_tmp,1);
+        for (p = 0; p &lt; num_pbars; p++) {
+            sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;(pbar_tmp));
+            update_pbar(p, pbar_tmp, 1);
 /*	    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;(pbars[p].data[x])); */
-	}
+        }
     }
 
     for (p = 0; p &lt; num_pbars; p++)
-	pbars[p].data_size = pbar_data_size;
+        pbars[p].data_size = pbar_data_size;
 
-    prog_box (&quot;&quot;, 99);
+    prog_box(&quot;&quot;, 99);
 
     for (p = 0; p &lt; num_pbars; p++) {
-	sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;(pbars[p].oldtot));
-	sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;(pbars[p].diff));
+        sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;(pbars[p].oldtot));
+        sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;(pbars[p].diff));
     }
 
-
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;cheat_flag);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;total_pollution_deaths);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%f&quot;, &amp;pollution_deaths_history);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;total_starve_deaths);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%f&quot;, &amp;starve_deaths_history);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;total_unemployed_years);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%f&quot;, &amp;unemployed_history);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;max_pop_ever);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;total_evacuated);
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;total_births);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;cheat_flag);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;total_pollution_deaths);
+    sscanf(gzgets(gzfile, s, 256), &quot;%f&quot;, &amp;pollution_deaths_history);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;total_starve_deaths);
+    sscanf(gzgets(gzfile, s, 256), &quot;%f&quot;, &amp;starve_deaths_history);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;total_unemployed_years);
+    sscanf(gzgets(gzfile, s, 256), &quot;%f&quot;, &amp;unemployed_history);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;max_pop_ever);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;total_evacuated);
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;total_births);
     for (x = 0; x &lt; NUMOF_MODULES; x++)
-	sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;(module_help_flag[x]));
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;x);	/* just dummy reads */
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%d&quot;, &amp;x);	/* for backwards compatibility. */
+        sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;(module_help_flag[x]));
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;x);   /* just dummy reads */
+    sscanf(gzgets(gzfile, s, 256), &quot;%d&quot;, &amp;x);   /* for backwards compatibility. */
 
     /* 10 dummy strings, for missed out things, have been put in save. */
     /* Input from this point uses them. */
     /* XXX: WCK: Huh? Missed out things? */
 
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%128s&quot;, given_scene);
-    if (strncmp (given_scene, &quot;dummy&quot;, 5) == 0 || strlen (given_scene) &lt; 3)
-	given_scene[0] = 0;
-    sscanf( gzgets( gzfile, s, 256 ), &quot;%128s&quot;, s);
-    if (strncmp (given_scene, &quot;dummy&quot;, 5) != 0)
-	sscanf (s, &quot;%d&quot;, &amp;highest_tech_level);
+    sscanf(gzgets(gzfile, s, 256), &quot;%128s&quot;, given_scene);
+    if (strncmp(given_scene, &quot;dummy&quot;, 5) == 0 || strlen(given_scene) &lt; 3)
+        given_scene[0] = 0;
+    sscanf(gzgets(gzfile, s, 256), &quot;%128s&quot;, s);
+    if (strncmp(given_scene, &quot;dummy&quot;, 5) != 0)
+        sscanf(s, &quot;%d&quot;, &amp;highest_tech_level);
     else
-	highest_tech_level = 0;
-    gzgets( gzfile, s, 80 );		/* this is the CR */
+        highest_tech_level = 0;
+    gzgets(gzfile, s, 80);      /* this is the CR */
 
-    if (sscanf (s, &quot;sust %d %d %d %d %d %d %d %d %d %d&quot;
-		,&amp;sust_dig_ore_coal_count, &amp;sust_port_count
-		,&amp;sust_old_money_count, &amp;sust_old_population_count
-		,&amp;sust_old_tech_count, &amp;sust_fire_count
-		,&amp;sust_old_money, &amp;sust_old_population, &amp;sust_old_tech
-		,&amp;sustain_flag) == 10)
-    {
-	sust_dig_ore_coal_tip_flag = sust_port_flag = 1;
-	/* GCS FIX: Check after loading file if screen is drawn OK */
-	/* draw_sustainable_window (); */
-    }
-    else
-	sustain_flag = sust_dig_ore_coal_count = sust_port_count
-		= sust_old_money_count = sust_old_population_count
-		= sust_old_tech_count = sust_fire_count
-		= sust_old_money = sust_old_population = sust_old_tech = 0;
+    if (sscanf
+        (s, &quot;sust %d %d %d %d %d %d %d %d %d %d&quot;, &amp;sust_dig_ore_coal_count, &amp;sust_port_count, &amp;sust_old_money_count,
+         &amp;sust_old_population_count, &amp;sust_old_tech_count, &amp;sust_fire_count, &amp;sust_old_money, &amp;sust_old_population,
+         &amp;sust_old_tech, &amp;sustain_flag) == 10) {
+        sust_dig_ore_coal_tip_flag = sust_port_flag = 1;
+        /* GCS FIX: Check after loading file if screen is drawn OK */
+        /* draw_sustainable_window (); */
+    } else
+        sustain_flag = sust_dig_ore_coal_count = sust_port_count
+            = sust_old_money_count = sust_old_population_count
+            = sust_old_tech_count = sust_fire_count = sust_old_money = sust_old_population = sust_old_tech = 0;
     if (use_waterwell == true) {
     }
-    gzclose( gzfile );
+    gzclose(gzfile);
 
-    numof_shanties = count_groups (GROUP_SHANTY);
-    numof_communes = count_groups (GROUP_COMMUNE);
-    prog_box (&quot;&quot;, 100);
+    numof_shanties = count_groups(GROUP_SHANTY);
+    numof_communes = count_groups(GROUP_COMMUNE);
+    prog_box(&quot;&quot;, 100);
 
     /* set up the university intake. */
-    x = count_groups (GROUP_UNIVERSITY);
+    x = count_groups(GROUP_UNIVERSITY);
     if (x &gt; 0) {
-	university_intake_rate
-		= (count_groups (GROUP_SCHOOL) * 20) / x;
-	if (university_intake_rate &gt; 100)
-	    university_intake_rate = 100;
-    }
-    else
-	university_intake_rate = 50;
+        university_intake_rate = (count_groups(GROUP_SCHOOL) * 20) / x;
+        if (university_intake_rate &gt; 100)
+            university_intake_rate = 100;
+    } else
+        university_intake_rate = 50;
 
     /*Al1 : What is this ? This does nothing, the value are saved in MP_INFO.int_ 
      * for (x = 0; x &lt; WORLD_SIDE_LEN; x++)
@@ -625,210 +603,194 @@
      *     update_tech_dep (x, y);
      */
 
-    unhighlight_module_button (selected_module);
-    selected_module = sbut[7];	/* 7 is track.  Watch out though! */
-    highlight_module_button (selected_module);
-    set_selected_module (CST_TRACK_LR);
+    unhighlight_module_button(selected_module);
+    selected_module = sbut[7];  /* 7 is track.  Watch out though! */
+    highlight_module_button(selected_module);
+    set_selected_module(CST_TRACK_LR);
 
-    print_total_money ();
-    reset_animation_times ();
+    print_total_money();
+    reset_animation_times();
     /* update tech dep for compatibility with old games */
     for (x = 0; x &lt; WORLD_SIDE_LEN; x++)
-	for (y = 0; y &lt; WORLD_SIDE_LEN; y++) {
-            switch (MP_GROUP(x,y)) {
-            case (GROUP_WINDMILL): 	 
-                MP_INFO(x,y).int_1 = (int)(WINDMILL_POWER 	 
-                        + (((double) MP_INFO(x,y).int_2 * WINDMILL_POWER)
-                                / MAX_TECH_LEVEL));
+        for (y = 0; y &lt; WORLD_SIDE_LEN; y++) {
+            switch (MP_GROUP(x, y)) {
+            case (GROUP_WINDMILL):
+                MP_INFO(x, y).int_1 = (int)(WINDMILL_POWER + (((double)MP_INFO(x, y).int_2 * WINDMILL_POWER)
+                                                              / MAX_TECH_LEVEL));
                 break;
-            case (GROUP_COAL_POWER): 	 
-                MP_INFO(x,y).int_1 = (int)(POWERS_COAL_OUTPUT 	 
-                        + (((double) MP_INFO(x,y).int_4 * POWERS_COAL_OUTPUT) 
-                                / MAX_TECH_LEVEL)); 	 
-                break; 	 
-            case (GROUP_SOLAR_POWER): 	 
-                MP_INFO(x,y).int_1 = (int)(POWERS_SOLAR_OUTPUT 	 
-                        + (((double) MP_INFO(x,y).int_2 * POWERS_SOLAR_OUTPUT) 	 
-                                / MAX_TECH_LEVEL)); 	 
-                break; 	 
+            case (GROUP_COAL_POWER):
+                MP_INFO(x, y).int_1 = (int)(POWERS_COAL_OUTPUT + (((double)MP_INFO(x, y).int_4 * POWERS_COAL_OUTPUT)
+                                                                  / MAX_TECH_LEVEL));
+                break;
+            case (GROUP_SOLAR_POWER):
+                MP_INFO(x, y).int_1 = (int)(POWERS_SOLAR_OUTPUT + (((double)MP_INFO(x, y).int_2 * POWERS_SOLAR_OUTPUT)
+                                                                   / MAX_TECH_LEVEL));
+                break;
             }
-    }
- 
-    map_power_grid(true); /* WCK:  Is this safe to do here?
-                           * AL1: No, in NG_1.1
-                           * In case of error message with ok_dial_box
-                           *    the dialog cannot appear because the screen
-                           *    is not set up =&gt; crash.
-                           * FIXME: move all initialisation elsewhere, in 
-                           *    engine.cpp or simulate.cpp.
-                           */
-                                
+        }
+
+    map_power_grid(true);       /* WCK:  Is this safe to do here?
+                                 * AL1: No, in NG_1.1
+                                 * In case of error message with ok_dial_box
+                                 *    the dialog cannot appear because the screen
+                                 *    is not set up =&gt; crash.
+                                 * FIXME: move all initialisation elsewhere, in 
+                                 *    engine.cpp or simulate.cpp.
+                                 */
+
 }
 
-void
-load_saved_city (char *s)
+void load_saved_city(char *s)
 {
-    char *cname = (char *) malloc (strlen (lc_save_dir) + strlen (s) + 2);
-    sprintf (cname, &quot;%s%c%s&quot;, lc_save_dir, PATH_SLASH, s);
-    load_city (cname);
-    free (cname);
+    char *cname = (char *)malloc(strlen(lc_save_dir) + strlen(s) + 2);
+    sprintf(cname, &quot;%s%c%s&quot;, lc_save_dir, PATH_SLASH, s);
+    load_city(cname);
+    free(cname);
 }
 
-void
-reset_animation_times (void)
+void reset_animation_times(void)
 {
     int x, y;
     for (y = 0; y &lt; WORLD_SIDE_LEN; y++)
-	for (x = 0; x &lt; WORLD_SIDE_LEN; x++) {
-	    if (MP_GROUP_IS_RESIDENCE(x,y))
-		MP_INFO(x,y).int_3 = 0;
-	    else if (MP_GROUP(x,y) == GROUP_WINDMILL)
-		MP_INFO(x,y).int_4 = 0;
-	    else if (MP_GROUP(x,y) == GROUP_BLACKSMITH)
-		MP_INFO(x,y).int_4 = 0;
-	    else if (MP_GROUP(x,y) == GROUP_MILL)
-		MP_INFO(x,y).int_4 = 0;
-	    else if (MP_GROUP(x,y) == GROUP_POTTERY)
-		MP_INFO(x,y).int_4 = 0;
-	    else if (MP_GROUP(x,y) == GROUP_CRICKET)
-		MP_INFO(x,y).int_4 = 0;
-	    else if (MP_GROUP(x,y) == GROUP_FIRESTATION)
-		MP_INFO(x,y).int_4 = 0;
-	    else if (MP_GROUP(x,y) == GROUP_FIRE)
-	    {
-		MP_INFO(x,y).int_1 = 0;
-		MP_INFO(x,y).int_3 = 0;
-	    }
-	    else if (MP_GROUP(x,y) == GROUP_COMMUNE)
-		MP_INFO(x,y).int_1 = 0;
-	    else if (MP_GROUP(x,y) == GROUP_ROCKET)
-		MP_INFO(x,y).int_5 = 0;
-	    else if (MP_GROUP(x,y) == GROUP_INDUSTRY_H)
-		MP_INFO(x,y).int_6 = 0;
-	    else if (MP_GROUP(x,y) == GROUP_INDUSTRY_L)
-		MP_INFO(x,y).int_7 = 0;
-	}
+        for (x = 0; x &lt; WORLD_SIDE_LEN; x++) {
+            if (MP_GROUP_IS_RESIDENCE(x, y))
+                MP_INFO(x, y).int_3 = 0;
+            else if (MP_GROUP(x, y) == GROUP_WINDMILL)
+                MP_INFO(x, y).int_4 = 0;
+            else if (MP_GROUP(x, y) == GROUP_BLACKSMITH)
+                MP_INFO(x, y).int_4 = 0;
+            else if (MP_GROUP(x, y) == GROUP_MILL)
+                MP_INFO(x, y).int_4 = 0;
+            else if (MP_GROUP(x, y) == GROUP_POTTERY)
+                MP_INFO(x, y).int_4 = 0;
+            else if (MP_GROUP(x, y) == GROUP_CRICKET)
+                MP_INFO(x, y).int_4 = 0;
+            else if (MP_GROUP(x, y) == GROUP_FIRESTATION)
+                MP_INFO(x, y).int_4 = 0;
+            else if (MP_GROUP(x, y) == GROUP_FIRE) {
+                MP_INFO(x, y).int_1 = 0;
+                MP_INFO(x, y).int_3 = 0;
+            } else if (MP_GROUP(x, y) == GROUP_COMMUNE)
+                MP_INFO(x, y).int_1 = 0;
+            else if (MP_GROUP(x, y) == GROUP_ROCKET)
+                MP_INFO(x, y).int_5 = 0;
+            else if (MP_GROUP(x, y) == GROUP_INDUSTRY_H)
+                MP_INFO(x, y).int_6 = 0;
+            else if (MP_GROUP(x, y) == GROUP_INDUSTRY_L)
+                MP_INFO(x, y).int_7 = 0;
+        }
 }
 
-/* Returns 1 if the city is proper version */ /* AL1 unused in NG 1.1 */
-int 
-verify_city (char *cname)
+                                              /* Returns 1 if the city is proper version *//* AL1 unused in NG 1.1 */
+int verify_city(char *cname)
 {
     gzFile fp;
-    char* s;
+    char *s;
     char str[256];
     int v;
 
     if (strlen(cname) == 0) {
-	return 0;
+        return 0;
     }
-    if ((s = (char *) malloc (lc_save_dir_len + strlen(cname) + 2)) == 0)
-	malloc_failure ();
-    sprintf (s, &quot;%s%c%s&quot;, lc_save_dir, PATH_SLASH, cname);
+    if ((s = (char *)malloc(lc_save_dir_len + strlen(cname) + 2)) == 0)
+        malloc_failure();
+    sprintf(s, &quot;%s%c%s&quot;, lc_save_dir, PATH_SLASH, cname);
     if (!file_exists(s)) {
-	free (s);
-	return 0;
+        free(s);
+        return 0;
     }
-    fp = gzopen( s, &quot;r&quot; );
+    fp = gzopen(s, &quot;r&quot;);
     if (fp == NULL) {
-	v = 0;
-    } else if (1 != sscanf ( gzgets( fp, str, 256 ) , &quot;%d&quot;, &amp;v)) {
-	v = 0;
+        v = 0;
+    } else if (1 != sscanf(gzgets(fp, str, 256), &quot;%d&quot;, &amp;v)) {
+        v = 0;
     }
     gzclose(fp);
-    free (s);
+    free(s);
     return v == VERSION_INT;
 }
 
 #ifdef MP_SANITY_CHECK
-void
-sanity_check (void)
+void sanity_check(void)
 {
     static int flag = 0;
     int x, y, xx, yy;
     for (x = 0; x &lt; WORLD_SIDE_LEN; x++)
-	for (y = 0; y &lt; WORLD_SIDE_LEN; y++) {
-	    if (MP_TYPE(x,y) == CST_USED) {
-		xx = MP_INFO(x,y).int_1;
-		yy = MP_INFO(x,y).int_2;
-		if (xx &lt; (x - 4) || yy &lt; (y - 4) || xx &gt; x || yy &gt; y ||
-		    xx &lt; 0 || xx &gt; WORLD_SIDE_LEN ||
-		    yy &lt; 0 || yy &gt; WORLD_SIDE_LEN) {
-		    printf (&quot;Sanity failed at %d %d, points to %d %d\n&quot;, x, y, xx, yy);
-		    if (flag == 0)
-			yn_dial_box (&quot;MP sanity check error&quot;,
-				     &quot;Please mail  <A HREF="https://lists.berlios.de/mailman/listinfo/lincity-ng-commit">lincity-users at lists.sourceforge.net</A>&quot;,
-				     &quot;telling me what you just did.&quot;,
-				     &quot;Do you think I'll find this bug?&quot;);
-		    flag = 1;
-		}
-	    }
-	}
+        for (y = 0; y &lt; WORLD_SIDE_LEN; y++) {
+            if (MP_TYPE(x, y) == CST_USED) {
+                xx = MP_INFO(x, y).int_1;
+                yy = MP_INFO(x, y).int_2;
+                if (xx &lt; (x - 4) || yy &lt; (y - 4) || xx &gt; x || yy &gt; y ||
+                    xx &lt; 0 || xx &gt; WORLD_SIDE_LEN || yy &lt; 0 || yy &gt; WORLD_SIDE_LEN) {
+                    printf(&quot;Sanity failed at %d %d, points to %d %d\n&quot;, x, y, xx, yy);
+                    if (flag == 0)
+                        yn_dial_box(&quot;MP sanity check error&quot;,
+                                    &quot;Please mail  <A HREF="https://lists.berlios.de/mailman/listinfo/lincity-ng-commit">lincity-users at lists.sourceforge.net</A>&quot;,
+                                    &quot;telling me what you just did.&quot;, &quot;Do you think I'll find this bug?&quot;);
+                    flag = 1;
+                }
+            }
+        }
 }
 #endif
 
-
-void
-check_endian (void)
+void check_endian(void)
 {
     static int flag = 0;
     char *cs;
     int t, x, y;
     t = 0;
-    cs = (char *) &t;
+    cs = (char *)&t;
     *cs = 1;
-    if (t == 1)			/* little endian */
-	return;
+    if (t == 1)                 /* little endian */
+        return;
     if (flag == 0) {
-	flag = 1;
+        flag = 1;
     }
     for (y = 0; y &lt; WORLD_SIDE_LEN; y++) {
-	for (x = 0; x &lt; WORLD_SIDE_LEN; x++) {
-	    eswap32 (&amp;(MP_INFO(x,y).population));
-	    eswap32 (&amp;(MP_INFO(x,y).flags));
-	    if (sizeof (short) == 2) {
-		eswap16 (&amp;(MP_INFO(x,y).coal_reserve));
-		eswap16 (&amp;(MP_INFO(x,y).ore_reserve));
-	    } else if (sizeof (short) == 4) {
-		eswap32 ((int *) &amp;(MP_INFO(x,y).coal_reserve));
-		eswap32 ((int *) &amp;(MP_INFO(x,y).ore_reserve));
-	    } else {
-		printf (&quot;Strange size (%d) for short, please mail me.\n&quot;,
-			sizeof (short));
-	    }
-	    eswap32 (&amp;(MP_INFO(x,y).int_1));
-	    eswap32 (&amp;(MP_INFO(x,y).int_2));
-	    eswap32 (&amp;(MP_INFO(x,y).int_3));
-	    eswap32 (&amp;(MP_INFO(x,y).int_4));
-	    eswap32 (&amp;(MP_INFO(x,y).int_5));
-	    eswap32 (&amp;(MP_INFO(x,y).int_6));
-	    eswap32 (&amp;(MP_INFO(x,y).int_7));
-	}
+        for (x = 0; x &lt; WORLD_SIDE_LEN; x++) {
+            eswap32(&amp;(MP_INFO(x, y).population));
+            eswap32(&amp;(MP_INFO(x, y).flags));
+            if (sizeof(short) == 2) {
+                eswap16(&amp;(MP_INFO(x, y).coal_reserve));
+                eswap16(&amp;(MP_INFO(x, y).ore_reserve));
+            } else if (sizeof(short) == 4) {
+                eswap32((int *)&amp;(MP_INFO(x, y).coal_reserve));
+                eswap32((int *)&amp;(MP_INFO(x, y).ore_reserve));
+            } else {
+                printf(&quot;Strange size (%d) for short, please mail me.\n&quot;, sizeof(short));
+            }
+            eswap32(&amp;(MP_INFO(x, y).int_1));
+            eswap32(&amp;(MP_INFO(x, y).int_2));
+            eswap32(&amp;(MP_INFO(x, y).int_3));
+            eswap32(&amp;(MP_INFO(x, y).int_4));
+            eswap32(&amp;(MP_INFO(x, y).int_5));
+            eswap32(&amp;(MP_INFO(x, y).int_6));
+            eswap32(&amp;(MP_INFO(x, y).int_7));
+        }
     }
 }
 
-void
-eswap32 (int *i)
+void eswap32(int *i)
 {
-  char *cs, c1, c2, c3, c4;
-  cs = (char *) i;
-  c1 = *cs;
-  c2 = *(cs + 1);
-  c3 = *(cs + 2);
-  c4 = *(cs + 3);
-  *(cs++) = c4;
-  *(cs++) = c3;
-  *(cs++) = c2;
-  *cs = c1;
+    char *cs, c1, c2, c3, c4;
+    cs = (char *)i;
+    c1 = *cs;
+    c2 = *(cs + 1);
+    c3 = *(cs + 2);
+    c4 = *(cs + 3);
+    *(cs++) = c4;
+    *(cs++) = c3;
+    *(cs++) = c2;
+    *cs = c1;
 }
 
-void
-eswap16 (unsigned short *i)
+void eswap16(unsigned short *i)
 {
-  char *cs, c1, c2;
-  cs = (char *) i;
-  c1 = *cs;
-  c2 = *(cs + 1);
-  *(cs++) = c2;
-  *cs = c1;
+    char *cs, c1, c2;
+    cs = (char *)i;
+    c1 = *cs;
+    c2 = *(cs + 1);
+    *(cs++) = c2;
+    *cs = c1;
 }

Modified: trunk/src/lincity/ldsvguts.h
===================================================================
--- trunk/src/lincity/ldsvguts.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/ldsvguts.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -9,7 +9,7 @@
 #ifndef __ldsvguts_h__
 #define __ldsvguts_h__
 
-void load_saved_city (char *s);
-void sanity_check (void);
+void load_saved_city(char *s);
+void sanity_check(void);
 
-#endif	/* __ldsvguts_h__ */
+#endif /* __ldsvguts_h__ */

Modified: trunk/src/lincity/lin-city.h
===================================================================
--- trunk/src/lincity/lin-city.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/lin-city.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -168,13 +168,13 @@
 #define FLAG_CRICKET_COVER      (0x400000)
 #define FLAG_IS_RIVER           (0x800000)
 #define FLAG_HAD_POWER          (0x1000000)
-#define FLAG_MULTI_TRANSPORT    (0x2000000)   /* Is it a multitransport? */ /* AL1: unused in NG 1.1 */
-#define FLAG_MULTI_TRANS_PREV   (0x4000000)	  /* AL1: unused in NG 1.1 */
+#define FLAG_MULTI_TRANSPORT    (0x2000000)   /* Is it a multitransport? */     /* AL1: unused in NG 1.1 */
+#define FLAG_MULTI_TRANS_PREV   (0x4000000)     /* AL1: unused in NG 1.1 */
 #define FLAG_POWER_LINE         (0x8000000)
 #define FLAG_WATERWELL_COVER    (0x10000000)
 #define FLAG_HAS_UNDERGROUND_WATER (0x20000000)
 #define FLAG_ASKED_FOR_POWER       (0x40000000)
-#define FLAG_GOT_POWER             (0x80000000) /* 2^31 = last flag*/
+#define FLAG_GOT_POWER             (0x80000000) /* 2^31 = last flag */
 
 /* XXX: It would appear that the following T_ are used exactly two times each,
    in market.c.  */
@@ -225,8 +225,8 @@
 #endif
 #define RESULTS_FILENAME &quot;results&quot;
 
-#define MAX_ICON_LEN 4096	/* AL1 unused in NG */
-#define WORLD_SIDE_LEN 100	/* Minimap size is hardcoded 200 pixel =&gt; some job to do ...*/
+#define MAX_ICON_LEN 4096       /* AL1 unused in NG */
+#define WORLD_SIDE_LEN 100      /* Minimap size is hardcoded 200 pixel =&gt; some job to do ... */
 #define NUMOF_DAYS_IN_MONTH 100
 #define NUMOF_DAYS_IN_YEAR (NUMOF_DAYS_IN_MONTH*12)
 #define FAST_TIME_FOR_YEAR 1
@@ -292,7 +292,6 @@
 #define INDUSTRY_L_POL_PER_GOOD 0.05
 #define INDUSTRY_L_POLLUTION    10
 
-
 #define MAX_ORE_AT_INDUSTRY_H 10000
 #define MAX_COAL_AT_INDUSTRY_H 1000
 #define MAX_MADE_AT_INDUSTRY_H MAX_ORE_AT_INDUSTRY_H/16
@@ -309,7 +308,7 @@
 #define ROAD_POLLUTION          1
 #define DAYS_PER_ROAD_POLLUTION 20
 #define UNNAT_DEATHS_COST       500
-#define POL_DIV                 64	/* GCS -- from engine.c */
+#define POL_DIV                 64      /* GCS -- from engine.c */
 
 #define FINANCE_X 91
 #define FINANCE_W 120
@@ -766,7 +765,7 @@
 #define GROUP_MARKET_FIREC 80
 
 #define GROUP_TRACK	   7
-#define GROUP_TRACK_COLOUR 32	/* 32 is a brown */
+#define GROUP_TRACK_COLOUR 32   /* 32 is a brown */
 #define GROUP_TRACK_COST   1
 #define GROUP_TRACK_COST_MUL 25
 #define GROUP_TRACK_BUL_COST   10
@@ -855,7 +854,7 @@
 #define GROUP_PORT_FIREC 50
 
 #define GROUP_INDUSTRY_H   18
-#define GROUP_INDUSTRY_H_COLOUR (7)	/* colour 7 is an orange, sort of */
+#define GROUP_INDUSTRY_H_COLOUR (7)     /* colour 7 is an orange, sort of */
 #define GROUP_INDUSTRY_H_COST 50000
 #define GROUP_INDUSTRY_H_COST_MUL 20
 #define GROUP_INDUSTRY_H_BUL_COST 70000
@@ -886,7 +885,7 @@
 #define GROUP_WATER_COST_MUL 2
 #define GROUP_WATER_BUL_COST      1000000
 #define GROUP_WATER_TECH      0
-#define GROUP_RIVER (GROUP_WATER)	/* oops -- GCS: Why oops? */
+#define GROUP_RIVER (GROUP_WATER)       /* oops -- GCS: Why oops? */
 #define GROUP_WATER_FIREC 0
 
 #define GROUP_HEALTH       22
@@ -972,18 +971,18 @@
 
 #define GROUP_BURNT        32
 #define GROUP_BURNT_COLOUR    (red(30))
-#define GROUP_BURNT_COST   0        /* Unused */
-#define GROUP_BURNT_COST_MUL   1    /* Unused */
+#define GROUP_BURNT_COST   0    /* Unused */
+#define GROUP_BURNT_COST_MUL   1        /* Unused */
 #define GROUP_BURNT_BUL_COST  1000
-#define GROUP_BURNT_TECH   0        /* Unused */
+#define GROUP_BURNT_TECH   0    /* Unused */
 #define GROUP_BURNT_FIREC  0
 
 #define GROUP_SHANTY        33
 #define GROUP_SHANTY_COLOUR    (red(22))
-#define GROUP_SHANTY_COST   0        /* Unused */
-#define GROUP_SHANTY_COST_MUL   1    /* Unused */
+#define GROUP_SHANTY_COST   0   /* Unused */
+#define GROUP_SHANTY_COST_MUL   1       /* Unused */
 #define GROUP_SHANTY_BUL_COST  100000
-#define GROUP_SHANTY_TECH   0        /* Unused */
+#define GROUP_SHANTY_TECH   0   /* Unused */
 #define GROUP_SHANTY_FIREC     25
 
 #define SHANTY_MIN_PP     150
@@ -998,19 +997,19 @@
 
 #define GROUP_FIRE        34
 #define GROUP_FIRE_COLOUR    (red(30))
-#define GROUP_FIRE_COST   0        /* Unused */
-#define GROUP_FIRE_COST_MUL   1    /* Unused */
+#define GROUP_FIRE_COST   0     /* Unused */
+#define GROUP_FIRE_COST_MUL   1 /* Unused */
 #define GROUP_FIRE_BUL_COST  1000
-#define GROUP_FIRE_TECH   0        /* Unused */
+#define GROUP_FIRE_TECH   0     /* Unused */
 #define GROUP_FIRE_FIREC  0
 
 #define GROUP_USED        35
-#define GROUP_USED_COLOUR (green(12))  /* Unused */
-#define GROUP_USED_COST   0            /* Unused */
-#define GROUP_USED_COST_MUL  1         /* Unused */
-#define GROUP_USED_BUL_COST  0         /* Unused */
-#define GROUP_USED_TECH   0            /* Unused */
-#define GROUP_USED_FIREC  0            /* Unused */
+#define GROUP_USED_COLOUR (green(12))   /* Unused */
+#define GROUP_USED_COST   0     /* Unused */
+#define GROUP_USED_COST_MUL  1  /* Unused */
+#define GROUP_USED_BUL_COST  0  /* Unused */
+#define GROUP_USED_TECH   0     /* Unused */
+#define GROUP_USED_FIREC  0     /* Unused */
 
 #define GROUP_RESIDENCE_ML 36
 #define GROUP_RESIDENCE_ML_COLOUR (cyan(24))
@@ -1033,7 +1032,7 @@
 #define GROUP_RESIDENCE_LH_COST 800
 #define GROUP_RESIDENCE_LH_COST_MUL 25
 #define GROUP_RESIDENCE_LH_BUL_COST 1000
-#define GROUP_RESIDENCE_LH_TECH 0          /* ?? */
+#define GROUP_RESIDENCE_LH_TECH 0       /* ?? */
 #define GROUP_RESIDENCE_LH_FIREC 75
 
 #define GROUP_RESIDENCE_MH 39
@@ -1060,7 +1059,7 @@
 #define GROUP_WATERWELL_TECH      0
 #define GROUP_WATERWELL_FIREC 0
 
-#define GROUP_DESERT 	  42 
+#define GROUP_DESERT 	  42
 #define GROUP_DESERT_COLOUR  (yellow(18))
 #define GROUP_DESERT_COST    0
 #define GROUP_DESERT_COST_MUL 1
@@ -1092,7 +1091,6 @@
 #define GROUP_TREE3_TECH    0
 #define GROUP_TREE3_FIREC   0
 
-
 #define GROUP_IS_TRANSPORT(group) \
             ((group == GROUP_TRACK) || \
              (group == GROUP_ROAD) || \
@@ -1126,197 +1124,191 @@
 #define cyan(x) (192 + x)
 #define white(x) (224 + x)
 
-
-struct map_point_info_struct
-{
-  int population;
-  int flags;
-  unsigned short coal_reserve;
-  unsigned short ore_reserve;
-  int int_1;
-  int int_2;
-  int int_3;
-  int int_4;
-  int int_5;
-  int int_6;
-  int int_7;
+struct map_point_info_struct {
+    int population;
+    int flags;
+    unsigned short coal_reserve;
+    unsigned short ore_reserve;
+    int int_1;
+    int int_2;
+    int int_3;
+    int int_4;
+    int int_5;
+    int int_6;
+    int int_7;
 };
 typedef struct map_point_info_struct Map_Point_Info;
 
-
 /* Set these flags to true when they need to be updated on the screen */
-struct update_scoreboard_struct
-{
-  int mps;
-  int mini;
-  int date;
-  int money;
-  int monthly;
-  int yearly_1;
-  int yearly_2;
-  long int message_area;
+struct update_scoreboard_struct {
+    int mps;
+    int mini;
+    int date;
+    int money;
+    int monthly;
+    int yearly_1;
+    int yearly_2;
+    long int message_area;
 };
 typedef struct update_scoreboard_struct Update_Scoreboard;
 
-
 /*
   main functions
   **************
 */
-extern int lincity_main (int, char **);
-extern void client_main_loop (void);
-extern void do_error (const char *);
-extern void do_save_city (void);
-extern void remove_scene (char *);
-extern void save_city (char *);
-extern void do_load_city (void);
-extern void load_opening_city (char *);
-extern void load_city (char *);
-extern void reset_animation_times (void);
-extern void coal_reserve_setup (void);
-extern void ore_reserve_setup (void);
-extern void setup_river (void);
-extern void setup_river2 (int, int, int);
-extern void check_savedir (void);
-extern void make_savedir (void);
-extern void draw_save_dir (int);
-extern void input_save_filename (char *);
-extern void load_start_image (void);
-extern void start_image_text (void);
-extern void si_scroll_text (void);
-extern char si_next_char (FILE *);
-extern void get_real_time (void);
-extern void debug_writeval (int);
-extern int cheat (void);
-extern void print_cheat (void);
-extern void unprint_cheat (void);
-extern void order_select_buttons (void);
-extern void lincityrc (void);
-extern void check_for_old_save_dir (void);
-extern int count_groups (int);
-extern int compile_results (void);
-extern void print_results (void);
-extern void mail_results (void);
-extern void window_results (void);
-extern void init_path_strings (void);
-extern void lc_usleep (unsigned long);
-extern void dump_tcore (void);
+extern int lincity_main(int, char **);
+extern void client_main_loop(void);
+extern void do_error(const char *);
+extern void do_save_city(void);
+extern void remove_scene(char *);
+extern void save_city(char *);
+extern void do_load_city(void);
+extern void load_opening_city(char *);
+extern void load_city(char *);
+extern void reset_animation_times(void);
+extern void coal_reserve_setup(void);
+extern void ore_reserve_setup(void);
+extern void setup_river(void);
+extern void setup_river2(int, int, int);
+extern void check_savedir(void);
+extern void make_savedir(void);
+extern void draw_save_dir(int);
+extern void input_save_filename(char *);
+extern void load_start_image(void);
+extern void start_image_text(void);
+extern void si_scroll_text(void);
+extern char si_next_char(FILE *);
+extern void get_real_time(void);
+extern void debug_writeval(int);
+extern int cheat(void);
+extern void print_cheat(void);
+extern void unprint_cheat(void);
+extern void order_select_buttons(void);
+extern void lincityrc(void);
+extern void check_for_old_save_dir(void);
+extern int count_groups(int);
+extern int compile_results(void);
+extern void print_results(void);
+extern void mail_results(void);
+extern void window_results(void);
+extern void init_path_strings(void);
+extern void lc_usleep(unsigned long);
+extern void dump_tcore(void);
 #ifndef LC_X11
-extern void parse_args (int, char **);
+extern void parse_args(int, char **);
 #endif
-extern void sustainability_test (void);
-extern int sust_fire_cover (void);
-extern void check_endian (void);
-extern void eswap32 (int *);
-extern void eswap16 (unsigned short *);
-extern void malloc_failure (void);
+extern void sustainability_test(void);
+extern int sust_fire_cover(void);
+extern void check_endian(void);
+extern void eswap32(int *);
+extern void eswap16(unsigned short *);
+extern void malloc_failure(void);
 
 /*
   fileutil
   ********
 */
-void malloc_failure (void);
+void malloc_failure(void);
 //FILE* fopen_read_gzipped (char* fn);
 //void fclose_read_gzipped (FILE* fp);
-void verify_package (void);
+void verify_package(void);
 
 /*
   ldsvgui
   *******
 */
-void load_opening_city (char *s);
-void check_savedir (void);
+void load_opening_city(char *s);
+void check_savedir(void);
 
 /*
   opening
   *******
 */
-void load_start_image (void);
+void load_start_image(void);
 
-
 /*
   type init functions
   *******************
 */
-extern void init_types (void);
-extern void init_type_graphics (void);
-void init_costs (void);
-int get_selected_type_cost (short selected_type);
-extern char *load_graphic (char *);
+extern void init_types(void);
+extern void init_type_graphics(void);
+void init_costs(void);
+int get_selected_type_cost(short selected_type);
+extern char *load_graphic(char *);
 
 /*
   screen functions
   ****************
 */
 #ifdef CS_PROFILE
-extern void FPgl_write (int, int, char *);
-extern void FPgl_getbox (int, int, int, int, void *);
-extern void FPgl_putbox (int, int, int, int, void *);
-extern void FPgl_fillbox (int, int, int, int, int);
-extern void FPgl_hline (int, int, int, int);
-extern void FPgl_line (int, int, int, int, int);
-extern void FPgl_setpixel (int, int, int);
+extern void FPgl_write(int, int, char *);
+extern void FPgl_getbox(int, int, int, int, void *);
+extern void FPgl_putbox(int, int, int, int, void *);
+extern void FPgl_fillbox(int, int, int, int, int);
+extern void FPgl_hline(int, int, int, int);
+extern void FPgl_line(int, int, int, int, int);
+extern void FPgl_setpixel(int, int, int);
 #endif
-extern void check_power_line_graphics (void);
-extern void check_water_graphics (void);
-extern void check_track_graphics (void);
-extern void check_rail_graphics (void);
-extern void check_road_graphics (void);
-extern int select_power_line_type (int, int, int, int);
-extern int select_water_type (int, int, int, int);
-extern int select_track_type (int, int, int, int);
-extern int select_rail_type (int, int, int, int);
-extern int select_road_type (int, int, int, int);
-extern void update_select_buttons (void);
-extern void draw_main_window_box (int);
-extern void draw_select_button_graphic (int, char *);
-extern void setcustompalette (void);
-extern void clip_main_window (void);
-extern void unclip_main_window (void);
-extern void initfont (void);
-extern void load_scroll_buttons (void);
-extern void draw_scroll_buttons (void);
-extern void update_mini_screen (void);
-extern void draw_mini_screen (void);
-extern void draw_big_mini_screen (void);
-extern void draw_mini_screen_pollution (void);
-extern void draw_mini_screen_fire_cover (void);
-extern void draw_mini_screen_cricket_cover (void);
-extern void draw_mini_screen_health_cover (void);
-extern void draw_mini_screen_ub40 (void);
-extern void draw_mini_screen_starve (void);
-extern void draw_mini_screen_coal (void);
-extern void draw_mini_screen_power (void);
-extern void draw_mini_screen_ocost (void);
-extern void draw_mini_screen_port (void);
-extern void draw_mini_screen_cursor (void);
-extern void print_stats (void);
-extern void print_total_money (void);
-int ask_launch_rocket_now (int x, int y);
-void print_date (void);
-extern void draw_market_cb (void);
-extern void clicked_market_cb (int, int);
-extern void close_market_cb (void);
-extern void draw_port_cb (void);
-extern void clicked_port_cb (int, int);
-extern void close_port_cb (void);
-extern int yn_dial_box (const char *, const char *, const char *, const char *);
-extern void ok_dial_box (const char *, int, const char *);
-extern int inv_sbut (int);
-extern void call_select_change_up (int);
-extern void beg_space_pad (const char *, int);
-extern void draw_up_pbar (int, int, int, int);
-extern void draw_down_pbar (int, int, int, int);
-extern void do_pbar_population (int);
-extern void do_pbar_tech (int);
-extern void do_pbar_food (int);
-extern void do_pbar_jobs (int);
-extern void do_pbar_coal (int);
-extern void do_pbar_goods (int);
-extern void do_pbar_ore (int);
-extern void do_pbar_steel (int);
-extern void do_pbar_money (int);
-extern void prog_box (const char *, int);
+extern void check_power_line_graphics(void);
+extern void check_water_graphics(void);
+extern void check_track_graphics(void);
+extern void check_rail_graphics(void);
+extern void check_road_graphics(void);
+extern int select_power_line_type(int, int, int, int);
+extern int select_water_type(int, int, int, int);
+extern int select_track_type(int, int, int, int);
+extern int select_rail_type(int, int, int, int);
+extern int select_road_type(int, int, int, int);
+extern void update_select_buttons(void);
+extern void draw_main_window_box(int);
+extern void draw_select_button_graphic(int, char *);
+extern void setcustompalette(void);
+extern void clip_main_window(void);
+extern void unclip_main_window(void);
+extern void initfont(void);
+extern void load_scroll_buttons(void);
+extern void draw_scroll_buttons(void);
+extern void update_mini_screen(void);
+extern void draw_mini_screen(void);
+extern void draw_big_mini_screen(void);
+extern void draw_mini_screen_pollution(void);
+extern void draw_mini_screen_fire_cover(void);
+extern void draw_mini_screen_cricket_cover(void);
+extern void draw_mini_screen_health_cover(void);
+extern void draw_mini_screen_ub40(void);
+extern void draw_mini_screen_starve(void);
+extern void draw_mini_screen_coal(void);
+extern void draw_mini_screen_power(void);
+extern void draw_mini_screen_ocost(void);
+extern void draw_mini_screen_port(void);
+extern void draw_mini_screen_cursor(void);
+extern void print_stats(void);
+extern void print_total_money(void);
+int ask_launch_rocket_now(int x, int y);
+void print_date(void);
+extern void draw_market_cb(void);
+extern void clicked_market_cb(int, int);
+extern void close_market_cb(void);
+extern void draw_port_cb(void);
+extern void clicked_port_cb(int, int);
+extern void close_port_cb(void);
+extern int yn_dial_box(const char *, const char *, const char *, const char *);
+extern void ok_dial_box(const char *, int, const char *);
+extern int inv_sbut(int);
+extern void call_select_change_up(int);
+extern void beg_space_pad(const char *, int);
+extern void draw_up_pbar(int, int, int, int);
+extern void draw_down_pbar(int, int, int, int);
+extern void do_pbar_population(int);
+extern void do_pbar_tech(int);
+extern void do_pbar_food(int);
+extern void do_pbar_jobs(int);
+extern void do_pbar_coal(int);
+extern void do_pbar_goods(int);
+extern void do_pbar_ore(int);
+extern void do_pbar_steel(int);
+extern void do_pbar_money(int);
+extern void prog_box(const char *, int);
 /*
   mouse functions -- are now in mouse.h, where they should be!
   ***************
@@ -1326,134 +1318,134 @@
   engine functions
   ****************
 */
-void initialize_tax_rates (void);
-void set_mappoint (int x, int y, short selected_type);
-void set_mappoint_used (int, int, int, int);
-int no_credit_build (int selected_type);
-void set_mappoint_ints (int fromx, int fromy, int x, int y);
-void new_city (int* originx, int* originy, int random_village);
-extern void engine_do_time_step (void);
-extern void do_residence (int, int);
-extern void debug_print (int);
-extern void do_power_source (int, int);
-extern void do_power_source_coal (int, int);
-extern void do_industry_l (int, int);
-extern void do_industry_h (int, int);
-extern void do_power_substation (int, int);
-extern int get_power (int, int, int, int);
-extern int add_a_substation (int, int);
-extern void remove_a_substation (int, int);
-extern void do_organic_farm (int, int);
-void init_mappoint_array (void);
-extern void shuffle_mappoint_array (void);
-extern void shuffle_substations (void);
-extern void do_coalmine (int, int);
-extern void do_oremine (int, int);
-extern void do_commune (int, int);
-extern void do_port (int, int);
+void initialize_tax_rates(void);
+void set_mappoint(int x, int y, short selected_type);
+void set_mappoint_used(int, int, int, int);
+int no_credit_build(int selected_type);
+void set_mappoint_ints(int fromx, int fromy, int x, int y);
+void new_city(int *originx, int *originy, int random_village);
+extern void engine_do_time_step(void);
+extern void do_residence(int, int);
+extern void debug_print(int);
+extern void do_power_source(int, int);
+extern void do_power_source_coal(int, int);
+extern void do_industry_l(int, int);
+extern void do_industry_h(int, int);
+extern void do_power_substation(int, int);
+extern int get_power(int, int, int, int);
+extern int add_a_substation(int, int);
+extern void remove_a_substation(int, int);
+extern void do_organic_farm(int, int);
+void init_mappoint_array(void);
+extern void shuffle_mappoint_array(void);
+extern void shuffle_substations(void);
+extern void do_coalmine(int, int);
+extern void do_oremine(int, int);
+extern void do_commune(int, int);
+extern void do_port(int, int);
 
-extern void do_pollution (void);
-extern void do_parkland (int, int);
-extern void do_university (int, int);
-extern void do_recycle (int, int);
-extern void do_health_centre (int, int);
-extern void do_rocket_pad (int, int);
-extern void launch_rocket (int x, int y);
-extern void do_windmill (int, int);
-extern void do_monument (int, int);
-extern void do_school (int, int);
-extern void do_blacksmith (int, int);
-extern void do_mill (int, int);
-extern void do_pottery (int, int);
-extern void do_firestation (int, int);
-extern void do_cricket (int, int);
-extern void clear_fire_health_and_cricket_cover (void);
-extern void do_fire_health_and_cricket_cover (void);
-extern void do_fire_cover (int, int);
-extern void do_health_cover (int, int);
-extern void do_cricket_cover (int, int);
-extern void do_random_fire (int, int, int);
-extern void do_fire (int, int);
-extern int spiral_find_group (int, int, int);
-extern int spiral_find_2x2 (int, int);
-extern void add_a_shanty (void);
-extern void remove_a_shanty (int, int);
-extern void update_shanty (void);
-extern void do_shanty (int, int);
-extern void do_tip (int, int);
-extern void update_tech_dep (int, int);
-extern void do_waterwell_cover (int, int);
+extern void do_pollution(void);
+extern void do_parkland(int, int);
+extern void do_university(int, int);
+extern void do_recycle(int, int);
+extern void do_health_centre(int, int);
+extern void do_rocket_pad(int, int);
+extern void launch_rocket(int x, int y);
+extern void do_windmill(int, int);
+extern void do_monument(int, int);
+extern void do_school(int, int);
+extern void do_blacksmith(int, int);
+extern void do_mill(int, int);
+extern void do_pottery(int, int);
+extern void do_firestation(int, int);
+extern void do_cricket(int, int);
+extern void clear_fire_health_and_cricket_cover(void);
+extern void do_fire_health_and_cricket_cover(void);
+extern void do_fire_cover(int, int);
+extern void do_health_cover(int, int);
+extern void do_cricket_cover(int, int);
+extern void do_random_fire(int, int, int);
+extern void do_fire(int, int);
+extern int spiral_find_group(int, int, int);
+extern int spiral_find_2x2(int, int);
+extern void add_a_shanty(void);
+extern void remove_a_shanty(int, int);
+extern void update_shanty(void);
+extern void do_shanty(int, int);
+extern void do_tip(int, int);
+extern void update_tech_dep(int, int);
+extern void do_waterwell_cover(int, int);
 /*
    transport functions
    *******************
 */
-void connect_transport (int originx, int originy, int w, int h);
-extern void do_power_line (int, int);
-extern void do_track (int, int);
-extern void do_rail (int, int);
-extern void do_road (int, int);
-extern void general_transport (Map_Point_Info *, int *, int, int *);
+void connect_transport(int originx, int originy, int w, int h);
+extern void do_power_line(int, int);
+extern void do_track(int, int);
+extern void do_rail(int, int);
+extern void do_road(int, int);
+extern void general_transport(Map_Point_Info *, int *, int, int *);
 
 /*
    market functions
    ****************
 */
-extern int get_food (int, int, int);
-extern int put_food (int, int, int);
-extern int get_jobs (int, int, int);
-extern int put_jobs (int, int, int);
-extern int get_goods (int, int, int);
-extern int put_goods (int, int, int);
-extern int get_ore (int, int, int);
-extern int put_ore (int, int, int);
-extern int get_coal (int, int, int);
-extern int put_coal (int, int, int);
-extern int add_a_market (int, int);
-extern void remove_a_market (int, int);
-extern void do_market (int, int);
-extern void shuffle_markets (void);
-extern int deal_with_transport (int, int, int, int);
-extern int get_steel (int, int, int);
-extern int put_steel (int, int, int);
-extern int get_waste (int, int, int);
-extern int put_waste (int, int, int);
-extern int get_stuff (int, int, int, int);
-extern int get_stuff2 (Map_Point_Info *, int, int);
-extern int get_stuff3 (Map_Point_Info *, int, int);
-extern int get_stuff4 (Map_Point_Info *, int, int);
-extern int put_stuff (int, int, int, int);
-extern int put_stuff2 (Map_Point_Info *, short *, int, int);
-extern int put_stuff3 (Map_Point_Info *, short *, int, int);
-extern int put_stuff4 (Map_Point_Info *, short *, int, int);
+extern int get_food(int, int, int);
+extern int put_food(int, int, int);
+extern int get_jobs(int, int, int);
+extern int put_jobs(int, int, int);
+extern int get_goods(int, int, int);
+extern int put_goods(int, int, int);
+extern int get_ore(int, int, int);
+extern int put_ore(int, int, int);
+extern int get_coal(int, int, int);
+extern int put_coal(int, int, int);
+extern int add_a_market(int, int);
+extern void remove_a_market(int, int);
+extern void do_market(int, int);
+extern void shuffle_markets(void);
+extern int deal_with_transport(int, int, int, int);
+extern int get_steel(int, int, int);
+extern int put_steel(int, int, int);
+extern int get_waste(int, int, int);
+extern int put_waste(int, int, int);
+extern int get_stuff(int, int, int, int);
+extern int get_stuff2(Map_Point_Info *, int, int);
+extern int get_stuff3(Map_Point_Info *, int, int);
+extern int get_stuff4(Map_Point_Info *, int, int);
+extern int put_stuff(int, int, int, int);
+extern int put_stuff2(Map_Point_Info *, short *, int, int);
+extern int put_stuff3(Map_Point_Info *, short *, int, int);
+extern int put_stuff4(Map_Point_Info *, short *, int, int);
 
 #if defined SDL
 #warning &quot;SDL defined&quot;
 #include &lt;SDL/SDL.h&gt;
 
-extern void sdl_gl_write (int, int, char *);
-extern void sdl_gl_getbox (int, int, int, int, void *);
-extern void sdl_gl_putbox (int, int, int, int, void *);
-extern void sdl_gl_fillbox (int, int, int, int, Uint32 col);
+extern void sdl_gl_write(int, int, char *);
+extern void sdl_gl_getbox(int, int, int, int, void *);
+extern void sdl_gl_putbox(int, int, int, int, void *);
+extern void sdl_gl_fillbox(int, int, int, int, Uint32 col);
 
-extern void sdl_gl_hline (int x1, int y1, int x2, Uint32 col);
-extern void sdl_gl_vline (int x1, int y1, int y2, Uint32 col);
-extern void sdl_gl_line (int x1, int y1, int x2, int y2, Uint32 col);
+extern void sdl_gl_hline(int x1, int y1, int x2, Uint32 col);
+extern void sdl_gl_vline(int x1, int y1, int y2, Uint32 col);
+extern void sdl_gl_line(int x1, int y1, int x2, int y2, Uint32 col);
 
-extern void sdl_gl_setpixel (int x, int y, Uint32 col);
-extern void sdl_gl_setfontcolors (Uint32 bg, Uint32 fg);
-extern void sdl_gl_setfont (int, int, void *);
-extern void sdl_gl_enableclipping (void);
-extern void sdl_gl_setclippingwindow (int, int, int, int);
-extern void sdl_gl_disableclipping (void);
+extern void sdl_gl_setpixel(int x, int y, Uint32 col);
+extern void sdl_gl_setfontcolors(Uint32 bg, Uint32 fg);
+extern void sdl_gl_setfont(int, int, void *);
+extern void sdl_gl_enableclipping(void);
+extern void sdl_gl_setclippingwindow(int, int, int, int);
+extern void sdl_gl_disableclipping(void);
 
-extern void sdl_blit (int x, int y, int w, int h, SDL_Surface *);
+extern void sdl_blit(int x, int y, int w, int h, SDL_Surface *);
 
 /* Wait for a key or some other event */
-extern int sdl_wait_for_key (void);
-extern int sdl_update_wait_for_key (void);
+extern int sdl_wait_for_key(void);
+extern int sdl_update_wait_for_key(void);
 
-extern int sdl_check_key (void);
-extern int sdl_update_check_key (void);
+extern int sdl_check_key(void);
+extern int sdl_update_check_key(void);
 
 #define sdl_map_rgb(r,g,b) SDL_MapRGB(display.surface-&gt;format, r, g, b)
 
@@ -1461,7 +1453,7 @@
 
 #define sdl_flip() SDL_Flip(display.surface)
 
-extern void sdl_clear (Uint32 col);
+extern void sdl_clear(Uint32 col);
 
 #define Fgl_write(a,b,c) sdl_gl_write(a,b,c)
 #define Fgl_getbox(a,b,c,d,e) sdl_gl_getbox(a,b,c,d,e)
@@ -1476,50 +1468,48 @@
 #define Fgl_setclippingwindow(a,b,c,d) sdl_gl_setclippingwindow(a,b,c,d)
 #define Fgl_disableclipping() sdl_gl_disableclipping()
 
-
-
 #elif defined LC_X11
 /* ----- X11 functions ----- */
-extern void Fgl_write (int, int, const char *);
-extern void open_write (int, int, const char *);
-extern void Fgl_getbox (int, int, int, int, void *);
-extern void Fgl_putbox (int, int, int, int, void *);
-extern void Fgl_fillbox (int, int, int, int, int);
-extern void Fgl_hline (int, int, int, int);
-extern void Fgl_line (int, int, int, int, int);
-extern void Fgl_setpixel (int, int, int);
-extern void Fgl_setfontcolors (int, int);
-extern void Fgl_setfont (int, int, void*);
-extern void Fgl_enableclipping (void);
-extern void Fgl_setclippingwindow (int, int, int, int);
-extern void Fgl_disableclipping (void);
+extern void Fgl_write(int, int, const char *);
+extern void open_write(int, int, const char *);
+extern void Fgl_getbox(int, int, int, int, void *);
+extern void Fgl_putbox(int, int, int, int, void *);
+extern void Fgl_fillbox(int, int, int, int, int);
+extern void Fgl_hline(int, int, int, int);
+extern void Fgl_line(int, int, int, int, int);
+extern void Fgl_setpixel(int, int, int);
+extern void Fgl_setfontcolors(int, int);
+extern void Fgl_setfont(int, int, void *);
+extern void Fgl_enableclipping(void);
+extern void Fgl_setclippingwindow(int, int, int, int);
+extern void Fgl_disableclipping(void);
 #ifdef USE_X11_PIXMAPS
 #define USE_PIXMAPS
-extern void init_pixmaps (void);
-extern void init_icon_pixmap (short);
-extern void update_pixmap (int, int, int, int, int, int, int, char *);
+extern void init_pixmaps(void);
+extern void init_icon_pixmap(short);
+extern void update_pixmap(int, int, int, int, int, int, int, char *);
 #endif
 
 #elif defined (WIN32)
 /* ----- Win32 functions ----- */
-extern void gl_setpalettecolor (long, long, long, long);
-extern void Fgl_write (int, int, const char *);
-extern void open_write (int, int, const char *);
-extern void Fgl_getbox (int, int, int, int, void *);
-extern void Fgl_putbox (int, int, int, int, void *);
-extern void Fgl_fillbox (int, int, int, int, int);
-extern void Fgl_hline (int, int, int, int);
-extern void Fgl_line (int, int, int, int, int);
-extern void Fgl_setpixel (int, int, int);
-extern void Fgl_setfontcolors (int, int);
-extern void Fgl_setfont (int, int, void*);
-extern void Fgl_enableclipping (void);
-extern void Fgl_setclippingwindow (int, int, int, int);
-extern void Fgl_disableclipping (void);
-#define USE_PIXMAPS		/* Always */
-extern void init_pixmaps (void);
-extern void init_icon_pixmap (short);
-extern void update_pixmap (int, int, int, int, int, int, int, char *);
+extern void gl_setpalettecolor(long, long, long, long);
+extern void Fgl_write(int, int, const char *);
+extern void open_write(int, int, const char *);
+extern void Fgl_getbox(int, int, int, int, void *);
+extern void Fgl_putbox(int, int, int, int, void *);
+extern void Fgl_fillbox(int, int, int, int, int);
+extern void Fgl_hline(int, int, int, int);
+extern void Fgl_line(int, int, int, int, int);
+extern void Fgl_setpixel(int, int, int);
+extern void Fgl_setfontcolors(int, int);
+extern void Fgl_setfont(int, int, void *);
+extern void Fgl_enableclipping(void);
+extern void Fgl_setclippingwindow(int, int, int, int);
+extern void Fgl_disableclipping(void);
+#define USE_PIXMAPS             /* Always */
+extern void init_pixmaps(void);
+extern void init_icon_pixmap(short);
+extern void update_pixmap(int, int, int, int, int, int, int, char *);
 
 #else
 /* ----- SVGALIB functions ----- */

Modified: trunk/src/lincity/lintypes.cpp
===================================================================
--- trunk/src/lincity/lintypes.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/lintypes.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -3,7 +3,7 @@
  * This file is part of lincity.
  * Lincity is copyright (c) I J Peters 1995-1997, (c) Greg Sharp 1997-2001.
  * ---------------------------------------------------------------------- */
-#include &lt;string.h&gt; /* XXX: portability issue?  for strcpy */
+#include &lt;string.h&gt;             /* XXX: portability issue?  for strcpy */
 #include &quot;lcconfig.h&quot;
 #include &quot;lin-city.h&quot;
 #include &quot;engglobs.h&quot;
@@ -16,1574 +16,1413 @@
 
 struct TYPE main_types[NUM_OF_TYPES];
 
-struct GROUP main_groups[NUM_OF_GROUPS] =
-{
+struct GROUP main_groups[NUM_OF_GROUPS] = {
     /* 0 */
-    { N_(&quot;Empty&quot;),       /* name */
-      FALSE,            /* need credit? */
-      GROUP_BARE,       /* group number */
-      1,                /* size */
-      (green(12)),      /* color */
-      1,                /* cost multiplier */
-      1,                /* bulldoze cost */
-      0,                /* probability of fire */
-      0,                /* cost */
-      0                 /* tech */
-    },
+    {N_(&quot;Empty&quot;),               /* name */
+     FALSE,                     /* need credit? */
+     GROUP_BARE,                /* group number */
+     1,                         /* size */
+     (green(12)),               /* color */
+     1,                         /* cost multiplier */
+     1,                         /* bulldoze cost */
+     0,                         /* probability of fire */
+     0,                         /* cost */
+     0                          /* tech */
+     },
     /* 1 */
-    { N_(&quot;Power line&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_POWER_LINE,
-      1,                               /* size */
-      GROUP_POWER_LINE_COLOUR,
-      GROUP_POWER_LINE_COST_MUL,
-      GROUP_POWER_LINE_BUL_COST,
-      GROUP_POWER_LINE_FIREC,
-      GROUP_POWER_LINE_COST,
-      GROUP_POWER_LINE_TECH
-    },
+    {N_(&quot;Power line&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_POWER_LINE,
+     1,                         /* size */
+     GROUP_POWER_LINE_COLOUR,
+     GROUP_POWER_LINE_COST_MUL,
+     GROUP_POWER_LINE_BUL_COST,
+     GROUP_POWER_LINE_FIREC,
+     GROUP_POWER_LINE_COST,
+     GROUP_POWER_LINE_TECH},
     /* 2 */
-    { N_(&quot;Solar PS&quot;),
-      TRUE,                            /* need credit? */
-      GROUP_SOLAR_POWER,
-      4,                               /* size */
-      GROUP_SOLAR_POWER_COLOUR,
-      GROUP_SOLAR_POWER_COST_MUL,
-      GROUP_SOLAR_POWER_BUL_COST,
-      GROUP_SOLAR_POWER_FIREC,
-      GROUP_SOLAR_POWER_COST,
-      GROUP_SOLAR_POWER_TECH
-    },
+    {N_(&quot;Solar PS&quot;),
+     TRUE,                      /* need credit? */
+     GROUP_SOLAR_POWER,
+     4,                         /* size */
+     GROUP_SOLAR_POWER_COLOUR,
+     GROUP_SOLAR_POWER_COST_MUL,
+     GROUP_SOLAR_POWER_BUL_COST,
+     GROUP_SOLAR_POWER_FIREC,
+     GROUP_SOLAR_POWER_COST,
+     GROUP_SOLAR_POWER_TECH},
     /* 3 */
-    { N_(&quot;Substation&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_SUBSTATION,
-      2,                               /* size */
-      GROUP_SUBSTATION_COLOUR,
-      GROUP_SUBSTATION_COST_MUL,
-      GROUP_SUBSTATION_BUL_COST,
-      GROUP_SUBSTATION_FIREC,
-      GROUP_SUBSTATION_COST,
-      GROUP_SUBSTATION_TECH
-    },
+    {N_(&quot;Substation&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_SUBSTATION,
+     2,                         /* size */
+     GROUP_SUBSTATION_COLOUR,
+     GROUP_SUBSTATION_COST_MUL,
+     GROUP_SUBSTATION_BUL_COST,
+     GROUP_SUBSTATION_FIREC,
+     GROUP_SUBSTATION_COST,
+     GROUP_SUBSTATION_TECH},
     /* 4 */
-    { N_(&quot;Residential LL&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_RESIDENCE_LL,
-      3,                               /* size */
-      GROUP_RESIDENCE_LL_COLOUR,
-      GROUP_RESIDENCE_LL_COST_MUL,
-      GROUP_RESIDENCE_LL_BUL_COST,
-      GROUP_RESIDENCE_LL_FIREC,
-      GROUP_RESIDENCE_LL_COST,
-      GROUP_RESIDENCE_LL_TECH
-    },
+    {N_(&quot;Residential LL&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_RESIDENCE_LL,
+     3,                         /* size */
+     GROUP_RESIDENCE_LL_COLOUR,
+     GROUP_RESIDENCE_LL_COST_MUL,
+     GROUP_RESIDENCE_LL_BUL_COST,
+     GROUP_RESIDENCE_LL_FIREC,
+     GROUP_RESIDENCE_LL_COST,
+     GROUP_RESIDENCE_LL_TECH},
     /* 5 */
-    { N_(&quot;Farm&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_ORGANIC_FARM,
-      4,                               /* size */
-      GROUP_ORGANIC_FARM_COLOUR,
-      GROUP_ORGANIC_FARM_COST_MUL,
-      GROUP_ORGANIC_FARM_BUL_COST,
-      GROUP_ORGANIC_FARM_FIREC,
-      GROUP_ORGANIC_FARM_COST,
-      GROUP_ORGANIC_FARM_TECH
-    },
+    {N_(&quot;Farm&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_ORGANIC_FARM,
+     4,                         /* size */
+     GROUP_ORGANIC_FARM_COLOUR,
+     GROUP_ORGANIC_FARM_COST_MUL,
+     GROUP_ORGANIC_FARM_BUL_COST,
+     GROUP_ORGANIC_FARM_FIREC,
+     GROUP_ORGANIC_FARM_COST,
+     GROUP_ORGANIC_FARM_TECH},
     /* 6 */
-    { N_(&quot;Market&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_MARKET,
-      2,                               /* size */
-      GROUP_MARKET_COLOUR,
-      GROUP_MARKET_COST_MUL,
-      GROUP_MARKET_BUL_COST,
-      GROUP_MARKET_FIREC,
-      GROUP_MARKET_COST,
-      GROUP_MARKET_TECH
-    },
+    {N_(&quot;Market&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_MARKET,
+     2,                         /* size */
+     GROUP_MARKET_COLOUR,
+     GROUP_MARKET_COST_MUL,
+     GROUP_MARKET_BUL_COST,
+     GROUP_MARKET_FIREC,
+     GROUP_MARKET_COST,
+     GROUP_MARKET_TECH},
     /* 7 */
-    { N_(&quot;Track&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_TRACK,
-      1,                               /* size */
-      GROUP_TRACK_COLOUR,
-      GROUP_TRACK_COST_MUL,
-      GROUP_TRACK_BUL_COST,
-      GROUP_TRACK_FIREC,
-      GROUP_TRACK_COST,
-      GROUP_TRACK_TECH
-    },
+    {N_(&quot;Track&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_TRACK,
+     1,                         /* size */
+     GROUP_TRACK_COLOUR,
+     GROUP_TRACK_COST_MUL,
+     GROUP_TRACK_BUL_COST,
+     GROUP_TRACK_FIREC,
+     GROUP_TRACK_COST,
+     GROUP_TRACK_TECH},
     /* 8 */
-    { N_(&quot;Coalmine&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_COALMINE,
-      4,                               /* size */
-      GROUP_COALMINE_COLOUR,
-      GROUP_COALMINE_COST_MUL,
-      GROUP_COALMINE_BUL_COST,
-      GROUP_COALMINE_FIREC,
-      GROUP_COALMINE_COST,
-      GROUP_COALMINE_TECH
-    },
+    {N_(&quot;Coalmine&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_COALMINE,
+     4,                         /* size */
+     GROUP_COALMINE_COLOUR,
+     GROUP_COALMINE_COST_MUL,
+     GROUP_COALMINE_BUL_COST,
+     GROUP_COALMINE_FIREC,
+     GROUP_COALMINE_COST,
+     GROUP_COALMINE_TECH},
     /* 9 */
-    { N_(&quot;Railway&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_RAIL,
-      1,                               /* size */
-      GROUP_RAIL_COLOUR,
-      GROUP_RAIL_COST_MUL,
-      GROUP_RAIL_BUL_COST,
-      GROUP_RAIL_FIREC,
-      GROUP_RAIL_COST,
-      GROUP_RAIL_TECH
-    },
+    {N_(&quot;Railway&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_RAIL,
+     1,                         /* size */
+     GROUP_RAIL_COLOUR,
+     GROUP_RAIL_COST_MUL,
+     GROUP_RAIL_BUL_COST,
+     GROUP_RAIL_FIREC,
+     GROUP_RAIL_COST,
+     GROUP_RAIL_TECH},
     /* 10 */
-    { N_(&quot;Coal PS&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_COAL_POWER,
-      4,                               /* size */
-      GROUP_COAL_POWER_COLOUR,
-      GROUP_COAL_POWER_COST_MUL,
-      GROUP_COAL_POWER_BUL_COST,
-      GROUP_COAL_POWER_FIREC,
-      GROUP_COAL_POWER_COST,
-      GROUP_COAL_POWER_TECH
-    },
+    {N_(&quot;Coal PS&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_COAL_POWER,
+     4,                         /* size */
+     GROUP_COAL_POWER_COLOUR,
+     GROUP_COAL_POWER_COST_MUL,
+     GROUP_COAL_POWER_BUL_COST,
+     GROUP_COAL_POWER_FIREC,
+     GROUP_COAL_POWER_COST,
+     GROUP_COAL_POWER_TECH},
     /* 11 */
-    { N_(&quot;Road&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_ROAD,
-      1,                               /* size */
-      GROUP_ROAD_COLOUR,
-      GROUP_ROAD_COST_MUL,
-      GROUP_ROAD_BUL_COST,
-      GROUP_ROAD_FIREC,
-      GROUP_ROAD_COST,
-      GROUP_ROAD_TECH
-    },
+    {N_(&quot;Road&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_ROAD,
+     1,                         /* size */
+     GROUP_ROAD_COLOUR,
+     GROUP_ROAD_COST_MUL,
+     GROUP_ROAD_BUL_COST,
+     GROUP_ROAD_FIREC,
+     GROUP_ROAD_COST,
+     GROUP_ROAD_TECH},
     /* 12 */
-    { N_(&quot;Lt. Industry&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_INDUSTRY_L,
-      3,                               /* size */
-      GROUP_INDUSTRY_L_COLOUR,
-      GROUP_INDUSTRY_L_COST_MUL,
-      GROUP_INDUSTRY_L_BUL_COST,
-      GROUP_INDUSTRY_L_FIREC,
-      GROUP_INDUSTRY_L_COST,
-      GROUP_INDUSTRY_L_TECH
-    },
+    {N_(&quot;Lt. Industry&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_INDUSTRY_L,
+     3,                         /* size */
+     GROUP_INDUSTRY_L_COLOUR,
+     GROUP_INDUSTRY_L_COST_MUL,
+     GROUP_INDUSTRY_L_BUL_COST,
+     GROUP_INDUSTRY_L_FIREC,
+     GROUP_INDUSTRY_L_COST,
+     GROUP_INDUSTRY_L_TECH},
     /* 13 */
-    { N_(&quot;University&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_UNIVERSITY,
-      3,                               /* size */
-      GROUP_UNIVERSITY_COLOUR,
-      GROUP_UNIVERSITY_COST_MUL,
-      GROUP_UNIVERSITY_BUL_COST,
-      GROUP_UNIVERSITY_FIREC,
-      GROUP_UNIVERSITY_COST,
-      GROUP_UNIVERSITY_TECH
-    },
+    {N_(&quot;University&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_UNIVERSITY,
+     3,                         /* size */
+     GROUP_UNIVERSITY_COLOUR,
+     GROUP_UNIVERSITY_COST_MUL,
+     GROUP_UNIVERSITY_BUL_COST,
+     GROUP_UNIVERSITY_FIREC,
+     GROUP_UNIVERSITY_COST,
+     GROUP_UNIVERSITY_TECH},
     /* 14 */
-    { N_(&quot;Commune&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_COMMUNE,
-      4,                               /* size */
-      GROUP_COMMUNE_COLOUR,
-      GROUP_COMMUNE_COST_MUL,
-      GROUP_COMMUNE_BUL_COST,
-      GROUP_COMMUNE_FIREC,
-      GROUP_COMMUNE_COST,
-      GROUP_COMMUNE_TECH
-    },
+    {N_(&quot;Commune&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_COMMUNE,
+     4,                         /* size */
+     GROUP_COMMUNE_COLOUR,
+     GROUP_COMMUNE_COST_MUL,
+     GROUP_COMMUNE_BUL_COST,
+     GROUP_COMMUNE_FIREC,
+     GROUP_COMMUNE_COST,
+     GROUP_COMMUNE_TECH},
     /* 15 */
-    { N_(&quot;Ore mine&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_OREMINE,
-      4,                               /* size */
-      GROUP_OREMINE_COLOUR,
-      GROUP_OREMINE_COST_MUL,
-      GROUP_OREMINE_BUL_COST,
-      GROUP_OREMINE_FIREC,
-      GROUP_OREMINE_COST,
-      GROUP_OREMINE_TECH
-    },
+    {N_(&quot;Ore mine&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_OREMINE,
+     4,                         /* size */
+     GROUP_OREMINE_COLOUR,
+     GROUP_OREMINE_COST_MUL,
+     GROUP_OREMINE_BUL_COST,
+     GROUP_OREMINE_FIREC,
+     GROUP_OREMINE_COST,
+     GROUP_OREMINE_TECH},
     /* 16 */
-    { N_(&quot;Rubbish tip&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_TIP,
-      4,                               /* size */
-      GROUP_TIP_COLOUR,
-      GROUP_TIP_COST_MUL,
-      GROUP_TIP_BUL_COST,
-      GROUP_TIP_FIREC,
-      GROUP_TIP_COST,
-      GROUP_TIP_TECH
-    },
+    {N_(&quot;Rubbish tip&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_TIP,
+     4,                         /* size */
+     GROUP_TIP_COLOUR,
+     GROUP_TIP_COST_MUL,
+     GROUP_TIP_BUL_COST,
+     GROUP_TIP_FIREC,
+     GROUP_TIP_COST,
+     GROUP_TIP_TECH},
     /* 17 */
-    { N_(&quot;Port&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_PORT,
-      4,                               /* size */
-      GROUP_PORT_COLOUR,
-      GROUP_PORT_COST_MUL,
-      GROUP_PORT_BUL_COST,
-      GROUP_PORT_FIREC,
-      GROUP_PORT_COST,
-      GROUP_PORT_TECH
-    },
+    {N_(&quot;Port&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_PORT,
+     4,                         /* size */
+     GROUP_PORT_COLOUR,
+     GROUP_PORT_COST_MUL,
+     GROUP_PORT_BUL_COST,
+     GROUP_PORT_FIREC,
+     GROUP_PORT_COST,
+     GROUP_PORT_TECH},
     /* 18 */
-    { N_(&quot;Hv. Industry&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_INDUSTRY_H,
-      4,                               /* size */
-      GROUP_INDUSTRY_H_COLOUR,
-      GROUP_INDUSTRY_H_COST_MUL,
-      GROUP_INDUSTRY_H_BUL_COST,
-      GROUP_INDUSTRY_H_FIREC,
-      GROUP_INDUSTRY_H_COST,
-      GROUP_INDUSTRY_H_TECH
-    },
+    {N_(&quot;Hv. Industry&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_INDUSTRY_H,
+     4,                         /* size */
+     GROUP_INDUSTRY_H_COLOUR,
+     GROUP_INDUSTRY_H_COST_MUL,
+     GROUP_INDUSTRY_H_BUL_COST,
+     GROUP_INDUSTRY_H_FIREC,
+     GROUP_INDUSTRY_H_COST,
+     GROUP_INDUSTRY_H_TECH},
     /* 19 */
-    { N_(&quot;Park&quot;),
-      TRUE,                           /* need credit? */
-      GROUP_PARKLAND,
-      1,                               /* size */
-      GROUP_PARKLAND_COLOUR,
-      GROUP_PARKLAND_COST_MUL,
-      GROUP_PARKLAND_BUL_COST,
-      GROUP_PARKLAND_FIREC,
-      GROUP_PARKLAND_COST,
-      GROUP_PARKLAND_TECH
-    },
+    {N_(&quot;Park&quot;),
+     TRUE,                      /* need credit? */
+     GROUP_PARKLAND,
+     1,                         /* size */
+     GROUP_PARKLAND_COLOUR,
+     GROUP_PARKLAND_COST_MUL,
+     GROUP_PARKLAND_BUL_COST,
+     GROUP_PARKLAND_FIREC,
+     GROUP_PARKLAND_COST,
+     GROUP_PARKLAND_TECH},
     /* 20 */
-    { N_(&quot;Recycle&quot;),
-      TRUE,                           /* need credit? */
-      GROUP_RECYCLE,
-      2,                               /* size */
-      GROUP_RECYCLE_COLOUR,
-      GROUP_RECYCLE_COST_MUL,
-      GROUP_RECYCLE_BUL_COST,
-      GROUP_RECYCLE_FIREC,
-      GROUP_RECYCLE_COST,
-      GROUP_RECYCLE_TECH
-    },
+    {N_(&quot;Recycle&quot;),
+     TRUE,                      /* need credit? */
+     GROUP_RECYCLE,
+     2,                         /* size */
+     GROUP_RECYCLE_COLOUR,
+     GROUP_RECYCLE_COST_MUL,
+     GROUP_RECYCLE_BUL_COST,
+     GROUP_RECYCLE_FIREC,
+     GROUP_RECYCLE_COST,
+     GROUP_RECYCLE_TECH},
     /* 21 */
-    { N_(&quot;Water&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_WATER,
-      1,                               /* size */
-      GROUP_WATER_COLOUR,
-      GROUP_WATER_COST_MUL,
-      GROUP_WATER_BUL_COST,
-      GROUP_WATER_FIREC,
-      GROUP_WATER_COST,
-      GROUP_WATER_TECH
-    },
+    {N_(&quot;Water&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_WATER,
+     1,                         /* size */
+     GROUP_WATER_COLOUR,
+     GROUP_WATER_COST_MUL,
+     GROUP_WATER_BUL_COST,
+     GROUP_WATER_FIREC,
+     GROUP_WATER_COST,
+     GROUP_WATER_TECH},
     /* 22 */
-    { N_(&quot;Health centre&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_HEALTH,
-      2,                               /* size */
-      GROUP_HEALTH_COLOUR,
-      GROUP_HEALTH_COST_MUL,
-      GROUP_HEALTH_BUL_COST,
-      GROUP_HEALTH_FIREC,
-      GROUP_HEALTH_COST,
-      GROUP_HEALTH_TECH
-    },
+    {N_(&quot;Health centre&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_HEALTH,
+     2,                         /* size */
+     GROUP_HEALTH_COLOUR,
+     GROUP_HEALTH_COST_MUL,
+     GROUP_HEALTH_BUL_COST,
+     GROUP_HEALTH_FIREC,
+     GROUP_HEALTH_COST,
+     GROUP_HEALTH_TECH},
     /* 23 */
-    { N_(&quot;Rocket pad&quot;),
-      TRUE,                            /* need credit? */
-      GROUP_ROCKET,
-      4,                               /* size */
-      GROUP_ROCKET_COLOUR,
-      GROUP_ROCKET_COST_MUL,
-      GROUP_ROCKET_BUL_COST,
-      GROUP_ROCKET_FIREC,
-      GROUP_ROCKET_COST,
-      GROUP_ROCKET_TECH
-    },
+    {N_(&quot;Rocket pad&quot;),
+     TRUE,                      /* need credit? */
+     GROUP_ROCKET,
+     4,                         /* size */
+     GROUP_ROCKET_COLOUR,
+     GROUP_ROCKET_COST_MUL,
+     GROUP_ROCKET_BUL_COST,
+     GROUP_ROCKET_FIREC,
+     GROUP_ROCKET_COST,
+     GROUP_ROCKET_TECH},
     /* 24 */
-    { N_(&quot;Windmill&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_WINDMILL,
-      2,                               /* size */
-      GROUP_WINDMILL_COLOUR,
-      GROUP_WINDMILL_COST_MUL,
-      GROUP_WINDMILL_BUL_COST,
-      GROUP_WINDMILL_FIREC,
-      GROUP_WINDMILL_COST,
-      GROUP_WINDMILL_TECH
-    },
+    {N_(&quot;Windmill&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_WINDMILL,
+     2,                         /* size */
+     GROUP_WINDMILL_COLOUR,
+     GROUP_WINDMILL_COST_MUL,
+     GROUP_WINDMILL_BUL_COST,
+     GROUP_WINDMILL_FIREC,
+     GROUP_WINDMILL_COST,
+     GROUP_WINDMILL_TECH},
     /* 25 */
-    { N_(&quot;Monument&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_MONUMENT,
-      2,                               /* size */
-      GROUP_MONUMENT_COLOUR,
-      GROUP_MONUMENT_COST_MUL,
-      GROUP_MONUMENT_BUL_COST,
-      GROUP_MONUMENT_FIREC,
-      GROUP_MONUMENT_COST,
-      GROUP_MONUMENT_TECH
-    },
+    {N_(&quot;Monument&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_MONUMENT,
+     2,                         /* size */
+     GROUP_MONUMENT_COLOUR,
+     GROUP_MONUMENT_COST_MUL,
+     GROUP_MONUMENT_BUL_COST,
+     GROUP_MONUMENT_FIREC,
+     GROUP_MONUMENT_COST,
+     GROUP_MONUMENT_TECH},
     /* 26 */
-    { N_(&quot;School&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_SCHOOL,
-      2,                               /* size */
-      GROUP_SCHOOL_COLOUR,
-      GROUP_SCHOOL_COST_MUL,
-      GROUP_SCHOOL_BUL_COST,
-      GROUP_SCHOOL_FIREC,
-      GROUP_SCHOOL_COST,
-      GROUP_SCHOOL_TECH
-    },
+    {N_(&quot;School&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_SCHOOL,
+     2,                         /* size */
+     GROUP_SCHOOL_COLOUR,
+     GROUP_SCHOOL_COST_MUL,
+     GROUP_SCHOOL_BUL_COST,
+     GROUP_SCHOOL_FIREC,
+     GROUP_SCHOOL_COST,
+     GROUP_SCHOOL_TECH},
     /* 27 */
-    { N_(&quot;Blacksmith&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_BLACKSMITH,
-      2,                               /* size */
-      GROUP_BLACKSMITH_COLOUR,
-      GROUP_BLACKSMITH_COST_MUL,
-      GROUP_BLACKSMITH_BUL_COST,
-      GROUP_BLACKSMITH_FIREC,
-      GROUP_BLACKSMITH_COST,
-      GROUP_BLACKSMITH_TECH
-    },
+    {N_(&quot;Blacksmith&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_BLACKSMITH,
+     2,                         /* size */
+     GROUP_BLACKSMITH_COLOUR,
+     GROUP_BLACKSMITH_COST_MUL,
+     GROUP_BLACKSMITH_BUL_COST,
+     GROUP_BLACKSMITH_FIREC,
+     GROUP_BLACKSMITH_COST,
+     GROUP_BLACKSMITH_TECH},
     /* 28 */
-    { N_(&quot;Mill&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_MILL,
-      2,                               /* size */
-      GROUP_MILL_COLOUR,
-      GROUP_MILL_COST_MUL,
-      GROUP_MILL_BUL_COST,
-      GROUP_MILL_FIREC,
-      GROUP_MILL_COST,
-      GROUP_MILL_TECH
-    },
+    {N_(&quot;Mill&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_MILL,
+     2,                         /* size */
+     GROUP_MILL_COLOUR,
+     GROUP_MILL_COST_MUL,
+     GROUP_MILL_BUL_COST,
+     GROUP_MILL_FIREC,
+     GROUP_MILL_COST,
+     GROUP_MILL_TECH},
     /* 29 */
-    { N_(&quot;Pottery&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_POTTERY,
-      2,                               /* size */
-      GROUP_POTTERY_COLOUR,
-      GROUP_POTTERY_COST_MUL,
-      GROUP_POTTERY_BUL_COST,
-      GROUP_POTTERY_FIREC,
-      GROUP_POTTERY_COST,
-      GROUP_POTTERY_TECH
-    },
+    {N_(&quot;Pottery&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_POTTERY,
+     2,                         /* size */
+     GROUP_POTTERY_COLOUR,
+     GROUP_POTTERY_COST_MUL,
+     GROUP_POTTERY_BUL_COST,
+     GROUP_POTTERY_FIREC,
+     GROUP_POTTERY_COST,
+     GROUP_POTTERY_TECH},
     /* 30 */
-    { N_(&quot;Fire sta'n&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_FIRESTATION,
-      2,                               /* size */
-      GROUP_FIRESTATION_COLOUR,
-      GROUP_FIRESTATION_COST_MUL,
-      GROUP_FIRESTATION_BUL_COST,
-      GROUP_FIRESTATION_FIREC,
-      GROUP_FIRESTATION_COST,
-      GROUP_FIRESTATION_TECH
-    },
+    {N_(&quot;Fire sta'n&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_FIRESTATION,
+     2,                         /* size */
+     GROUP_FIRESTATION_COLOUR,
+     GROUP_FIRESTATION_COST_MUL,
+     GROUP_FIRESTATION_BUL_COST,
+     GROUP_FIRESTATION_FIREC,
+     GROUP_FIRESTATION_COST,
+     GROUP_FIRESTATION_TECH},
     /* 31 */
-    { N_(&quot;Sports field&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_CRICKET,
-      2,                               /* size */
-      GROUP_CRICKET_COLOUR,
-      GROUP_CRICKET_COST_MUL,
-      GROUP_CRICKET_BUL_COST,
-      GROUP_CRICKET_FIREC,
-      GROUP_CRICKET_COST,
-      GROUP_CRICKET_TECH
-    },
+    {N_(&quot;Sports field&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_CRICKET,
+     2,                         /* size */
+     GROUP_CRICKET_COLOUR,
+     GROUP_CRICKET_COST_MUL,
+     GROUP_CRICKET_BUL_COST,
+     GROUP_CRICKET_FIREC,
+     GROUP_CRICKET_COST,
+     GROUP_CRICKET_TECH},
     /* 32 */
     /* there is no button for this. */
-    { N_(&quot;Burnt&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_BURNT,
-      1,                               /* size */
-      GROUP_BURNT_COLOUR,
-      GROUP_BURNT_COST_MUL,
-      GROUP_BURNT_BUL_COST,
-      GROUP_BURNT_FIREC,
-      GROUP_BURNT_COST,
-      GROUP_BURNT_TECH
-    },
+    {N_(&quot;Burnt&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_BURNT,
+     1,                         /* size */
+     GROUP_BURNT_COLOUR,
+     GROUP_BURNT_COST_MUL,
+     GROUP_BURNT_BUL_COST,
+     GROUP_BURNT_FIREC,
+     GROUP_BURNT_COST,
+     GROUP_BURNT_TECH},
     /* 33 */
     /* there is no button for this. */
-    { N_(&quot;Shanty town&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_SHANTY,
-      2,                               /* size */
-      GROUP_SHANTY_COLOUR,
-      GROUP_SHANTY_COST_MUL,
-      GROUP_SHANTY_BUL_COST,
-      GROUP_SHANTY_FIREC,
-      GROUP_SHANTY_COST,
-      GROUP_SHANTY_TECH
-    },
+    {N_(&quot;Shanty town&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_SHANTY,
+     2,                         /* size */
+     GROUP_SHANTY_COLOUR,
+     GROUP_SHANTY_COST_MUL,
+     GROUP_SHANTY_BUL_COST,
+     GROUP_SHANTY_FIREC,
+     GROUP_SHANTY_COST,
+     GROUP_SHANTY_TECH},
     /* 34 */
     /* there is no button for this. */
-    { N_(&quot;Fire&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_FIRE,
-      1,                               /* size */
-      GROUP_FIRE_COLOUR,
-      GROUP_FIRE_COST_MUL,
-      GROUP_FIRE_BUL_COST,
-      GROUP_FIRE_FIREC,
-      GROUP_FIRE_COST,
-      GROUP_FIRE_TECH
-    },
+    {N_(&quot;Fire&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_FIRE,
+     1,                         /* size */
+     GROUP_FIRE_COLOUR,
+     GROUP_FIRE_COST_MUL,
+     GROUP_FIRE_BUL_COST,
+     GROUP_FIRE_FIREC,
+     GROUP_FIRE_COST,
+     GROUP_FIRE_TECH},
     /* 35 */
     /* there is no button for this. */
-    { N_(&quot;Used&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_USED,
-      1,                               /* size */
-      GROUP_USED_COLOUR,
-      GROUP_USED_COST_MUL,
-      GROUP_USED_BUL_COST,
-      GROUP_USED_FIREC,
-      GROUP_USED_COST,
-      GROUP_USED_TECH
-    },
+    {N_(&quot;Used&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_USED,
+     1,                         /* size */
+     GROUP_USED_COLOUR,
+     GROUP_USED_COST_MUL,
+     GROUP_USED_BUL_COST,
+     GROUP_USED_FIREC,
+     GROUP_USED_COST,
+     GROUP_USED_TECH},
     /* 36 */
-    { N_(&quot;Residential ML&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_RESIDENCE_ML,
-      3,                               /* size */
-      GROUP_RESIDENCE_ML_COLOUR,
-      GROUP_RESIDENCE_ML_COST_MUL,
-      GROUP_RESIDENCE_ML_BUL_COST,
-      GROUP_RESIDENCE_ML_FIREC,
-      GROUP_RESIDENCE_ML_COST,
-      GROUP_RESIDENCE_ML_TECH
-    },
+    {N_(&quot;Residential ML&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_RESIDENCE_ML,
+     3,                         /* size */
+     GROUP_RESIDENCE_ML_COLOUR,
+     GROUP_RESIDENCE_ML_COST_MUL,
+     GROUP_RESIDENCE_ML_BUL_COST,
+     GROUP_RESIDENCE_ML_FIREC,
+     GROUP_RESIDENCE_ML_COST,
+     GROUP_RESIDENCE_ML_TECH},
     /* 37 */
-    { N_(&quot;Residential HL&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_RESIDENCE_HL,
-      3,                               /* size */
-      GROUP_RESIDENCE_HL_COLOUR,
-      GROUP_RESIDENCE_HL_COST_MUL,
-      GROUP_RESIDENCE_HL_BUL_COST,
-      GROUP_RESIDENCE_HL_FIREC,
-      GROUP_RESIDENCE_HL_COST,
-      GROUP_RESIDENCE_HL_TECH
-    },
+    {N_(&quot;Residential HL&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_RESIDENCE_HL,
+     3,                         /* size */
+     GROUP_RESIDENCE_HL_COLOUR,
+     GROUP_RESIDENCE_HL_COST_MUL,
+     GROUP_RESIDENCE_HL_BUL_COST,
+     GROUP_RESIDENCE_HL_FIREC,
+     GROUP_RESIDENCE_HL_COST,
+     GROUP_RESIDENCE_HL_TECH},
     /* 38 */
-    { N_(&quot;Residential LH&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_RESIDENCE_LH,
-      3,                               /* size */
-      GROUP_RESIDENCE_LH_COLOUR,
-      GROUP_RESIDENCE_LH_COST_MUL,
-      GROUP_RESIDENCE_LH_BUL_COST,
-      GROUP_RESIDENCE_LH_FIREC,
-      GROUP_RESIDENCE_LH_COST,
-      GROUP_RESIDENCE_LH_TECH
-    },
+    {N_(&quot;Residential LH&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_RESIDENCE_LH,
+     3,                         /* size */
+     GROUP_RESIDENCE_LH_COLOUR,
+     GROUP_RESIDENCE_LH_COST_MUL,
+     GROUP_RESIDENCE_LH_BUL_COST,
+     GROUP_RESIDENCE_LH_FIREC,
+     GROUP_RESIDENCE_LH_COST,
+     GROUP_RESIDENCE_LH_TECH},
     /* 39 */
-    { N_(&quot;Residential MH&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_RESIDENCE_MH,
-      3,                               /* size */
-      GROUP_RESIDENCE_MH_COLOUR,
-      GROUP_RESIDENCE_MH_COST_MUL,
-      GROUP_RESIDENCE_MH_BUL_COST,
-      GROUP_RESIDENCE_MH_FIREC,
-      GROUP_RESIDENCE_MH_COST,
-      GROUP_RESIDENCE_MH_TECH
-    },
+    {N_(&quot;Residential MH&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_RESIDENCE_MH,
+     3,                         /* size */
+     GROUP_RESIDENCE_MH_COLOUR,
+     GROUP_RESIDENCE_MH_COST_MUL,
+     GROUP_RESIDENCE_MH_BUL_COST,
+     GROUP_RESIDENCE_MH_FIREC,
+     GROUP_RESIDENCE_MH_COST,
+     GROUP_RESIDENCE_MH_TECH},
     /* 40 */
-    { N_(&quot;Residential HH&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_RESIDENCE_HH,
-      3,                               /* size */
-      GROUP_RESIDENCE_HH_COLOUR,
-      GROUP_RESIDENCE_HH_COST_MUL,
-      GROUP_RESIDENCE_HH_BUL_COST,
-      GROUP_RESIDENCE_HH_FIREC,
-      GROUP_RESIDENCE_HH_COST,
-      GROUP_RESIDENCE_HH_TECH
-    },
+    {N_(&quot;Residential HH&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_RESIDENCE_HH,
+     3,                         /* size */
+     GROUP_RESIDENCE_HH_COLOUR,
+     GROUP_RESIDENCE_HH_COST_MUL,
+     GROUP_RESIDENCE_HH_BUL_COST,
+     GROUP_RESIDENCE_HH_FIREC,
+     GROUP_RESIDENCE_HH_COST,
+     GROUP_RESIDENCE_HH_TECH},
     /* 41 */
-        { N_(&quot;Water well&quot;),
-      FALSE,                           /* need credit? */
-      GROUP_WATERWELL,
-      2,                               /* size */
-      GROUP_WATERWELL_COLOUR,
-      GROUP_WATERWELL_COST_MUL,
-      GROUP_WATERWELL_BUL_COST,
-      GROUP_WATERWELL_FIREC,
-      GROUP_WATERWELL_COST,
-      GROUP_WATERWELL_TECH
-    },
+    {N_(&quot;Water well&quot;),
+     FALSE,                     /* need credit? */
+     GROUP_WATERWELL,
+     2,                         /* size */
+     GROUP_WATERWELL_COLOUR,
+     GROUP_WATERWELL_COST_MUL,
+     GROUP_WATERWELL_BUL_COST,
+     GROUP_WATERWELL_FIREC,
+     GROUP_WATERWELL_COST,
+     GROUP_WATERWELL_TECH},
 
     /* 42 */
-    { N_(&quot;Desert&quot;),       	/* name */
-      FALSE,            	/* need credit? */
-      GROUP_DESERT,       	/* group number */
-      1,                	/* size */
-      GROUP_DESERT_COLOUR,      /* color */
-      GROUP_DESERT_COST_MUL,	/* cost multiplier */
-      GROUP_DESERT_BUL_COST,	/* bulldoze cost */
-      GROUP_DESERT_FIREC,	/* probability of fire */
-      GROUP_DESERT_COST,	/* cost */
-      GROUP_DESERT_TECH		/* tech */
-    },
+    {N_(&quot;Desert&quot;),              /* name */
+     FALSE,                     /* need credit? */
+     GROUP_DESERT,              /* group number */
+     1,                         /* size */
+     GROUP_DESERT_COLOUR,       /* color */
+     GROUP_DESERT_COST_MUL,     /* cost multiplier */
+     GROUP_DESERT_BUL_COST,     /* bulldoze cost */
+     GROUP_DESERT_FIREC,        /* probability of fire */
+     GROUP_DESERT_COST,         /* cost */
+     GROUP_DESERT_TECH          /* tech */
+     },
     /* 43 */
-    { N_(&quot;Tree&quot;),       	/* name */
-      FALSE,            	/* need credit? */
-      GROUP_TREE,       	/* group number */
-      1,                	/* size */
-      GROUP_TREE_COLOUR,	/* color */
-      GROUP_TREE_COST_MUL,	/* cost multiplier */
-      GROUP_TREE_BUL_COST,	/* bulldoze cost */
-      GROUP_TREE_FIREC,		/* probability of fire */
-      GROUP_TREE_COST,		/* cost */
-      GROUP_TREE_TECH		/* tech */
-    },
+    {N_(&quot;Tree&quot;),                /* name */
+     FALSE,                     /* need credit? */
+     GROUP_TREE,                /* group number */
+     1,                         /* size */
+     GROUP_TREE_COLOUR,         /* color */
+     GROUP_TREE_COST_MUL,       /* cost multiplier */
+     GROUP_TREE_BUL_COST,       /* bulldoze cost */
+     GROUP_TREE_FIREC,          /* probability of fire */
+     GROUP_TREE_COST,           /* cost */
+     GROUP_TREE_TECH            /* tech */
+     },
 
     /* 44 */
-    { N_(&quot;Trees&quot;),       	/* name */
-      FALSE,            	/* need credit? */
-      GROUP_TREE2,       	/* group number */
-      1,                	/* size */
-      GROUP_TREE2_COLOUR,	/* color */
-      GROUP_TREE2_COST_MUL,	/* cost multiplier */
-      GROUP_TREE2_BUL_COST,	/* bulldoze cost */
-      GROUP_TREE2_FIREC,	/* probability of fire */
-      GROUP_TREE2_COST,		/* cost */
-      GROUP_TREE2_TECH		/* tech */
-    },
+    {N_(&quot;Trees&quot;),               /* name */
+     FALSE,                     /* need credit? */
+     GROUP_TREE2,               /* group number */
+     1,                         /* size */
+     GROUP_TREE2_COLOUR,        /* color */
+     GROUP_TREE2_COST_MUL,      /* cost multiplier */
+     GROUP_TREE2_BUL_COST,      /* bulldoze cost */
+     GROUP_TREE2_FIREC,         /* probability of fire */
+     GROUP_TREE2_COST,          /* cost */
+     GROUP_TREE2_TECH           /* tech */
+     },
 
     /* 45 */
-    { N_(&quot;Forest&quot;),       	/* name */
-      FALSE,            	/* need credit? */
-      GROUP_TREE3,       	/* group number */
-      1,                	/* size */
-      GROUP_TREE3_COLOUR,	/* color */
-      GROUP_TREE3_COST_MUL,	/* cost multiplier */
-      GROUP_TREE3_BUL_COST,	/* bulldoze cost */
-      GROUP_TREE3_FIREC,	/* probability of fire */
-      GROUP_TREE3_COST,		/* cost */
-      GROUP_TREE3_TECH		/* tech */
-    },
+    {N_(&quot;Forest&quot;),              /* name */
+     FALSE,                     /* need credit? */
+     GROUP_TREE3,               /* group number */
+     1,                         /* size */
+     GROUP_TREE3_COLOUR,        /* color */
+     GROUP_TREE3_COST_MUL,      /* cost multiplier */
+     GROUP_TREE3_BUL_COST,      /* bulldoze cost */
+     GROUP_TREE3_FIREC,         /* probability of fire */
+     GROUP_TREE3_COST,          /* cost */
+     GROUP_TREE3_TECH           /* tech */
+     },
 
     /* 46 */
     /* End of Data */
-    { &quot;EOF&quot;,
-      FALSE,                           /* need credit? */
-      0,
-      0,                               /* size */
-      0,
-      0,
-      0,
-      0,
-      0,
-      0
-    }
+    {&quot;EOF&quot;,
+     FALSE,                     /* need credit? */
+     0,
+     0,                         /* size */
+     0,
+     0,
+     0,
+     0,
+     0,
+     0}
 };
 
 void init_types(void)
 {
     char png_file[LC_PATH_MAX], txt_file[LC_PATH_MAX];
-    sprintf (png_file, &quot;%s%c%s&quot;, opening_path, PATH_SLASH, &quot;icons.png&quot;);
-    sprintf (txt_file, &quot;%s%c%s&quot;, opening_path, PATH_SLASH, &quot;iconlist.txt&quot;);
+    sprintf(png_file, &quot;%s%c%s&quot;, opening_path, PATH_SLASH, &quot;icons.png&quot;);
+    sprintf(txt_file, &quot;%s%c%s&quot;, opening_path, PATH_SLASH, &quot;iconlist.txt&quot;);
 
-    load_png_graphics (txt_file,png_file);
+    load_png_graphics(txt_file, png_file);
 
 #if defined (commentout)
-    main_types[CST_GREEN].group=GROUP_BARE;
-    main_types[CST_GREEN].graphic=load_graphic(CST_GREEN_G);
+    main_types[CST_GREEN].group = GROUP_BARE;
+    main_types[CST_GREEN].graphic = load_graphic(CST_GREEN_G);
 
-    main_types[CST_POWERL_H_L].group=GROUP_POWER_LINE;
-    main_types[CST_POWERL_H_L].graphic=load_graphic(CST_POWERL_H_L_G);
+    main_types[CST_POWERL_H_L].group = GROUP_POWER_LINE;
+    main_types[CST_POWERL_H_L].graphic = load_graphic(CST_POWERL_H_L_G);
 
-    main_types[CST_POWERL_V_L].group=GROUP_POWER_LINE;
-    main_types[CST_POWERL_V_L].graphic=load_graphic(CST_POWERL_V_L_G);
+    main_types[CST_POWERL_V_L].group = GROUP_POWER_LINE;
+    main_types[CST_POWERL_V_L].graphic = load_graphic(CST_POWERL_V_L_G);
 
-    main_types[CST_POWERL_LD_L].group=GROUP_POWER_LINE;
-    main_types[CST_POWERL_LD_L].graphic=load_graphic(CST_POWERL_LD_L_G);
+    main_types[CST_POWERL_LD_L].group = GROUP_POWER_LINE;
+    main_types[CST_POWERL_LD_L].graphic = load_graphic(CST_POWERL_LD_L_G);
 
-    main_types[CST_POWERL_RD_L].group=GROUP_POWER_LINE;
-    main_types[CST_POWERL_RD_L].graphic=load_graphic(CST_POWERL_RD_L_G);
+    main_types[CST_POWERL_RD_L].group = GROUP_POWER_LINE;
+    main_types[CST_POWERL_RD_L].graphic = load_graphic(CST_POWERL_RD_L_G);
 
-    main_types[CST_POWERL_LU_L].group=GROUP_POWER_LINE;
-    main_types[CST_POWERL_LU_L].graphic=load_graphic(CST_POWERL_LU_L_G);
+    main_types[CST_POWERL_LU_L].group = GROUP_POWER_LINE;
+    main_types[CST_POWERL_LU_L].graphic = load_graphic(CST_POWERL_LU_L_G);
 
-    main_types[CST_POWERL_RU_L].group=GROUP_POWER_LINE;
-    main_types[CST_POWERL_RU_L].graphic=load_graphic(CST_POWERL_RU_L_G);
+    main_types[CST_POWERL_RU_L].group = GROUP_POWER_LINE;
+    main_types[CST_POWERL_RU_L].graphic = load_graphic(CST_POWERL_RU_L_G);
 
-    main_types[CST_POWERL_LDU_L].group=GROUP_POWER_LINE;
-    main_types[CST_POWERL_LDU_L].graphic=load_graphic(CST_POWERL_LDU_L_G);
+    main_types[CST_POWERL_LDU_L].group = GROUP_POWER_LINE;
+    main_types[CST_POWERL_LDU_L].graphic = load_graphic(CST_POWERL_LDU_L_G);
 
-    main_types[CST_POWERL_LDR_L].group=GROUP_POWER_LINE;
-    main_types[CST_POWERL_LDR_L].graphic=load_graphic(CST_POWERL_LDR_L_G);
+    main_types[CST_POWERL_LDR_L].group = GROUP_POWER_LINE;
+    main_types[CST_POWERL_LDR_L].graphic = load_graphic(CST_POWERL_LDR_L_G);
 
-    main_types[CST_POWERL_LUR_L].group=GROUP_POWER_LINE;
-    main_types[CST_POWERL_LUR_L].graphic=load_graphic(CST_POWERL_LUR_L_G);
+    main_types[CST_POWERL_LUR_L].group = GROUP_POWER_LINE;
+    main_types[CST_POWERL_LUR_L].graphic = load_graphic(CST_POWERL_LUR_L_G);
 
-    main_types[CST_POWERL_UDR_L].group=GROUP_POWER_LINE;
-    main_types[CST_POWERL_UDR_L].graphic=load_graphic(CST_POWERL_UDR_L_G);
+    main_types[CST_POWERL_UDR_L].group = GROUP_POWER_LINE;
+    main_types[CST_POWERL_UDR_L].graphic = load_graphic(CST_POWERL_UDR_L_G);
 
-    main_types[CST_POWERL_LUDR_L].group=GROUP_POWER_LINE;
-    main_types[CST_POWERL_LUDR_L].graphic
-	    =load_graphic(CST_POWERL_LUDR_L_G);
+    main_types[CST_POWERL_LUDR_L].group = GROUP_POWER_LINE;
+    main_types[CST_POWERL_LUDR_L].graphic = load_graphic(CST_POWERL_LUDR_L_G);
 
-    main_types[CST_POWERL_H_D].group=GROUP_POWER_LINE;
-    main_types[CST_POWERL_H_D].graphic=load_graphic(CST_POWERL_H_D_G);
+    main_types[CST_POWERL_H_D].group = GROUP_POWER_LINE;
+    main_types[CST_POWERL_H_D].graphic = load_graphic(CST_POWERL_H_D_G);
 
-    main_types[CST_POWERL_V_D].group=GROUP_POWER_LINE;
-    main_types[CST_POWERL_V_D].graphic=load_graphic(CST_POWERL_V_D_G);
+    main_types[CST_POWERL_V_D].group = GROUP_POWER_LINE;
+    main_types[CST_POWERL_V_D].graphic = load_graphic(CST_POWERL_V_D_G);
 
-    main_types[CST_POWERL_LD_D].group=GROUP_POWER_LINE;
-    main_types[CST_POWERL_LD_D].graphic=load_graphic(CST_POWERL_LD_D_G);
+    main_types[CST_POWERL_LD_D].group = GROUP_POWER_LINE;
+    main_types[CST_POWERL_LD_D].graphic = load_graphic(CST_POWERL_LD_D_G);
 
-    main_types[CST_POWERL_RD_D].group=GROUP_POWER_LINE;
-    main_types[CST_POWERL_RD_D].graphic=load_graphic(CST_POWERL_RD_D_G);
+    main_types[CST_POWERL_RD_D].group = GROUP_POWER_LINE;
+    main_types[CST_POWERL_RD_D].graphic = load_graphic(CST_POWERL_RD_D_G);
 
-    main_types[CST_POWERL_LU_D].group=GROUP_POWER_LINE;
-    main_types[CST_POWERL_LU_D].graphic=load_graphic(CST_POWERL_LU_D_G);
+    main_types[CST_POWERL_LU_D].group = GROUP_POWER_LINE;
+    main_types[CST_POWERL_LU_D].graphic = load_graphic(CST_POWERL_LU_D_G);
 
-    main_types[CST_POWERL_RU_D].group=GROUP_POWER_LINE;
-    main_types[CST_POWERL_RU_D].graphic=load_graphic(CST_POWERL_RU_D_G);
+    main_types[CST_POWERL_RU_D].group = GROUP_POWER_LINE;
+    main_types[CST_POWERL_RU_D].graphic = load_graphic(CST_POWERL_RU_D_G);
 
-    main_types[CST_POWERL_LDU_D].group=GROUP_POWER_LINE;
-    main_types[CST_POWERL_LDU_D].graphic=load_graphic(CST_POWERL_LDU_D_G);
+    main_types[CST_POWERL_LDU_D].group = GROUP_POWER_LINE;
+    main_types[CST_POWERL_LDU_D].graphic = load_graphic(CST_POWERL_LDU_D_G);
 
-    main_types[CST_POWERL_LDR_D].group=GROUP_POWER_LINE;
-    main_types[CST_POWERL_LDR_D].graphic=load_graphic(CST_POWERL_LDR_D_G);
+    main_types[CST_POWERL_LDR_D].group = GROUP_POWER_LINE;
+    main_types[CST_POWERL_LDR_D].graphic = load_graphic(CST_POWERL_LDR_D_G);
 
-    main_types[CST_POWERL_LUR_D].group=GROUP_POWER_LINE;
-    main_types[CST_POWERL_LUR_D].graphic=load_graphic(CST_POWERL_LUR_D_G);
+    main_types[CST_POWERL_LUR_D].group = GROUP_POWER_LINE;
+    main_types[CST_POWERL_LUR_D].graphic = load_graphic(CST_POWERL_LUR_D_G);
 
-    main_types[CST_POWERL_UDR_D].group=GROUP_POWER_LINE;
-    main_types[CST_POWERL_UDR_D].graphic=load_graphic(CST_POWERL_UDR_D_G);
+    main_types[CST_POWERL_UDR_D].group = GROUP_POWER_LINE;
+    main_types[CST_POWERL_UDR_D].graphic = load_graphic(CST_POWERL_UDR_D_G);
 
-    main_types[CST_POWERL_LUDR_D].group=GROUP_POWER_LINE;
-    main_types[CST_POWERL_LUDR_D].graphic
-	    =load_graphic(CST_POWERL_LUDR_D_G);
+    main_types[CST_POWERL_LUDR_D].group = GROUP_POWER_LINE;
+    main_types[CST_POWERL_LUDR_D].graphic = load_graphic(CST_POWERL_LUDR_D_G);
 
-    main_types[CST_POWERS_SOLAR].group=GROUP_SOLAR_POWER;
-    main_types[CST_POWERS_SOLAR].graphic=load_graphic(CST_POWERS_SOLAR_G);
+    main_types[CST_POWERS_SOLAR].group = GROUP_SOLAR_POWER;
+    main_types[CST_POWERS_SOLAR].graphic = load_graphic(CST_POWERS_SOLAR_G);
 
-    main_types[CST_POWERS_COAL_EMPTY].group=GROUP_COAL_POWER;
-    main_types[CST_POWERS_COAL_EMPTY].graphic
-	    =load_graphic(CST_POWERS_COAL_EMPTY_G);
+    main_types[CST_POWERS_COAL_EMPTY].group = GROUP_COAL_POWER;
+    main_types[CST_POWERS_COAL_EMPTY].graphic = load_graphic(CST_POWERS_COAL_EMPTY_G);
 
-    main_types[CST_POWERS_COAL_LOW].group=GROUP_COAL_POWER;
-    main_types[CST_POWERS_COAL_LOW].graphic
-	    =load_graphic(CST_POWERS_COAL_LOW_G);
+    main_types[CST_POWERS_COAL_LOW].group = GROUP_COAL_POWER;
+    main_types[CST_POWERS_COAL_LOW].graphic = load_graphic(CST_POWERS_COAL_LOW_G);
 
-    prog_box(&quot;&quot;,12);
+    prog_box(&quot;&quot;, 12);
 
-    main_types[CST_POWERS_COAL_MED].group=GROUP_COAL_POWER;
-    main_types[CST_POWERS_COAL_MED].graphic
-	    =load_graphic(CST_POWERS_COAL_MED_G);
+    main_types[CST_POWERS_COAL_MED].group = GROUP_COAL_POWER;
+    main_types[CST_POWERS_COAL_MED].graphic = load_graphic(CST_POWERS_COAL_MED_G);
 
-    main_types[CST_POWERS_COAL_FULL].group=GROUP_COAL_POWER;
-    main_types[CST_POWERS_COAL_FULL].graphic
-	    =load_graphic(CST_POWERS_COAL_FULL_G);
+    main_types[CST_POWERS_COAL_FULL].group = GROUP_COAL_POWER;
+    main_types[CST_POWERS_COAL_FULL].graphic = load_graphic(CST_POWERS_COAL_FULL_G);
 
-    main_types[CST_SUBSTATION_R].group=GROUP_SUBSTATION;
-    main_types[CST_SUBSTATION_R].graphic=load_graphic(CST_SUBSTATION_R_G);
+    main_types[CST_SUBSTATION_R].group = GROUP_SUBSTATION;
+    main_types[CST_SUBSTATION_R].graphic = load_graphic(CST_SUBSTATION_R_G);
 
-    main_types[CST_SUBSTATION_G].group=GROUP_SUBSTATION;
-    main_types[CST_SUBSTATION_G].graphic=load_graphic(CST_SUBSTATION_G_G);
+    main_types[CST_SUBSTATION_G].group = GROUP_SUBSTATION;
+    main_types[CST_SUBSTATION_G].graphic = load_graphic(CST_SUBSTATION_G_G);
 
-    main_types[CST_SUBSTATION_RG].group=GROUP_SUBSTATION;
-    main_types[CST_SUBSTATION_RG].graphic
-	    =load_graphic(CST_SUBSTATION_RG_G);
+    main_types[CST_SUBSTATION_RG].group = GROUP_SUBSTATION;
+    main_types[CST_SUBSTATION_RG].graphic = load_graphic(CST_SUBSTATION_RG_G);
 
-    main_types[CST_RESIDENCE_LL].group=GROUP_RESIDENCE_LL;
-    main_types[CST_RESIDENCE_LL].graphic=load_graphic(CST_RESIDENCE_LL_G);
+    main_types[CST_RESIDENCE_LL].group = GROUP_RESIDENCE_LL;
+    main_types[CST_RESIDENCE_LL].graphic = load_graphic(CST_RESIDENCE_LL_G);
 
-    main_types[CST_RESIDENCE_ML].group=GROUP_RESIDENCE_ML;
-    main_types[CST_RESIDENCE_ML].graphic
-	    =load_graphic(CST_RESIDENCE_ML_G);
+    main_types[CST_RESIDENCE_ML].group = GROUP_RESIDENCE_ML;
+    main_types[CST_RESIDENCE_ML].graphic = load_graphic(CST_RESIDENCE_ML_G);
 
-    main_types[CST_RESIDENCE_HL].group=GROUP_RESIDENCE_HL;
-    main_types[CST_RESIDENCE_HL].graphic
-	    =load_graphic(CST_RESIDENCE_HL_G);
+    main_types[CST_RESIDENCE_HL].group = GROUP_RESIDENCE_HL;
+    main_types[CST_RESIDENCE_HL].graphic = load_graphic(CST_RESIDENCE_HL_G);
 
-    main_types[CST_RESIDENCE_LH].group=GROUP_RESIDENCE_LH;
-    main_types[CST_RESIDENCE_LH].graphic=load_graphic(CST_RESIDENCE_LH_G);
+    main_types[CST_RESIDENCE_LH].group = GROUP_RESIDENCE_LH;
+    main_types[CST_RESIDENCE_LH].graphic = load_graphic(CST_RESIDENCE_LH_G);
 
-    main_types[CST_RESIDENCE_MH].group=GROUP_RESIDENCE_MH;
-    main_types[CST_RESIDENCE_MH].graphic=load_graphic(CST_RESIDENCE_MH_G);
+    main_types[CST_RESIDENCE_MH].group = GROUP_RESIDENCE_MH;
+    main_types[CST_RESIDENCE_MH].graphic = load_graphic(CST_RESIDENCE_MH_G);
 
-    main_types[CST_RESIDENCE_HH].group=GROUP_RESIDENCE_HH;
-    main_types[CST_RESIDENCE_HH].graphic=load_graphic(CST_RESIDENCE_HH_G);
+    main_types[CST_RESIDENCE_HH].group = GROUP_RESIDENCE_HH;
+    main_types[CST_RESIDENCE_HH].graphic = load_graphic(CST_RESIDENCE_HH_G);
 
+    main_types[CST_FARM_O0].group = GROUP_ORGANIC_FARM;
+    main_types[CST_FARM_O0].graphic = load_graphic(CST_FARM_O0_G);
 
-    main_types[CST_FARM_O0].group=GROUP_ORGANIC_FARM;
-    main_types[CST_FARM_O0].graphic=load_graphic(CST_FARM_O0_G);
+    main_types[CST_FARM_O1].group = GROUP_ORGANIC_FARM;
+    main_types[CST_FARM_O1].graphic = load_graphic(CST_FARM_O1_G);
 
-    main_types[CST_FARM_O1].group=GROUP_ORGANIC_FARM;
-    main_types[CST_FARM_O1].graphic=load_graphic(CST_FARM_O1_G);
+    main_types[CST_FARM_O2].group = GROUP_ORGANIC_FARM;
+    main_types[CST_FARM_O2].graphic = load_graphic(CST_FARM_O2_G);
 
-    main_types[CST_FARM_O2].group=GROUP_ORGANIC_FARM;
-    main_types[CST_FARM_O2].graphic=load_graphic(CST_FARM_O2_G);
+    main_types[CST_FARM_O3].group = GROUP_ORGANIC_FARM;
+    main_types[CST_FARM_O3].graphic = load_graphic(CST_FARM_O3_G);
 
-    main_types[CST_FARM_O3].group=GROUP_ORGANIC_FARM;
-    main_types[CST_FARM_O3].graphic=load_graphic(CST_FARM_O3_G);
+    main_types[CST_FARM_O4].group = GROUP_ORGANIC_FARM;
+    main_types[CST_FARM_O4].graphic = load_graphic(CST_FARM_O4_G);
 
-    main_types[CST_FARM_O4].group=GROUP_ORGANIC_FARM;
-    main_types[CST_FARM_O4].graphic=load_graphic(CST_FARM_O4_G);
+    main_types[CST_FARM_O5].group = GROUP_ORGANIC_FARM;
+    main_types[CST_FARM_O5].graphic = load_graphic(CST_FARM_O5_G);
 
-    main_types[CST_FARM_O5].group=GROUP_ORGANIC_FARM;
-    main_types[CST_FARM_O5].graphic=load_graphic(CST_FARM_O5_G);
+    main_types[CST_FARM_O6].group = GROUP_ORGANIC_FARM;
+    main_types[CST_FARM_O6].graphic = load_graphic(CST_FARM_O6_G);
 
-    main_types[CST_FARM_O6].group=GROUP_ORGANIC_FARM;
-    main_types[CST_FARM_O6].graphic=load_graphic(CST_FARM_O6_G);
+    main_types[CST_FARM_O7].group = GROUP_ORGANIC_FARM;
+    main_types[CST_FARM_O7].graphic = load_graphic(CST_FARM_O7_G);
 
-    main_types[CST_FARM_O7].group=GROUP_ORGANIC_FARM;
-    main_types[CST_FARM_O7].graphic=load_graphic(CST_FARM_O7_G);
+    main_types[CST_FARM_O8].group = GROUP_ORGANIC_FARM;
+    main_types[CST_FARM_O8].graphic = load_graphic(CST_FARM_O8_G);
 
-    main_types[CST_FARM_O8].group=GROUP_ORGANIC_FARM;
-    main_types[CST_FARM_O8].graphic=load_graphic(CST_FARM_O8_G);
+    main_types[CST_FARM_O9].group = GROUP_ORGANIC_FARM;
+    main_types[CST_FARM_O9].graphic = load_graphic(CST_FARM_O9_G);
 
-    main_types[CST_FARM_O9].group=GROUP_ORGANIC_FARM;
-    main_types[CST_FARM_O9].graphic=load_graphic(CST_FARM_O9_G);
+    main_types[CST_FARM_O10].group = GROUP_ORGANIC_FARM;
+    main_types[CST_FARM_O10].graphic = load_graphic(CST_FARM_O10_G);
 
-    main_types[CST_FARM_O10].group=GROUP_ORGANIC_FARM;
-    main_types[CST_FARM_O10].graphic=load_graphic(CST_FARM_O10_G);
+    main_types[CST_FARM_O11].group = GROUP_ORGANIC_FARM;
+    main_types[CST_FARM_O11].graphic = load_graphic(CST_FARM_O11_G);
 
-    main_types[CST_FARM_O11].group=GROUP_ORGANIC_FARM;
-    main_types[CST_FARM_O11].graphic=load_graphic(CST_FARM_O11_G);
+    main_types[CST_FARM_O12].group = GROUP_ORGANIC_FARM;
+    main_types[CST_FARM_O12].graphic = load_graphic(CST_FARM_O12_G);
 
-    main_types[CST_FARM_O12].group=GROUP_ORGANIC_FARM;
-    main_types[CST_FARM_O12].graphic=load_graphic(CST_FARM_O12_G);
+    main_types[CST_FARM_O13].group = GROUP_ORGANIC_FARM;
+    main_types[CST_FARM_O13].graphic = load_graphic(CST_FARM_O13_G);
 
-    main_types[CST_FARM_O13].group=GROUP_ORGANIC_FARM;
-    main_types[CST_FARM_O13].graphic=load_graphic(CST_FARM_O13_G);
+    main_types[CST_FARM_O14].group = GROUP_ORGANIC_FARM;
+    main_types[CST_FARM_O14].graphic = load_graphic(CST_FARM_O14_G);
 
-    main_types[CST_FARM_O14].group=GROUP_ORGANIC_FARM;
-    main_types[CST_FARM_O14].graphic=load_graphic(CST_FARM_O14_G);
+    main_types[CST_FARM_O15].group = GROUP_ORGANIC_FARM;
+    main_types[CST_FARM_O15].graphic = load_graphic(CST_FARM_O15_G);
 
-    main_types[CST_FARM_O15].group=GROUP_ORGANIC_FARM;
-    main_types[CST_FARM_O15].graphic=load_graphic(CST_FARM_O15_G);
+    main_types[CST_FARM_O16].group = GROUP_ORGANIC_FARM;
+    main_types[CST_FARM_O16].graphic = load_graphic(CST_FARM_O16_G);
 
-    main_types[CST_FARM_O16].group=GROUP_ORGANIC_FARM;
-    main_types[CST_FARM_O16].graphic=load_graphic(CST_FARM_O16_G);
+    main_types[CST_MARKET_EMPTY].group = GROUP_MARKET;
+    main_types[CST_MARKET_EMPTY].graphic = load_graphic(CST_MARKET_EMPTY_G);
 
-    main_types[CST_MARKET_EMPTY].group=GROUP_MARKET;
-    main_types[CST_MARKET_EMPTY].graphic
-	    =load_graphic(CST_MARKET_EMPTY_G);
+    main_types[CST_MARKET_LOW].group = GROUP_MARKET;
+    main_types[CST_MARKET_LOW].graphic = load_graphic(CST_MARKET_LOW_G);
 
-    main_types[CST_MARKET_LOW].group=GROUP_MARKET;
-    main_types[CST_MARKET_LOW].graphic
-	    =load_graphic(CST_MARKET_LOW_G);
+    main_types[CST_MARKET_MED].group = GROUP_MARKET;
+    main_types[CST_MARKET_MED].graphic = load_graphic(CST_MARKET_MED_G);
 
-    main_types[CST_MARKET_MED].group=GROUP_MARKET;
-    main_types[CST_MARKET_MED].graphic
-	    =load_graphic(CST_MARKET_MED_G);
+    main_types[CST_MARKET_FULL].group = GROUP_MARKET;
+    main_types[CST_MARKET_FULL].graphic = load_graphic(CST_MARKET_FULL_G);
 
-    main_types[CST_MARKET_FULL].group=GROUP_MARKET;
-    main_types[CST_MARKET_FULL].graphic
-	    =load_graphic(CST_MARKET_FULL_G);
+    main_types[CST_TRACK_LR].group = GROUP_TRACK;
+    main_types[CST_TRACK_LR].graphic = load_graphic(CST_TRACK_LR_G);
 
-    main_types[CST_TRACK_LR].group=GROUP_TRACK;
-    main_types[CST_TRACK_LR].graphic=load_graphic(CST_TRACK_LR_G);
+    main_types[CST_TRACK_LU].group = GROUP_TRACK;
+    main_types[CST_TRACK_LU].graphic = load_graphic(CST_TRACK_LU_G);
 
-    main_types[CST_TRACK_LU].group=GROUP_TRACK;
-    main_types[CST_TRACK_LU].graphic=load_graphic(CST_TRACK_LU_G);
+    main_types[CST_TRACK_LD].group = GROUP_TRACK;
+    main_types[CST_TRACK_LD].graphic = load_graphic(CST_TRACK_LD_G);
 
-    main_types[CST_TRACK_LD].group=GROUP_TRACK;
-    main_types[CST_TRACK_LD].graphic=load_graphic(CST_TRACK_LD_G);
+    main_types[CST_TRACK_UD].group = GROUP_TRACK;
+    main_types[CST_TRACK_UD].graphic = load_graphic(CST_TRACK_UD_G);
 
-    main_types[CST_TRACK_UD].group=GROUP_TRACK;
-    main_types[CST_TRACK_UD].graphic=load_graphic(CST_TRACK_UD_G);
+    main_types[CST_TRACK_UR].group = GROUP_TRACK;
+    main_types[CST_TRACK_UR].graphic = load_graphic(CST_TRACK_UR_G);
 
-    main_types[CST_TRACK_UR].group=GROUP_TRACK;
-    main_types[CST_TRACK_UR].graphic=load_graphic(CST_TRACK_UR_G);
+    main_types[CST_TRACK_DR].group = GROUP_TRACK;
+    main_types[CST_TRACK_DR].graphic = load_graphic(CST_TRACK_DR_G);
 
-    main_types[CST_TRACK_DR].group=GROUP_TRACK;
-    main_types[CST_TRACK_DR].graphic=load_graphic(CST_TRACK_DR_G);
+    main_types[CST_TRACK_LUR].group = GROUP_TRACK;
+    main_types[CST_TRACK_LUR].graphic = load_graphic(CST_TRACK_LUR_G);
 
-    main_types[CST_TRACK_LUR].group=GROUP_TRACK;
-    main_types[CST_TRACK_LUR].graphic=load_graphic(CST_TRACK_LUR_G);
+    main_types[CST_TRACK_LDR].group = GROUP_TRACK;
+    main_types[CST_TRACK_LDR].graphic = load_graphic(CST_TRACK_LDR_G);
 
-    main_types[CST_TRACK_LDR].group=GROUP_TRACK;
-    main_types[CST_TRACK_LDR].graphic=load_graphic(CST_TRACK_LDR_G);
+    main_types[CST_TRACK_LUD].group = GROUP_TRACK;
+    main_types[CST_TRACK_LUD].graphic = load_graphic(CST_TRACK_LUD_G);
 
-    main_types[CST_TRACK_LUD].group=GROUP_TRACK;
-    main_types[CST_TRACK_LUD].graphic=load_graphic(CST_TRACK_LUD_G);
+    main_types[CST_TRACK_UDR].group = GROUP_TRACK;
+    main_types[CST_TRACK_UDR].graphic = load_graphic(CST_TRACK_UDR_G);
 
-    main_types[CST_TRACK_UDR].group=GROUP_TRACK;
-    main_types[CST_TRACK_UDR].graphic=load_graphic(CST_TRACK_UDR_G);
+    main_types[CST_TRACK_LUDR].group = GROUP_TRACK;
+    main_types[CST_TRACK_LUDR].graphic = load_graphic(CST_TRACK_LUDR_G);
 
-    main_types[CST_TRACK_LUDR].group=GROUP_TRACK;
-    main_types[CST_TRACK_LUDR].graphic=load_graphic(CST_TRACK_LUDR_G);
+    main_types[CST_COALMINE_EMPTY].group = GROUP_COALMINE;
+    main_types[CST_COALMINE_EMPTY].graphic = load_graphic(CST_COALMINE_EMPTY_G);
 
-    main_types[CST_COALMINE_EMPTY].group=GROUP_COALMINE;
-    main_types[CST_COALMINE_EMPTY].graphic
-	    =load_graphic(CST_COALMINE_EMPTY_G);
+    prog_box(&quot;&quot;, 25);
 
-    prog_box(&quot;&quot;,25);
+    main_types[CST_COALMINE_LOW].group = GROUP_COALMINE;
+    main_types[CST_COALMINE_LOW].graphic = load_graphic(CST_COALMINE_LOW_G);
 
-    main_types[CST_COALMINE_LOW].group=GROUP_COALMINE;
-    main_types[CST_COALMINE_LOW].graphic=load_graphic(CST_COALMINE_LOW_G);
+    main_types[CST_COALMINE_MED].group = GROUP_COALMINE;
+    main_types[CST_COALMINE_MED].graphic = load_graphic(CST_COALMINE_MED_G);
 
-    main_types[CST_COALMINE_MED].group=GROUP_COALMINE;
-    main_types[CST_COALMINE_MED].graphic=load_graphic(CST_COALMINE_MED_G);
+    main_types[CST_COALMINE_FULL].group = GROUP_COALMINE;
+    main_types[CST_COALMINE_FULL].graphic = load_graphic(CST_COALMINE_FULL_G);
 
-    main_types[CST_COALMINE_FULL].group=GROUP_COALMINE;
-    main_types[CST_COALMINE_FULL].graphic
-	    =load_graphic(CST_COALMINE_FULL_G);
+    main_types[CST_RAIL_LR].group = GROUP_RAIL;
+    main_types[CST_RAIL_LR].graphic = load_graphic(CST_RAIL_LR_G);
 
-    main_types[CST_RAIL_LR].group=GROUP_RAIL;
-    main_types[CST_RAIL_LR].graphic=load_graphic(CST_RAIL_LR_G);
+    main_types[CST_RAIL_LU].group = GROUP_RAIL;
+    main_types[CST_RAIL_LU].graphic = load_graphic(CST_RAIL_LU_G);
 
-    main_types[CST_RAIL_LU].group=GROUP_RAIL;
-    main_types[CST_RAIL_LU].graphic=load_graphic(CST_RAIL_LU_G);
+    main_types[CST_RAIL_LD].group = GROUP_RAIL;
+    main_types[CST_RAIL_LD].graphic = load_graphic(CST_RAIL_LD_G);
 
-    main_types[CST_RAIL_LD].group=GROUP_RAIL;
-    main_types[CST_RAIL_LD].graphic=load_graphic(CST_RAIL_LD_G);
+    main_types[CST_RAIL_UD].group = GROUP_RAIL;
+    main_types[CST_RAIL_UD].graphic = load_graphic(CST_RAIL_UD_G);
 
-    main_types[CST_RAIL_UD].group=GROUP_RAIL;
-    main_types[CST_RAIL_UD].graphic=load_graphic(CST_RAIL_UD_G);
+    main_types[CST_RAIL_UR].group = GROUP_RAIL;
+    main_types[CST_RAIL_UR].graphic = load_graphic(CST_RAIL_UR_G);
 
-    main_types[CST_RAIL_UR].group=GROUP_RAIL;
-    main_types[CST_RAIL_UR].graphic=load_graphic(CST_RAIL_UR_G);
+    main_types[CST_RAIL_DR].group = GROUP_RAIL;
+    main_types[CST_RAIL_DR].graphic = load_graphic(CST_RAIL_DR_G);
 
-    main_types[CST_RAIL_DR].group=GROUP_RAIL;
-    main_types[CST_RAIL_DR].graphic=load_graphic(CST_RAIL_DR_G);
+    main_types[CST_RAIL_LUR].group = GROUP_RAIL;
+    main_types[CST_RAIL_LUR].graphic = load_graphic(CST_RAIL_LUR_G);
 
-    main_types[CST_RAIL_LUR].group=GROUP_RAIL;
-    main_types[CST_RAIL_LUR].graphic=load_graphic(CST_RAIL_LUR_G);
+    main_types[CST_RAIL_LDR].group = GROUP_RAIL;
+    main_types[CST_RAIL_LDR].graphic = load_graphic(CST_RAIL_LDR_G);
 
-    main_types[CST_RAIL_LDR].group=GROUP_RAIL;
-    main_types[CST_RAIL_LDR].graphic=load_graphic(CST_RAIL_LDR_G);
+    main_types[CST_RAIL_LUD].group = GROUP_RAIL;
+    main_types[CST_RAIL_LUD].graphic = load_graphic(CST_RAIL_LUD_G);
 
-    main_types[CST_RAIL_LUD].group=GROUP_RAIL;
-    main_types[CST_RAIL_LUD].graphic=load_graphic(CST_RAIL_LUD_G);
+    prog_box(&quot;&quot;, 30);
 
-    prog_box(&quot;&quot;,30);
+    main_types[CST_RAIL_UDR].group = GROUP_RAIL;
+    main_types[CST_RAIL_UDR].graphic = load_graphic(CST_RAIL_UDR_G);
 
-    main_types[CST_RAIL_UDR].group=GROUP_RAIL;
-    main_types[CST_RAIL_UDR].graphic=load_graphic(CST_RAIL_UDR_G);
+    main_types[CST_RAIL_LUDR].group = GROUP_RAIL;
+    main_types[CST_RAIL_LUDR].graphic = load_graphic(CST_RAIL_LUDR_G);
 
-    main_types[CST_RAIL_LUDR].group=GROUP_RAIL;
-    main_types[CST_RAIL_LUDR].graphic=load_graphic(CST_RAIL_LUDR_G);
+    main_types[CST_ROAD_LR].group = GROUP_ROAD;
+    main_types[CST_ROAD_LR].graphic = load_graphic(CST_ROAD_LR_G);
 
-    main_types[CST_ROAD_LR].group=GROUP_ROAD;
-    main_types[CST_ROAD_LR].graphic=load_graphic(CST_ROAD_LR_G);
+    main_types[CST_ROAD_LU].group = GROUP_ROAD;
+    main_types[CST_ROAD_LU].graphic = load_graphic(CST_ROAD_LU_G);
 
-    main_types[CST_ROAD_LU].group=GROUP_ROAD;
-    main_types[CST_ROAD_LU].graphic=load_graphic(CST_ROAD_LU_G);
+    main_types[CST_ROAD_LD].group = GROUP_ROAD;
+    main_types[CST_ROAD_LD].graphic = load_graphic(CST_ROAD_LD_G);
 
-    main_types[CST_ROAD_LD].group=GROUP_ROAD;
-    main_types[CST_ROAD_LD].graphic=load_graphic(CST_ROAD_LD_G);
+    main_types[CST_ROAD_UD].group = GROUP_ROAD;
+    main_types[CST_ROAD_UD].graphic = load_graphic(CST_ROAD_UD_G);
 
-    main_types[CST_ROAD_UD].group=GROUP_ROAD;
-    main_types[CST_ROAD_UD].graphic=load_graphic(CST_ROAD_UD_G);
+    main_types[CST_ROAD_UR].group = GROUP_ROAD;
+    main_types[CST_ROAD_UR].graphic = load_graphic(CST_ROAD_UR_G);
 
-    main_types[CST_ROAD_UR].group=GROUP_ROAD;
-    main_types[CST_ROAD_UR].graphic=load_graphic(CST_ROAD_UR_G);
+    main_types[CST_ROAD_DR].group = GROUP_ROAD;
+    main_types[CST_ROAD_DR].graphic = load_graphic(CST_ROAD_DR_G);
 
-    main_types[CST_ROAD_DR].group=GROUP_ROAD;
-    main_types[CST_ROAD_DR].graphic=load_graphic(CST_ROAD_DR_G);
+    main_types[CST_ROAD_LUR].group = GROUP_ROAD;
+    main_types[CST_ROAD_LUR].graphic = load_graphic(CST_ROAD_LUR_G);
 
-    main_types[CST_ROAD_LUR].group=GROUP_ROAD;
-    main_types[CST_ROAD_LUR].graphic=load_graphic(CST_ROAD_LUR_G);
+    main_types[CST_ROAD_LDR].group = GROUP_ROAD;
+    main_types[CST_ROAD_LDR].graphic = load_graphic(CST_ROAD_LDR_G);
 
-    main_types[CST_ROAD_LDR].group=GROUP_ROAD;
-    main_types[CST_ROAD_LDR].graphic=load_graphic(CST_ROAD_LDR_G);
+    main_types[CST_ROAD_LUD].group = GROUP_ROAD;
+    main_types[CST_ROAD_LUD].graphic = load_graphic(CST_ROAD_LUD_G);
 
-    main_types[CST_ROAD_LUD].group=GROUP_ROAD;
-    main_types[CST_ROAD_LUD].graphic=load_graphic(CST_ROAD_LUD_G);
+    main_types[CST_ROAD_UDR].group = GROUP_ROAD;
+    main_types[CST_ROAD_UDR].graphic = load_graphic(CST_ROAD_UDR_G);
 
-    main_types[CST_ROAD_UDR].group=GROUP_ROAD;
-    main_types[CST_ROAD_UDR].graphic=load_graphic(CST_ROAD_UDR_G);
+    main_types[CST_ROAD_LUDR].group = GROUP_ROAD;
+    main_types[CST_ROAD_LUDR].graphic = load_graphic(CST_ROAD_LUDR_G);
 
-    main_types[CST_ROAD_LUDR].group=GROUP_ROAD;
-    main_types[CST_ROAD_LUDR].graphic=load_graphic(CST_ROAD_LUDR_G);
+    main_types[CST_INDUSTRY_L_C].group = GROUP_INDUSTRY_L;
+    main_types[CST_INDUSTRY_L_C].graphic = load_graphic(CST_INDUSTRY_L_C_G);
 
-    main_types[CST_INDUSTRY_L_C].group=GROUP_INDUSTRY_L;
-    main_types[CST_INDUSTRY_L_C].graphic
-	    =load_graphic(CST_INDUSTRY_L_C_G);
+    main_types[CST_INDUSTRY_L_Q1].group = GROUP_INDUSTRY_L;
+    main_types[CST_INDUSTRY_L_Q1].graphic = load_graphic(CST_INDUSTRY_L_Q1_G);
 
-    main_types[CST_INDUSTRY_L_Q1].group=GROUP_INDUSTRY_L;
-    main_types[CST_INDUSTRY_L_Q1].graphic
-	    =load_graphic(CST_INDUSTRY_L_Q1_G);
+    main_types[CST_INDUSTRY_L_Q2].group = GROUP_INDUSTRY_L;
+    main_types[CST_INDUSTRY_L_Q2].graphic = load_graphic(CST_INDUSTRY_L_Q2_G);
 
-    main_types[CST_INDUSTRY_L_Q2].group=GROUP_INDUSTRY_L;
-    main_types[CST_INDUSTRY_L_Q2].graphic
-	    =load_graphic(CST_INDUSTRY_L_Q2_G);
+    main_types[CST_INDUSTRY_L_Q3].group = GROUP_INDUSTRY_L;
+    main_types[CST_INDUSTRY_L_Q3].graphic = load_graphic(CST_INDUSTRY_L_Q3_G);
 
-    main_types[CST_INDUSTRY_L_Q3].group=GROUP_INDUSTRY_L;
-    main_types[CST_INDUSTRY_L_Q3].graphic
-	    =load_graphic(CST_INDUSTRY_L_Q3_G);
+    main_types[CST_INDUSTRY_L_Q4].group = GROUP_INDUSTRY_L;
+    main_types[CST_INDUSTRY_L_Q4].graphic = load_graphic(CST_INDUSTRY_L_Q4_G);
 
-    main_types[CST_INDUSTRY_L_Q4].group=GROUP_INDUSTRY_L;
-    main_types[CST_INDUSTRY_L_Q4].graphic
-	    =load_graphic(CST_INDUSTRY_L_Q4_G);
+    main_types[CST_INDUSTRY_L_L1].group = GROUP_INDUSTRY_L;
+    main_types[CST_INDUSTRY_L_L1].graphic = load_graphic(CST_INDUSTRY_L_L1_G);
 
-    main_types[CST_INDUSTRY_L_L1].group=GROUP_INDUSTRY_L;
-    main_types[CST_INDUSTRY_L_L1].graphic
-	    =load_graphic(CST_INDUSTRY_L_L1_G);
+    main_types[CST_INDUSTRY_L_L2].group = GROUP_INDUSTRY_L;
+    main_types[CST_INDUSTRY_L_L2].graphic = load_graphic(CST_INDUSTRY_L_L2_G);
 
-    main_types[CST_INDUSTRY_L_L2].group=GROUP_INDUSTRY_L;
-    main_types[CST_INDUSTRY_L_L2].graphic
-	    =load_graphic(CST_INDUSTRY_L_L2_G);
+    main_types[CST_INDUSTRY_L_L3].group = GROUP_INDUSTRY_L;
+    main_types[CST_INDUSTRY_L_L3].graphic = load_graphic(CST_INDUSTRY_L_L3_G);
 
-    main_types[CST_INDUSTRY_L_L3].group=GROUP_INDUSTRY_L;
-    main_types[CST_INDUSTRY_L_L3].graphic
-	    =load_graphic(CST_INDUSTRY_L_L3_G);
+    main_types[CST_INDUSTRY_L_L4].group = GROUP_INDUSTRY_L;
+    main_types[CST_INDUSTRY_L_L4].graphic = load_graphic(CST_INDUSTRY_L_L4_G);
 
-    main_types[CST_INDUSTRY_L_L4].group=GROUP_INDUSTRY_L;
-    main_types[CST_INDUSTRY_L_L4].graphic
-	    =load_graphic(CST_INDUSTRY_L_L4_G);
+    main_types[CST_INDUSTRY_L_M1].group = GROUP_INDUSTRY_L;
+    main_types[CST_INDUSTRY_L_M1].graphic = load_graphic(CST_INDUSTRY_L_M1_G);
 
+    main_types[CST_INDUSTRY_L_M2].group = GROUP_INDUSTRY_L;
+    main_types[CST_INDUSTRY_L_M2].graphic = load_graphic(CST_INDUSTRY_L_M2_G);
 
-    main_types[CST_INDUSTRY_L_M1].group=GROUP_INDUSTRY_L;
-    main_types[CST_INDUSTRY_L_M1].graphic
-	    =load_graphic(CST_INDUSTRY_L_M1_G);
+    main_types[CST_INDUSTRY_L_M3].group = GROUP_INDUSTRY_L;
+    main_types[CST_INDUSTRY_L_M3].graphic = load_graphic(CST_INDUSTRY_L_M3_G);
 
-    main_types[CST_INDUSTRY_L_M2].group=GROUP_INDUSTRY_L;
-    main_types[CST_INDUSTRY_L_M2].graphic
-	    =load_graphic(CST_INDUSTRY_L_M2_G);
+    main_types[CST_INDUSTRY_L_M4].group = GROUP_INDUSTRY_L;
+    main_types[CST_INDUSTRY_L_M4].graphic = load_graphic(CST_INDUSTRY_L_M4_G);
 
-    main_types[CST_INDUSTRY_L_M3].group=GROUP_INDUSTRY_L;
-    main_types[CST_INDUSTRY_L_M3].graphic
-	    =load_graphic(CST_INDUSTRY_L_M3_G);
+    main_types[CST_INDUSTRY_L_H1].group = GROUP_INDUSTRY_L;
+    main_types[CST_INDUSTRY_L_H1].graphic = load_graphic(CST_INDUSTRY_L_H1_G);
 
-    main_types[CST_INDUSTRY_L_M4].group=GROUP_INDUSTRY_L;
-    main_types[CST_INDUSTRY_L_M4].graphic
-	    =load_graphic(CST_INDUSTRY_L_M4_G);
+    main_types[CST_INDUSTRY_L_H2].group = GROUP_INDUSTRY_L;
+    main_types[CST_INDUSTRY_L_H2].graphic = load_graphic(CST_INDUSTRY_L_H2_G);
 
+    main_types[CST_INDUSTRY_L_H3].group = GROUP_INDUSTRY_L;
+    main_types[CST_INDUSTRY_L_H3].graphic = load_graphic(CST_INDUSTRY_L_H3_G);
 
-    main_types[CST_INDUSTRY_L_H1].group=GROUP_INDUSTRY_L;
-    main_types[CST_INDUSTRY_L_H1].graphic
-	    =load_graphic(CST_INDUSTRY_L_H1_G);
+    main_types[CST_INDUSTRY_L_H4].group = GROUP_INDUSTRY_L;
+    main_types[CST_INDUSTRY_L_H4].graphic = load_graphic(CST_INDUSTRY_L_H4_G);
 
-    main_types[CST_INDUSTRY_L_H2].group=GROUP_INDUSTRY_L;
-    main_types[CST_INDUSTRY_L_H2].graphic
-	    =load_graphic(CST_INDUSTRY_L_H2_G);
+    main_types[CST_COMMUNE_1].group = GROUP_COMMUNE;
+    main_types[CST_COMMUNE_1].graphic = load_graphic(CST_COMMUNE_1_G);
 
-    main_types[CST_INDUSTRY_L_H3].group=GROUP_INDUSTRY_L;
-    main_types[CST_INDUSTRY_L_H3].graphic
-	    =load_graphic(CST_INDUSTRY_L_H3_G);
+    main_types[CST_COMMUNE_2].group = GROUP_COMMUNE;
+    main_types[CST_COMMUNE_2].graphic = load_graphic(CST_COMMUNE_2_G);
 
-    main_types[CST_INDUSTRY_L_H4].group=GROUP_INDUSTRY_L;
-    main_types[CST_INDUSTRY_L_H4].graphic
-	    =load_graphic(CST_INDUSTRY_L_H4_G);
+    main_types[CST_COMMUNE_3].group = GROUP_COMMUNE;
+    main_types[CST_COMMUNE_3].graphic = load_graphic(CST_COMMUNE_3_G);
 
-    main_types[CST_COMMUNE_1].group=GROUP_COMMUNE;
-    main_types[CST_COMMUNE_1].graphic=load_graphic(CST_COMMUNE_1_G);
+    main_types[CST_COMMUNE_4].group = GROUP_COMMUNE;
+    main_types[CST_COMMUNE_4].graphic = load_graphic(CST_COMMUNE_4_G);
 
-    main_types[CST_COMMUNE_2].group=GROUP_COMMUNE;
-    main_types[CST_COMMUNE_2].graphic=load_graphic(CST_COMMUNE_2_G);
+    main_types[CST_COMMUNE_5].group = GROUP_COMMUNE;
+    main_types[CST_COMMUNE_5].graphic = load_graphic(CST_COMMUNE_5_G);
 
-    main_types[CST_COMMUNE_3].group=GROUP_COMMUNE;
-    main_types[CST_COMMUNE_3].graphic=load_graphic(CST_COMMUNE_3_G);
+    main_types[CST_COMMUNE_6].group = GROUP_COMMUNE;
+    main_types[CST_COMMUNE_6].graphic = load_graphic(CST_COMMUNE_6_G);
 
-    main_types[CST_COMMUNE_4].group=GROUP_COMMUNE;
-    main_types[CST_COMMUNE_4].graphic=load_graphic(CST_COMMUNE_4_G);
+    main_types[CST_COMMUNE_7].group = GROUP_COMMUNE;
+    main_types[CST_COMMUNE_7].graphic = load_graphic(CST_COMMUNE_7_G);
 
-    main_types[CST_COMMUNE_5].group=GROUP_COMMUNE;
-    main_types[CST_COMMUNE_5].graphic=load_graphic(CST_COMMUNE_5_G);
+    main_types[CST_COMMUNE_8].group = GROUP_COMMUNE;
+    main_types[CST_COMMUNE_8].graphic = load_graphic(CST_COMMUNE_8_G);
 
-    main_types[CST_COMMUNE_6].group=GROUP_COMMUNE;
-    main_types[CST_COMMUNE_6].graphic=load_graphic(CST_COMMUNE_6_G);
+    main_types[CST_COMMUNE_9].group = GROUP_COMMUNE;
+    main_types[CST_COMMUNE_9].graphic = load_graphic(CST_COMMUNE_9_G);
 
-    main_types[CST_COMMUNE_7].group=GROUP_COMMUNE;
-    main_types[CST_COMMUNE_7].graphic=load_graphic(CST_COMMUNE_7_G);
+    main_types[CST_COMMUNE_10].group = GROUP_COMMUNE;
+    main_types[CST_COMMUNE_10].graphic = load_graphic(CST_COMMUNE_10_G);
 
-    main_types[CST_COMMUNE_8].group=GROUP_COMMUNE;
-    main_types[CST_COMMUNE_8].graphic=load_graphic(CST_COMMUNE_8_G);
+    main_types[CST_COMMUNE_11].group = GROUP_COMMUNE;
+    main_types[CST_COMMUNE_11].graphic = load_graphic(CST_COMMUNE_11_G);
 
-    main_types[CST_COMMUNE_9].group=GROUP_COMMUNE;
-    main_types[CST_COMMUNE_9].graphic=load_graphic(CST_COMMUNE_9_G);
+    main_types[CST_COMMUNE_12].group = GROUP_COMMUNE;
+    main_types[CST_COMMUNE_12].graphic = load_graphic(CST_COMMUNE_12_G);
 
-    main_types[CST_COMMUNE_10].group=GROUP_COMMUNE;
-    main_types[CST_COMMUNE_10].graphic=load_graphic(CST_COMMUNE_10_G);
+    main_types[CST_COMMUNE_13].group = GROUP_COMMUNE;
+    main_types[CST_COMMUNE_13].graphic = load_graphic(CST_COMMUNE_13_G);
 
-    main_types[CST_COMMUNE_11].group=GROUP_COMMUNE;
-    main_types[CST_COMMUNE_11].graphic=load_graphic(CST_COMMUNE_11_G);
+    main_types[CST_COMMUNE_14].group = GROUP_COMMUNE;
+    main_types[CST_COMMUNE_14].graphic = load_graphic(CST_COMMUNE_14_G);
 
-    main_types[CST_COMMUNE_12].group=GROUP_COMMUNE;
-    main_types[CST_COMMUNE_12].graphic=load_graphic(CST_COMMUNE_12_G);
+    main_types[CST_UNIVERSITY].group = GROUP_UNIVERSITY;
+    main_types[CST_UNIVERSITY].graphic = load_graphic(CST_UNIVERSITY_G);
 
-    main_types[CST_COMMUNE_13].group=GROUP_COMMUNE;
-    main_types[CST_COMMUNE_13].graphic=load_graphic(CST_COMMUNE_13_G);
+    main_types[CST_OREMINE_1].group = GROUP_OREMINE;
+    main_types[CST_OREMINE_1].graphic = load_graphic(CST_OREMINE_1_G);
 
-    main_types[CST_COMMUNE_14].group=GROUP_COMMUNE;
-    main_types[CST_COMMUNE_14].graphic=load_graphic(CST_COMMUNE_14_G);
+    main_types[CST_OREMINE_2].group = GROUP_OREMINE;
+    main_types[CST_OREMINE_2].graphic = load_graphic(CST_OREMINE_2_G);
 
-    main_types[CST_UNIVERSITY].group=GROUP_UNIVERSITY;
-    main_types[CST_UNIVERSITY].graphic=load_graphic(CST_UNIVERSITY_G);
+    main_types[CST_OREMINE_3].group = GROUP_OREMINE;
+    main_types[CST_OREMINE_3].graphic = load_graphic(CST_OREMINE_3_G);
 
-    main_types[CST_OREMINE_1].group=GROUP_OREMINE;
-    main_types[CST_OREMINE_1].graphic=load_graphic(CST_OREMINE_1_G);
+    main_types[CST_OREMINE_4].group = GROUP_OREMINE;
+    main_types[CST_OREMINE_4].graphic = load_graphic(CST_OREMINE_4_G);
 
-    main_types[CST_OREMINE_2].group=GROUP_OREMINE;
-    main_types[CST_OREMINE_2].graphic=load_graphic(CST_OREMINE_2_G);
+    main_types[CST_OREMINE_5].group = GROUP_OREMINE;
+    main_types[CST_OREMINE_5].graphic = load_graphic(CST_OREMINE_5_G);
 
-    main_types[CST_OREMINE_3].group=GROUP_OREMINE;
-    main_types[CST_OREMINE_3].graphic=load_graphic(CST_OREMINE_3_G);
+    main_types[CST_OREMINE_6].group = GROUP_OREMINE;
+    main_types[CST_OREMINE_6].graphic = load_graphic(CST_OREMINE_6_G);
 
-    main_types[CST_OREMINE_4].group=GROUP_OREMINE;
-    main_types[CST_OREMINE_4].graphic=load_graphic(CST_OREMINE_4_G);
+    main_types[CST_OREMINE_7].group = GROUP_OREMINE;
+    main_types[CST_OREMINE_7].graphic = load_graphic(CST_OREMINE_7_G);
 
-    main_types[CST_OREMINE_5].group=GROUP_OREMINE;
-    main_types[CST_OREMINE_5].graphic=load_graphic(CST_OREMINE_5_G);
+    main_types[CST_OREMINE_8].group = GROUP_OREMINE;
+    main_types[CST_OREMINE_8].graphic = load_graphic(CST_OREMINE_8_G);
 
-    main_types[CST_OREMINE_6].group=GROUP_OREMINE;
-    main_types[CST_OREMINE_6].graphic=load_graphic(CST_OREMINE_6_G);
+    main_types[CST_TIP_0].group = GROUP_TIP;
+    main_types[CST_TIP_0].graphic = load_graphic(CST_TIP_0_G);
 
-    main_types[CST_OREMINE_7].group=GROUP_OREMINE;
-    main_types[CST_OREMINE_7].graphic=load_graphic(CST_OREMINE_7_G);
+    main_types[CST_TIP_1].group = GROUP_TIP;
+    main_types[CST_TIP_1].graphic = load_graphic(CST_TIP_1_G);
 
-    main_types[CST_OREMINE_8].group=GROUP_OREMINE;
-    main_types[CST_OREMINE_8].graphic=load_graphic(CST_OREMINE_8_G);
+    main_types[CST_TIP_2].group = GROUP_TIP;
+    main_types[CST_TIP_2].graphic = load_graphic(CST_TIP_2_G);
 
-    main_types[CST_TIP_0].group=GROUP_TIP;
-    main_types[CST_TIP_0].graphic=load_graphic(CST_TIP_0_G);
+    main_types[CST_TIP_3].group = GROUP_TIP;
+    main_types[CST_TIP_3].graphic = load_graphic(CST_TIP_3_G);
 
-    main_types[CST_TIP_1].group=GROUP_TIP;
-    main_types[CST_TIP_1].graphic=load_graphic(CST_TIP_1_G);
+    main_types[CST_TIP_4].group = GROUP_TIP;
+    main_types[CST_TIP_4].graphic = load_graphic(CST_TIP_4_G);
 
-    main_types[CST_TIP_2].group=GROUP_TIP;
-    main_types[CST_TIP_2].graphic=load_graphic(CST_TIP_2_G);
+    main_types[CST_TIP_5].group = GROUP_TIP;
+    main_types[CST_TIP_5].graphic = load_graphic(CST_TIP_5_G);
 
-    main_types[CST_TIP_3].group=GROUP_TIP;
-    main_types[CST_TIP_3].graphic=load_graphic(CST_TIP_3_G);
+    main_types[CST_TIP_6].group = GROUP_TIP;
+    main_types[CST_TIP_6].graphic = load_graphic(CST_TIP_6_G);
 
-    main_types[CST_TIP_4].group=GROUP_TIP;
-    main_types[CST_TIP_4].graphic=load_graphic(CST_TIP_4_G);
+    main_types[CST_TIP_7].group = GROUP_TIP;
+    main_types[CST_TIP_7].graphic = load_graphic(CST_TIP_7_G);
 
-    main_types[CST_TIP_5].group=GROUP_TIP;
-    main_types[CST_TIP_5].graphic=load_graphic(CST_TIP_5_G);
+    main_types[CST_TIP_8].group = GROUP_TIP;
+    main_types[CST_TIP_8].graphic = load_graphic(CST_TIP_8_G);
 
-    main_types[CST_TIP_6].group=GROUP_TIP;
-    main_types[CST_TIP_6].graphic=load_graphic(CST_TIP_6_G);
+    main_types[CST_EX_PORT].group = GROUP_PORT;
+    main_types[CST_EX_PORT].graphic = load_graphic(CST_EX_PORT_G);
 
-    main_types[CST_TIP_7].group=GROUP_TIP;
-    main_types[CST_TIP_7].graphic=load_graphic(CST_TIP_7_G);
+    main_types[CST_INDUSTRY_H_C].group = GROUP_INDUSTRY_H;
+    main_types[CST_INDUSTRY_H_C].graphic = load_graphic(CST_INDUSTRY_H_C_G);
 
-    main_types[CST_TIP_8].group=GROUP_TIP;
-    main_types[CST_TIP_8].graphic=load_graphic(CST_TIP_8_G);
+    main_types[CST_INDUSTRY_H_L1].group = GROUP_INDUSTRY_H;
+    main_types[CST_INDUSTRY_H_L1].graphic = load_graphic(CST_INDUSTRY_H_L1_G);
 
-    main_types[CST_EX_PORT].group=GROUP_PORT;
-    main_types[CST_EX_PORT].graphic=load_graphic(CST_EX_PORT_G);
+    main_types[CST_INDUSTRY_H_L2].group = GROUP_INDUSTRY_H;
+    main_types[CST_INDUSTRY_H_L2].graphic = load_graphic(CST_INDUSTRY_H_L2_G);
 
-    main_types[CST_INDUSTRY_H_C].group=GROUP_INDUSTRY_H;
-    main_types[CST_INDUSTRY_H_C].graphic
-	    =load_graphic(CST_INDUSTRY_H_C_G);
+    main_types[CST_INDUSTRY_H_L3].group = GROUP_INDUSTRY_H;
+    main_types[CST_INDUSTRY_H_L3].graphic = load_graphic(CST_INDUSTRY_H_L3_G);
 
-    main_types[CST_INDUSTRY_H_L1].group=GROUP_INDUSTRY_H;
-    main_types[CST_INDUSTRY_H_L1].graphic
-	    =load_graphic(CST_INDUSTRY_H_L1_G);
+    main_types[CST_INDUSTRY_H_L4].group = GROUP_INDUSTRY_H;
+    main_types[CST_INDUSTRY_H_L4].graphic = load_graphic(CST_INDUSTRY_H_L4_G);
 
-    main_types[CST_INDUSTRY_H_L2].group=GROUP_INDUSTRY_H;
-    main_types[CST_INDUSTRY_H_L2].graphic
-	    =load_graphic(CST_INDUSTRY_H_L2_G);
+    main_types[CST_INDUSTRY_H_L5].group = GROUP_INDUSTRY_H;
+    main_types[CST_INDUSTRY_H_L5].graphic = load_graphic(CST_INDUSTRY_H_L5_G);
 
-    main_types[CST_INDUSTRY_H_L3].group=GROUP_INDUSTRY_H;
-    main_types[CST_INDUSTRY_H_L3].graphic
-	    =load_graphic(CST_INDUSTRY_H_L3_G);
+    main_types[CST_INDUSTRY_H_L6].group = GROUP_INDUSTRY_H;
+    main_types[CST_INDUSTRY_H_L6].graphic = load_graphic(CST_INDUSTRY_H_L6_G);
 
-    main_types[CST_INDUSTRY_H_L4].group=GROUP_INDUSTRY_H;
-    main_types[CST_INDUSTRY_H_L4].graphic
-	    =load_graphic(CST_INDUSTRY_H_L4_G);
+    main_types[CST_INDUSTRY_H_L7].group = GROUP_INDUSTRY_H;
+    main_types[CST_INDUSTRY_H_L7].graphic = load_graphic(CST_INDUSTRY_H_L7_G);
 
-    main_types[CST_INDUSTRY_H_L5].group=GROUP_INDUSTRY_H;
-    main_types[CST_INDUSTRY_H_L5].graphic
-	    =load_graphic(CST_INDUSTRY_H_L5_G);
+    main_types[CST_INDUSTRY_H_L8].group = GROUP_INDUSTRY_H;
+    main_types[CST_INDUSTRY_H_L8].graphic = load_graphic(CST_INDUSTRY_H_L8_G);
 
-    main_types[CST_INDUSTRY_H_L6].group=GROUP_INDUSTRY_H;
-    main_types[CST_INDUSTRY_H_L6].graphic
-	    =load_graphic(CST_INDUSTRY_H_L6_G);
+    main_types[CST_INDUSTRY_H_M1].group = GROUP_INDUSTRY_H;
+    main_types[CST_INDUSTRY_H_M1].graphic = load_graphic(CST_INDUSTRY_H_M1_G);
 
-    main_types[CST_INDUSTRY_H_L7].group=GROUP_INDUSTRY_H;
-    main_types[CST_INDUSTRY_H_L7].graphic
-	    =load_graphic(CST_INDUSTRY_H_L7_G);
+    main_types[CST_INDUSTRY_H_M2].group = GROUP_INDUSTRY_H;
+    main_types[CST_INDUSTRY_H_M2].graphic = load_graphic(CST_INDUSTRY_H_M2_G);
 
-    main_types[CST_INDUSTRY_H_L8].group=GROUP_INDUSTRY_H;
-    main_types[CST_INDUSTRY_H_L8].graphic
-	    =load_graphic(CST_INDUSTRY_H_L8_G);
+    main_types[CST_INDUSTRY_H_M3].group = GROUP_INDUSTRY_H;
+    main_types[CST_INDUSTRY_H_M3].graphic = load_graphic(CST_INDUSTRY_H_M3_G);
 
+    main_types[CST_INDUSTRY_H_M4].group = GROUP_INDUSTRY_H;
+    main_types[CST_INDUSTRY_H_M4].graphic = load_graphic(CST_INDUSTRY_H_M4_G);
 
-    main_types[CST_INDUSTRY_H_M1].group=GROUP_INDUSTRY_H;
-    main_types[CST_INDUSTRY_H_M1].graphic
-	    =load_graphic(CST_INDUSTRY_H_M1_G);
+    main_types[CST_INDUSTRY_H_M5].group = GROUP_INDUSTRY_H;
+    main_types[CST_INDUSTRY_H_M5].graphic = load_graphic(CST_INDUSTRY_H_M5_G);
 
-    main_types[CST_INDUSTRY_H_M2].group=GROUP_INDUSTRY_H;
-    main_types[CST_INDUSTRY_H_M2].graphic
-	    =load_graphic(CST_INDUSTRY_H_M2_G);
+    main_types[CST_INDUSTRY_H_M6].group = GROUP_INDUSTRY_H;
+    main_types[CST_INDUSTRY_H_M6].graphic = load_graphic(CST_INDUSTRY_H_M6_G);
 
-    main_types[CST_INDUSTRY_H_M3].group=GROUP_INDUSTRY_H;
-    main_types[CST_INDUSTRY_H_M3].graphic
-	    =load_graphic(CST_INDUSTRY_H_M3_G);
+    main_types[CST_INDUSTRY_H_M7].group = GROUP_INDUSTRY_H;
+    main_types[CST_INDUSTRY_H_M7].graphic = load_graphic(CST_INDUSTRY_H_M7_G);
 
-    main_types[CST_INDUSTRY_H_M4].group=GROUP_INDUSTRY_H;
-    main_types[CST_INDUSTRY_H_M4].graphic
-	    =load_graphic(CST_INDUSTRY_H_M4_G);
+    main_types[CST_INDUSTRY_H_M8].group = GROUP_INDUSTRY_H;
+    main_types[CST_INDUSTRY_H_M8].graphic = load_graphic(CST_INDUSTRY_H_M8_G);
 
-    main_types[CST_INDUSTRY_H_M5].group=GROUP_INDUSTRY_H;
-    main_types[CST_INDUSTRY_H_M5].graphic
-	    =load_graphic(CST_INDUSTRY_H_M5_G);
+    main_types[CST_INDUSTRY_H_H1].group = GROUP_INDUSTRY_H;
+    main_types[CST_INDUSTRY_H_H1].graphic = load_graphic(CST_INDUSTRY_H_H1_G);
 
-    main_types[CST_INDUSTRY_H_M6].group=GROUP_INDUSTRY_H;
-    main_types[CST_INDUSTRY_H_M6].graphic
-	    =load_graphic(CST_INDUSTRY_H_M6_G);
+    main_types[CST_INDUSTRY_H_H2].group = GROUP_INDUSTRY_H;
+    main_types[CST_INDUSTRY_H_H2].graphic = load_graphic(CST_INDUSTRY_H_H2_G);
 
-    main_types[CST_INDUSTRY_H_M7].group=GROUP_INDUSTRY_H;
-    main_types[CST_INDUSTRY_H_M7].graphic
-	    =load_graphic(CST_INDUSTRY_H_M7_G);
+    main_types[CST_INDUSTRY_H_H3].group = GROUP_INDUSTRY_H;
+    main_types[CST_INDUSTRY_H_H3].graphic = load_graphic(CST_INDUSTRY_H_H3_G);
 
-    main_types[CST_INDUSTRY_H_M8].group=GROUP_INDUSTRY_H;
-    main_types[CST_INDUSTRY_H_M8].graphic
-	    =load_graphic(CST_INDUSTRY_H_M8_G);
+    main_types[CST_INDUSTRY_H_H4].group = GROUP_INDUSTRY_H;
+    main_types[CST_INDUSTRY_H_H4].graphic = load_graphic(CST_INDUSTRY_H_H4_G);
 
-    main_types[CST_INDUSTRY_H_H1].group=GROUP_INDUSTRY_H;
-    main_types[CST_INDUSTRY_H_H1].graphic
-	    =load_graphic(CST_INDUSTRY_H_H1_G);
+    main_types[CST_INDUSTRY_H_H5].group = GROUP_INDUSTRY_H;
+    main_types[CST_INDUSTRY_H_H5].graphic = load_graphic(CST_INDUSTRY_H_H5_G);
 
-    main_types[CST_INDUSTRY_H_H2].group=GROUP_INDUSTRY_H;
-    main_types[CST_INDUSTRY_H_H2].graphic
-	    =load_graphic(CST_INDUSTRY_H_H2_G);
+    main_types[CST_INDUSTRY_H_H6].group = GROUP_INDUSTRY_H;
+    main_types[CST_INDUSTRY_H_H6].graphic = load_graphic(CST_INDUSTRY_H_H6_G);
 
-    main_types[CST_INDUSTRY_H_H3].group=GROUP_INDUSTRY_H;
-    main_types[CST_INDUSTRY_H_H3].graphic
-	    =load_graphic(CST_INDUSTRY_H_H3_G);
+    main_types[CST_INDUSTRY_H_H7].group = GROUP_INDUSTRY_H;
+    main_types[CST_INDUSTRY_H_H7].graphic = load_graphic(CST_INDUSTRY_H_H7_G);
 
-    main_types[CST_INDUSTRY_H_H4].group=GROUP_INDUSTRY_H;
-    main_types[CST_INDUSTRY_H_H4].graphic
-	    =load_graphic(CST_INDUSTRY_H_H4_G);
+    main_types[CST_INDUSTRY_H_H8].group = GROUP_INDUSTRY_H;
+    main_types[CST_INDUSTRY_H_H8].graphic = load_graphic(CST_INDUSTRY_H_H8_G);
 
-    main_types[CST_INDUSTRY_H_H5].group=GROUP_INDUSTRY_H;
-    main_types[CST_INDUSTRY_H_H5].graphic
-	    =load_graphic(CST_INDUSTRY_H_H5_G);
+    main_types[CST_PARKLAND_PLANE].group = GROUP_PARKLAND;
+    main_types[CST_PARKLAND_PLANE].graphic = load_graphic(CST_PARKLAND_PLANE_G);
 
-    main_types[CST_INDUSTRY_H_H6].group=GROUP_INDUSTRY_H;
-    main_types[CST_INDUSTRY_H_H6].graphic
-	    =load_graphic(CST_INDUSTRY_H_H6_G);
+    prog_box(&quot;&quot;, 50);
 
-    main_types[CST_INDUSTRY_H_H7].group=GROUP_INDUSTRY_H;
-    main_types[CST_INDUSTRY_H_H7].graphic
-	    =load_graphic(CST_INDUSTRY_H_H7_G);
+    main_types[CST_PARKLAND_LAKE].group = GROUP_PARKLAND;
+    main_types[CST_PARKLAND_LAKE].graphic = load_graphic(CST_PARKLAND_LAKE_G);
 
-    main_types[CST_INDUSTRY_H_H8].group=GROUP_INDUSTRY_H;
-    main_types[CST_INDUSTRY_H_H8].graphic
-	    =load_graphic(CST_INDUSTRY_H_H8_G);
+    main_types[CST_RECYCLE].group = GROUP_RECYCLE;
+    main_types[CST_RECYCLE].graphic = load_graphic(CST_RECYCLE_G);
 
-    main_types[CST_PARKLAND_PLANE].group=GROUP_PARKLAND;
-    main_types[CST_PARKLAND_PLANE].graphic
-	    =load_graphic(CST_PARKLAND_PLANE_G);
+    main_types[CST_WATER].group = GROUP_WATER;
+    main_types[CST_WATER].graphic = load_graphic(CST_WATER_G);
 
-    prog_box(&quot;&quot;,50);
+    main_types[CST_WATER_D].group = GROUP_WATER;
+    main_types[CST_WATER_D].graphic = load_graphic(CST_WATER_D_G);
 
-    main_types[CST_PARKLAND_LAKE].group=GROUP_PARKLAND;
-    main_types[CST_PARKLAND_LAKE].graphic
-	    =load_graphic(CST_PARKLAND_LAKE_G);
+    main_types[CST_WATER_R].group = GROUP_WATER;
+    main_types[CST_WATER_R].graphic = load_graphic(CST_WATER_R_G);
 
-    main_types[CST_RECYCLE].group=GROUP_RECYCLE;
-    main_types[CST_RECYCLE].graphic=load_graphic(CST_RECYCLE_G);
+    main_types[CST_WATER_U].group = GROUP_WATER;
+    main_types[CST_WATER_U].graphic = load_graphic(CST_WATER_U_G);
 
-    main_types[CST_WATER].group=GROUP_WATER;
-    main_types[CST_WATER].graphic=load_graphic(CST_WATER_G);
+    main_types[CST_WATER_L].group = GROUP_WATER;
+    main_types[CST_WATER_L].graphic = load_graphic(CST_WATER_L_G);
 
-    main_types[CST_WATER_D].group=GROUP_WATER;
-    main_types[CST_WATER_D].graphic=load_graphic(CST_WATER_D_G);
+    main_types[CST_WATER_LR].group = GROUP_WATER;
+    main_types[CST_WATER_LR].graphic = load_graphic(CST_WATER_LR_G);
 
-    main_types[CST_WATER_R].group=GROUP_WATER;
-    main_types[CST_WATER_R].graphic=load_graphic(CST_WATER_R_G);
+    main_types[CST_WATER_UD].group = GROUP_WATER;
+    main_types[CST_WATER_UD].graphic = load_graphic(CST_WATER_UD_G);
 
-    main_types[CST_WATER_U].group=GROUP_WATER;
-    main_types[CST_WATER_U].graphic=load_graphic(CST_WATER_U_G);
+    main_types[CST_WATER_LD].group = GROUP_WATER;
+    main_types[CST_WATER_LD].graphic = load_graphic(CST_WATER_LD_G);
 
-    main_types[CST_WATER_L].group=GROUP_WATER;
-    main_types[CST_WATER_L].graphic=load_graphic(CST_WATER_L_G);
+    main_types[CST_WATER_RD].group = GROUP_WATER;
+    main_types[CST_WATER_RD].graphic = load_graphic(CST_WATER_RD_G);
 
-    main_types[CST_WATER_LR].group=GROUP_WATER;
-    main_types[CST_WATER_LR].graphic=load_graphic(CST_WATER_LR_G);
+    main_types[CST_WATER_LU].group = GROUP_WATER;
+    main_types[CST_WATER_LU].graphic = load_graphic(CST_WATER_LU_G);
 
-    main_types[CST_WATER_UD].group=GROUP_WATER;
-    main_types[CST_WATER_UD].graphic=load_graphic(CST_WATER_UD_G);
+    main_types[CST_WATER_UR].group = GROUP_WATER;
+    main_types[CST_WATER_UR].graphic = load_graphic(CST_WATER_UR_G);
 
-    main_types[CST_WATER_LD].group=GROUP_WATER;
-    main_types[CST_WATER_LD].graphic=load_graphic(CST_WATER_LD_G);
+    main_types[CST_WATER_LUD].group = GROUP_WATER;
+    main_types[CST_WATER_LUD].graphic = load_graphic(CST_WATER_LUD_G);
 
-    main_types[CST_WATER_RD].group=GROUP_WATER;
-    main_types[CST_WATER_RD].graphic=load_graphic(CST_WATER_RD_G);
+    main_types[CST_WATER_LRD].group = GROUP_WATER;
+    main_types[CST_WATER_LRD].graphic = load_graphic(CST_WATER_LRD_G);
 
-    main_types[CST_WATER_LU].group=GROUP_WATER;
-    main_types[CST_WATER_LU].graphic=load_graphic(CST_WATER_LU_G);
+    main_types[CST_WATER_LUR].group = GROUP_WATER;
+    main_types[CST_WATER_LUR].graphic = load_graphic(CST_WATER_LUR_G);
 
-    main_types[CST_WATER_UR].group=GROUP_WATER;
-    main_types[CST_WATER_UR].graphic=load_graphic(CST_WATER_UR_G);
+    main_types[CST_WATER_URD].group = GROUP_WATER;
+    main_types[CST_WATER_URD].graphic = load_graphic(CST_WATER_URD_G);
 
-    main_types[CST_WATER_LUD].group=GROUP_WATER;
-    main_types[CST_WATER_LUD].graphic=load_graphic(CST_WATER_LUD_G);
+    main_types[CST_WATER_LURD].group = GROUP_WATER;
+    main_types[CST_WATER_LURD].graphic = load_graphic(CST_WATER_LURD_G);
 
-    main_types[CST_WATER_LRD].group=GROUP_WATER;
-    main_types[CST_WATER_LRD].graphic=load_graphic(CST_WATER_LRD_G);
+    main_types[CST_WATERWELL].group = GROUP_WATERWELL;
+    main_types[CST_WATERWELL].graphic = load_graphic(CST_WATERWELL_G);
 
-    main_types[CST_WATER_LUR].group=GROUP_WATER;
-    main_types[CST_WATER_LUR].graphic=load_graphic(CST_WATER_LUR_G);
+    main_types[CST_HEALTH].group = GROUP_HEALTH;
+    main_types[CST_HEALTH].graphic = load_graphic(CST_HEALTH_G);
 
-    main_types[CST_WATER_URD].group=GROUP_WATER;
-    main_types[CST_WATER_URD].graphic=load_graphic(CST_WATER_URD_G);
+    main_types[CST_ROCKET_1].group = GROUP_ROCKET;
+    main_types[CST_ROCKET_1].graphic = load_graphic(CST_ROCKET_1_G);
 
-    main_types[CST_WATER_LURD].group=GROUP_WATER;
-    main_types[CST_WATER_LURD].graphic=load_graphic(CST_WATER_LURD_G);
+    main_types[CST_ROCKET_2].group = GROUP_ROCKET;
+    main_types[CST_ROCKET_2].graphic = load_graphic(CST_ROCKET_2_G);
 
-    main_types[CST_WATERWELL].group=GROUP_WATERWELL;
-    main_types[CST_WATERWELL].graphic=load_graphic(CST_WATERWELL_G);
+    main_types[CST_ROCKET_3].group = GROUP_ROCKET;
+    main_types[CST_ROCKET_3].graphic = load_graphic(CST_ROCKET_3_G);
 
-    main_types[CST_HEALTH].group=GROUP_HEALTH;
-    main_types[CST_HEALTH].graphic=load_graphic(CST_HEALTH_G);
+    main_types[CST_ROCKET_4].group = GROUP_ROCKET;
+    main_types[CST_ROCKET_4].graphic = load_graphic(CST_ROCKET_4_G);
 
-    main_types[CST_ROCKET_1].group=GROUP_ROCKET;
-    main_types[CST_ROCKET_1].graphic=load_graphic(CST_ROCKET_1_G);
+    prog_box(&quot;&quot;, 60);
 
-    main_types[CST_ROCKET_2].group=GROUP_ROCKET;
-    main_types[CST_ROCKET_2].graphic=load_graphic(CST_ROCKET_2_G);
+    main_types[CST_ROCKET_5].group = GROUP_ROCKET;
+    main_types[CST_ROCKET_5].graphic = load_graphic(CST_ROCKET_5_G);
 
-    main_types[CST_ROCKET_3].group=GROUP_ROCKET;
-    main_types[CST_ROCKET_3].graphic=load_graphic(CST_ROCKET_3_G);
+    main_types[CST_ROCKET_6].group = GROUP_ROCKET;
+    main_types[CST_ROCKET_6].graphic = load_graphic(CST_ROCKET_6_G);
 
-    main_types[CST_ROCKET_4].group=GROUP_ROCKET;
-    main_types[CST_ROCKET_4].graphic=load_graphic(CST_ROCKET_4_G);
+    main_types[CST_ROCKET_7].group = GROUP_ROCKET;
+    main_types[CST_ROCKET_7].graphic = load_graphic(CST_ROCKET_7_G);
 
-    prog_box(&quot;&quot;,60);
+    main_types[CST_ROCKET_FLOWN].group = GROUP_ROCKET;
+    main_types[CST_ROCKET_FLOWN].graphic = load_graphic(CST_ROCKET_FLOWN_G);
 
-    main_types[CST_ROCKET_5].group=GROUP_ROCKET;
-    main_types[CST_ROCKET_5].graphic=load_graphic(CST_ROCKET_5_G);
+    main_types[CST_BURNT].group = GROUP_BURNT;
+    main_types[CST_BURNT].graphic = load_graphic(CST_BURNT_G);
 
-    main_types[CST_ROCKET_6].group=GROUP_ROCKET;
-    main_types[CST_ROCKET_6].graphic=load_graphic(CST_ROCKET_6_G);
+    main_types[CST_WINDMILL_1_G].group = GROUP_WINDMILL;
+    main_types[CST_WINDMILL_1_G].graphic = load_graphic(CST_WINDMILL_1_G_G);
 
-    main_types[CST_ROCKET_7].group=GROUP_ROCKET;
-    main_types[CST_ROCKET_7].graphic=load_graphic(CST_ROCKET_7_G);
+    main_types[CST_WINDMILL_2_G].group = GROUP_WINDMILL;
+    main_types[CST_WINDMILL_2_G].graphic = load_graphic(CST_WINDMILL_2_G_G);
 
-    main_types[CST_ROCKET_FLOWN].group=GROUP_ROCKET;
-    main_types[CST_ROCKET_FLOWN].graphic
-	    =load_graphic(CST_ROCKET_FLOWN_G);
+    main_types[CST_WINDMILL_3_G].group = GROUP_WINDMILL;
+    main_types[CST_WINDMILL_3_G].graphic = load_graphic(CST_WINDMILL_3_G_G);
 
+    main_types[CST_WINDMILL_1_RG].group = GROUP_WINDMILL;
+    main_types[CST_WINDMILL_1_RG].graphic = load_graphic(CST_WINDMILL_1_RG_G);
 
-    main_types[CST_BURNT].group=GROUP_BURNT;
-    main_types[CST_BURNT].graphic=load_graphic(CST_BURNT_G);
+    main_types[CST_WINDMILL_2_RG].group = GROUP_WINDMILL;
+    main_types[CST_WINDMILL_2_RG].graphic = load_graphic(CST_WINDMILL_2_RG_G);
 
-    main_types[CST_WINDMILL_1_G].group=GROUP_WINDMILL;
-    main_types[CST_WINDMILL_1_G].graphic
-	    =load_graphic(CST_WINDMILL_1_G_G);
+    main_types[CST_WINDMILL_3_RG].group = GROUP_WINDMILL;
+    main_types[CST_WINDMILL_3_RG].graphic = load_graphic(CST_WINDMILL_3_RG_G);
 
-    main_types[CST_WINDMILL_2_G].group=GROUP_WINDMILL;
-    main_types[CST_WINDMILL_2_G].graphic
-	    =load_graphic(CST_WINDMILL_2_G_G);
+    main_types[CST_WINDMILL_1_R].group = GROUP_WINDMILL;
+    main_types[CST_WINDMILL_1_R].graphic = load_graphic(CST_WINDMILL_1_R_G);
 
-    main_types[CST_WINDMILL_3_G].group=GROUP_WINDMILL;
-    main_types[CST_WINDMILL_3_G].graphic
-	    =load_graphic(CST_WINDMILL_3_G_G);
+    main_types[CST_WINDMILL_2_R].group = GROUP_WINDMILL;
+    main_types[CST_WINDMILL_2_R].graphic = load_graphic(CST_WINDMILL_2_R_G);
 
-    main_types[CST_WINDMILL_1_RG].group=GROUP_WINDMILL;
-    main_types[CST_WINDMILL_1_RG].graphic
-	    =load_graphic(CST_WINDMILL_1_RG_G);
+    main_types[CST_WINDMILL_3_R].group = GROUP_WINDMILL;
+    main_types[CST_WINDMILL_3_R].graphic = load_graphic(CST_WINDMILL_3_R_G);
 
-    main_types[CST_WINDMILL_2_RG].group=GROUP_WINDMILL;
-    main_types[CST_WINDMILL_2_RG].graphic
-	    =load_graphic(CST_WINDMILL_2_RG_G);
+    main_types[CST_WINDMILL_1_W].group = GROUP_WINDMILL;
+    main_types[CST_WINDMILL_1_W].graphic = load_graphic(CST_WINDMILL_1_W_G);
 
-    main_types[CST_WINDMILL_3_RG].group=GROUP_WINDMILL;
-    main_types[CST_WINDMILL_3_RG].graphic
-	    =load_graphic(CST_WINDMILL_3_RG_G);
+    main_types[CST_WINDMILL_2_W].group = GROUP_WINDMILL;
+    main_types[CST_WINDMILL_2_W].graphic = load_graphic(CST_WINDMILL_2_W_G);
 
-    main_types[CST_WINDMILL_1_R].group=GROUP_WINDMILL;
-    main_types[CST_WINDMILL_1_R].graphic
-	    =load_graphic(CST_WINDMILL_1_R_G);
+    main_types[CST_WINDMILL_3_W].group = GROUP_WINDMILL;
+    main_types[CST_WINDMILL_3_W].graphic = load_graphic(CST_WINDMILL_3_W_G);
 
-    main_types[CST_WINDMILL_2_R].group=GROUP_WINDMILL;
-    main_types[CST_WINDMILL_2_R].graphic
-	    =load_graphic(CST_WINDMILL_2_R_G);
+    main_types[CST_MONUMENT_0].group = GROUP_MONUMENT;
+    main_types[CST_MONUMENT_0].graphic = load_graphic(CST_MONUMENT_0_G);
 
-    main_types[CST_WINDMILL_3_R].group=GROUP_WINDMILL;
-    main_types[CST_WINDMILL_3_R].graphic
-	    =load_graphic(CST_WINDMILL_3_R_G);
+    main_types[CST_MONUMENT_1].group = GROUP_MONUMENT;
+    main_types[CST_MONUMENT_1].graphic = load_graphic(CST_MONUMENT_1_G);
 
-    main_types[CST_WINDMILL_1_W].group=GROUP_WINDMILL;
-    main_types[CST_WINDMILL_1_W].graphic
-	    =load_graphic(CST_WINDMILL_1_W_G);
+    main_types[CST_MONUMENT_2].group = GROUP_MONUMENT;
+    main_types[CST_MONUMENT_2].graphic = load_graphic(CST_MONUMENT_2_G);
 
-    main_types[CST_WINDMILL_2_W].group=GROUP_WINDMILL;
-    main_types[CST_WINDMILL_2_W].graphic
-	    =load_graphic(CST_WINDMILL_2_W_G);
+    main_types[CST_MONUMENT_3].group = GROUP_MONUMENT;
+    main_types[CST_MONUMENT_3].graphic = load_graphic(CST_MONUMENT_3_G);
 
-    main_types[CST_WINDMILL_3_W].group=GROUP_WINDMILL;
-    main_types[CST_WINDMILL_3_W].graphic
-	    =load_graphic(CST_WINDMILL_3_W_G);
+    main_types[CST_MONUMENT_4].group = GROUP_MONUMENT;
+    main_types[CST_MONUMENT_4].graphic = load_graphic(CST_MONUMENT_4_G);
 
-    main_types[CST_MONUMENT_0].group=GROUP_MONUMENT;
-    main_types[CST_MONUMENT_0].graphic=load_graphic(CST_MONUMENT_0_G);
+    main_types[CST_MONUMENT_5].group = GROUP_MONUMENT;
+    main_types[CST_MONUMENT_5].graphic = load_graphic(CST_MONUMENT_5_G);
 
-    main_types[CST_MONUMENT_1].group=GROUP_MONUMENT;
-    main_types[CST_MONUMENT_1].graphic=load_graphic(CST_MONUMENT_1_G);
+    main_types[CST_SCHOOL].group = GROUP_SCHOOL;
+    main_types[CST_SCHOOL].graphic = load_graphic(CST_SCHOOL_G);
 
-    main_types[CST_MONUMENT_2].group=GROUP_MONUMENT;
-    main_types[CST_MONUMENT_2].graphic=load_graphic(CST_MONUMENT_2_G);
+    main_types[CST_BLACKSMITH_0].group = GROUP_BLACKSMITH;
+    main_types[CST_BLACKSMITH_0].graphic = load_graphic(CST_BLACKSMITH_0_G);
 
-    main_types[CST_MONUMENT_3].group=GROUP_MONUMENT;
-    main_types[CST_MONUMENT_3].graphic=load_graphic(CST_MONUMENT_3_G);
+    main_types[CST_BLACKSMITH_1].group = GROUP_BLACKSMITH;
+    main_types[CST_BLACKSMITH_1].graphic = load_graphic(CST_BLACKSMITH_1_G);
 
-    main_types[CST_MONUMENT_4].group=GROUP_MONUMENT;
-    main_types[CST_MONUMENT_4].graphic=load_graphic(CST_MONUMENT_4_G);
+    main_types[CST_BLACKSMITH_2].group = GROUP_BLACKSMITH;
+    main_types[CST_BLACKSMITH_2].graphic = load_graphic(CST_BLACKSMITH_2_G);
 
-    main_types[CST_MONUMENT_5].group=GROUP_MONUMENT;
-    main_types[CST_MONUMENT_5].graphic=load_graphic(CST_MONUMENT_5_G);
+    main_types[CST_BLACKSMITH_3].group = GROUP_BLACKSMITH;
+    main_types[CST_BLACKSMITH_3].graphic = load_graphic(CST_BLACKSMITH_3_G);
 
-    main_types[CST_SCHOOL].group=GROUP_SCHOOL;
-    main_types[CST_SCHOOL].graphic=load_graphic(CST_SCHOOL_G);
+    main_types[CST_BLACKSMITH_4].group = GROUP_BLACKSMITH;
+    main_types[CST_BLACKSMITH_4].graphic = load_graphic(CST_BLACKSMITH_4_G);
 
-    main_types[CST_BLACKSMITH_0].group=GROUP_BLACKSMITH;
-    main_types[CST_BLACKSMITH_0].graphic
-	    =load_graphic(CST_BLACKSMITH_0_G);
+    main_types[CST_BLACKSMITH_5].group = GROUP_BLACKSMITH;
+    main_types[CST_BLACKSMITH_5].graphic = load_graphic(CST_BLACKSMITH_5_G);
 
-    main_types[CST_BLACKSMITH_1].group=GROUP_BLACKSMITH;
-    main_types[CST_BLACKSMITH_1].graphic
-	    =load_graphic(CST_BLACKSMITH_1_G);
+    main_types[CST_BLACKSMITH_6].group = GROUP_BLACKSMITH;
+    main_types[CST_BLACKSMITH_6].graphic = load_graphic(CST_BLACKSMITH_6_G);
 
-    main_types[CST_BLACKSMITH_2].group=GROUP_BLACKSMITH;
-    main_types[CST_BLACKSMITH_2].graphic
-	    =load_graphic(CST_BLACKSMITH_2_G);
+    prog_box(&quot;&quot;, 75);
 
-    main_types[CST_BLACKSMITH_3].group=GROUP_BLACKSMITH;
-    main_types[CST_BLACKSMITH_3].graphic
-	    =load_graphic(CST_BLACKSMITH_3_G);
+    main_types[CST_MILL_0].group = GROUP_MILL;
+    main_types[CST_MILL_0].graphic = load_graphic(CST_MILL_0_G);
 
-    main_types[CST_BLACKSMITH_4].group=GROUP_BLACKSMITH;
-    main_types[CST_BLACKSMITH_4].graphic
-	    =load_graphic(CST_BLACKSMITH_4_G);
+    main_types[CST_MILL_1].group = GROUP_MILL;
+    main_types[CST_MILL_1].graphic = load_graphic(CST_MILL_1_G);
 
-    main_types[CST_BLACKSMITH_5].group=GROUP_BLACKSMITH;
-    main_types[CST_BLACKSMITH_5].graphic
-	    =load_graphic(CST_BLACKSMITH_5_G);
+    main_types[CST_MILL_2].group = GROUP_MILL;
+    main_types[CST_MILL_2].graphic = load_graphic(CST_MILL_2_G);
 
-    main_types[CST_BLACKSMITH_6].group=GROUP_BLACKSMITH;
-    main_types[CST_BLACKSMITH_6].graphic
-	    =load_graphic(CST_BLACKSMITH_6_G);
+    main_types[CST_MILL_3].group = GROUP_MILL;
+    main_types[CST_MILL_3].graphic = load_graphic(CST_MILL_3_G);
 
-    prog_box(&quot;&quot;,75);
+    main_types[CST_MILL_4].group = GROUP_MILL;
+    main_types[CST_MILL_4].graphic = load_graphic(CST_MILL_4_G);
 
-    main_types[CST_MILL_0].group=GROUP_MILL;
-    main_types[CST_MILL_0].graphic=load_graphic(CST_MILL_0_G);
+    main_types[CST_MILL_5].group = GROUP_MILL;
+    main_types[CST_MILL_5].graphic = load_graphic(CST_MILL_5_G);
 
-    main_types[CST_MILL_1].group=GROUP_MILL;
-    main_types[CST_MILL_1].graphic=load_graphic(CST_MILL_1_G);
+    main_types[CST_MILL_6].group = GROUP_MILL;
+    main_types[CST_MILL_6].graphic = load_graphic(CST_MILL_6_G);
 
-    main_types[CST_MILL_2].group=GROUP_MILL;
-    main_types[CST_MILL_2].graphic=load_graphic(CST_MILL_2_G);
+    main_types[CST_POTTERY_0].group = GROUP_POTTERY;
+    main_types[CST_POTTERY_0].graphic = load_graphic(CST_POTTERY_0_G);
 
-    main_types[CST_MILL_3].group=GROUP_MILL;
-    main_types[CST_MILL_3].graphic=load_graphic(CST_MILL_3_G);
+    main_types[CST_POTTERY_1].group = GROUP_POTTERY;
+    main_types[CST_POTTERY_1].graphic = load_graphic(CST_POTTERY_1_G);
 
-    main_types[CST_MILL_4].group=GROUP_MILL;
-    main_types[CST_MILL_4].graphic=load_graphic(CST_MILL_4_G);
+    main_types[CST_POTTERY_2].group = GROUP_POTTERY;
+    main_types[CST_POTTERY_2].graphic = load_graphic(CST_POTTERY_2_G);
 
-    main_types[CST_MILL_5].group=GROUP_MILL;
-    main_types[CST_MILL_5].graphic=load_graphic(CST_MILL_5_G);
+    main_types[CST_POTTERY_3].group = GROUP_POTTERY;
+    main_types[CST_POTTERY_3].graphic = load_graphic(CST_POTTERY_3_G);
 
-    main_types[CST_MILL_6].group=GROUP_MILL;
-    main_types[CST_MILL_6].graphic=load_graphic(CST_MILL_6_G);
+    main_types[CST_POTTERY_4].group = GROUP_POTTERY;
+    main_types[CST_POTTERY_4].graphic = load_graphic(CST_POTTERY_4_G);
 
-    main_types[CST_POTTERY_0].group=GROUP_POTTERY;
-    main_types[CST_POTTERY_0].graphic=load_graphic(CST_POTTERY_0_G);
+    main_types[CST_POTTERY_5].group = GROUP_POTTERY;
+    main_types[CST_POTTERY_5].graphic = load_graphic(CST_POTTERY_5_G);
 
-    main_types[CST_POTTERY_1].group=GROUP_POTTERY;
-    main_types[CST_POTTERY_1].graphic=load_graphic(CST_POTTERY_1_G);
+    main_types[CST_POTTERY_6].group = GROUP_POTTERY;
+    main_types[CST_POTTERY_6].graphic = load_graphic(CST_POTTERY_6_G);
 
-    main_types[CST_POTTERY_2].group=GROUP_POTTERY;
-    main_types[CST_POTTERY_2].graphic=load_graphic(CST_POTTERY_2_G);
+    main_types[CST_POTTERY_7].group = GROUP_POTTERY;
+    main_types[CST_POTTERY_7].graphic = load_graphic(CST_POTTERY_7_G);
 
-    main_types[CST_POTTERY_3].group=GROUP_POTTERY;
-    main_types[CST_POTTERY_3].graphic=load_graphic(CST_POTTERY_3_G);
+    main_types[CST_POTTERY_8].group = GROUP_POTTERY;
+    main_types[CST_POTTERY_8].graphic = load_graphic(CST_POTTERY_8_G);
 
-    main_types[CST_POTTERY_4].group=GROUP_POTTERY;
-    main_types[CST_POTTERY_4].graphic=load_graphic(CST_POTTERY_4_G);
+    main_types[CST_POTTERY_9].group = GROUP_POTTERY;
+    main_types[CST_POTTERY_9].graphic = load_graphic(CST_POTTERY_9_G);
 
-    main_types[CST_POTTERY_5].group=GROUP_POTTERY;
-    main_types[CST_POTTERY_5].graphic=load_graphic(CST_POTTERY_5_G);
+    main_types[CST_POTTERY_10].group = GROUP_POTTERY;
+    main_types[CST_POTTERY_10].graphic = load_graphic(CST_POTTERY_10_G);
 
-    main_types[CST_POTTERY_6].group=GROUP_POTTERY;
-    main_types[CST_POTTERY_6].graphic=load_graphic(CST_POTTERY_6_G);
+    main_types[CST_FIRESTATION_1].group = GROUP_FIRESTATION;
+    main_types[CST_FIRESTATION_1].graphic = load_graphic(CST_FIRESTATION_1_G);
 
-    main_types[CST_POTTERY_7].group=GROUP_POTTERY;
-    main_types[CST_POTTERY_7].graphic=load_graphic(CST_POTTERY_7_G);
+    main_types[CST_FIRESTATION_2].group = GROUP_FIRESTATION;
+    main_types[CST_FIRESTATION_2].graphic = load_graphic(CST_FIRESTATION_2_G);
 
-    main_types[CST_POTTERY_8].group=GROUP_POTTERY;
-    main_types[CST_POTTERY_8].graphic=load_graphic(CST_POTTERY_8_G);
+    main_types[CST_FIRESTATION_3].group = GROUP_FIRESTATION;
+    main_types[CST_FIRESTATION_3].graphic = load_graphic(CST_FIRESTATION_3_G);
 
-    main_types[CST_POTTERY_9].group=GROUP_POTTERY;
-    main_types[CST_POTTERY_9].graphic=load_graphic(CST_POTTERY_9_G);
+    main_types[CST_FIRESTATION_4].group = GROUP_FIRESTATION;
+    main_types[CST_FIRESTATION_4].graphic = load_graphic(CST_FIRESTATION_4_G);
 
-    main_types[CST_POTTERY_10].group=GROUP_POTTERY;
-    main_types[CST_POTTERY_10].graphic=load_graphic(CST_POTTERY_10_G);
+    main_types[CST_FIRESTATION_5].group = GROUP_FIRESTATION;
+    main_types[CST_FIRESTATION_5].graphic = load_graphic(CST_FIRESTATION_5_G);
 
-    main_types[CST_FIRESTATION_1].group=GROUP_FIRESTATION;
-    main_types[CST_FIRESTATION_1].graphic
-	    =load_graphic(CST_FIRESTATION_1_G);
+    main_types[CST_FIRESTATION_6].group = GROUP_FIRESTATION;
+    main_types[CST_FIRESTATION_6].graphic = load_graphic(CST_FIRESTATION_6_G);
 
-    main_types[CST_FIRESTATION_2].group=GROUP_FIRESTATION;
-    main_types[CST_FIRESTATION_2].graphic
-	    =load_graphic(CST_FIRESTATION_2_G);
+    main_types[CST_FIRESTATION_7].group = GROUP_FIRESTATION;
+    main_types[CST_FIRESTATION_7].graphic = load_graphic(CST_FIRESTATION_7_G);
 
-    main_types[CST_FIRESTATION_3].group=GROUP_FIRESTATION;
-    main_types[CST_FIRESTATION_3].graphic
-	    =load_graphic(CST_FIRESTATION_3_G);
+    main_types[CST_FIRESTATION_8].group = GROUP_FIRESTATION;
+    main_types[CST_FIRESTATION_8].graphic = load_graphic(CST_FIRESTATION_8_G);
 
-    main_types[CST_FIRESTATION_4].group=GROUP_FIRESTATION;
-    main_types[CST_FIRESTATION_4].graphic
-	    =load_graphic(CST_FIRESTATION_4_G);
+    main_types[CST_FIRESTATION_9].group = GROUP_FIRESTATION;
+    main_types[CST_FIRESTATION_9].graphic = load_graphic(CST_FIRESTATION_9_G);
 
-    main_types[CST_FIRESTATION_5].group=GROUP_FIRESTATION;
-    main_types[CST_FIRESTATION_5].graphic
-	    =load_graphic(CST_FIRESTATION_5_G);
+    main_types[CST_FIRESTATION_10].group = GROUP_FIRESTATION;
+    main_types[CST_FIRESTATION_10].graphic = load_graphic(CST_FIRESTATION_10_G);
 
-    main_types[CST_FIRESTATION_6].group=GROUP_FIRESTATION;
-    main_types[CST_FIRESTATION_6].graphic
-	    =load_graphic(CST_FIRESTATION_6_G);
+    main_types[CST_CRICKET_1].group = GROUP_CRICKET;
+    main_types[CST_CRICKET_1].graphic = load_graphic(CST_CRICKET_1_G);
 
-    main_types[CST_FIRESTATION_7].group=GROUP_FIRESTATION;
-    main_types[CST_FIRESTATION_7].graphic
-	    =load_graphic(CST_FIRESTATION_7_G);
+    main_types[CST_CRICKET_2].group = GROUP_CRICKET;
+    main_types[CST_CRICKET_2].graphic = load_graphic(CST_CRICKET_2_G);
 
-    main_types[CST_FIRESTATION_8].group=GROUP_FIRESTATION;
-    main_types[CST_FIRESTATION_8].graphic
-	    =load_graphic(CST_FIRESTATION_8_G);
+    main_types[CST_CRICKET_3].group = GROUP_CRICKET;
+    main_types[CST_CRICKET_3].graphic = load_graphic(CST_CRICKET_3_G);
 
-    main_types[CST_FIRESTATION_9].group=GROUP_FIRESTATION;
-    main_types[CST_FIRESTATION_9].graphic
-	    =load_graphic(CST_FIRESTATION_9_G);
+    main_types[CST_CRICKET_4].group = GROUP_CRICKET;
+    main_types[CST_CRICKET_4].graphic = load_graphic(CST_CRICKET_4_G);
 
-    main_types[CST_FIRESTATION_10].group=GROUP_FIRESTATION;
-    main_types[CST_FIRESTATION_10].graphic
-	    =load_graphic(CST_FIRESTATION_10_G);
+    prog_box(&quot;&quot;, 90);
 
-    main_types[CST_CRICKET_1].group=GROUP_CRICKET;
-    main_types[CST_CRICKET_1].graphic
-	    =load_graphic(CST_CRICKET_1_G);
+    main_types[CST_CRICKET_5].group = GROUP_CRICKET;
+    main_types[CST_CRICKET_5].graphic = load_graphic(CST_CRICKET_5_G);
 
-    main_types[CST_CRICKET_2].group=GROUP_CRICKET;
-    main_types[CST_CRICKET_2].graphic
-	    =load_graphic(CST_CRICKET_2_G);
+    main_types[CST_CRICKET_6].group = GROUP_CRICKET;
+    main_types[CST_CRICKET_6].graphic = load_graphic(CST_CRICKET_6_G);
 
-    main_types[CST_CRICKET_3].group=GROUP_CRICKET;
-    main_types[CST_CRICKET_3].graphic
-	    =load_graphic(CST_CRICKET_3_G);
+    main_types[CST_CRICKET_7].group = GROUP_CRICKET;
+    main_types[CST_CRICKET_7].graphic = load_graphic(CST_CRICKET_7_G);
 
-    main_types[CST_CRICKET_4].group=GROUP_CRICKET;
-    main_types[CST_CRICKET_4].graphic
-	    =load_graphic(CST_CRICKET_4_G);
+    main_types[CST_FIRE_1].group = GROUP_FIRE;
+    main_types[CST_FIRE_1].graphic = load_graphic(CST_FIRE_1_G);
 
-    prog_box(&quot;&quot;,90);
+    main_types[CST_FIRE_2].group = GROUP_FIRE;
+    main_types[CST_FIRE_2].graphic = load_graphic(CST_FIRE_2_G);
 
-    main_types[CST_CRICKET_5].group=GROUP_CRICKET;
-    main_types[CST_CRICKET_5].graphic
-	    =load_graphic(CST_CRICKET_5_G);
+    main_types[CST_FIRE_3].group = GROUP_FIRE;
+    main_types[CST_FIRE_3].graphic = load_graphic(CST_FIRE_3_G);
 
-    main_types[CST_CRICKET_6].group=GROUP_CRICKET;
-    main_types[CST_CRICKET_6].graphic
-	    =load_graphic(CST_CRICKET_6_G);
+    main_types[CST_FIRE_4].group = GROUP_FIRE;
+    main_types[CST_FIRE_4].graphic = load_graphic(CST_FIRE_4_G);
 
-    main_types[CST_CRICKET_7].group=GROUP_CRICKET;
-    main_types[CST_CRICKET_7].graphic
-	    =load_graphic(CST_CRICKET_7_G);
+    main_types[CST_FIRE_5].group = GROUP_FIRE;
+    main_types[CST_FIRE_5].graphic = load_graphic(CST_FIRE_5_G);
 
-    main_types[CST_FIRE_1].group=GROUP_FIRE;
-    main_types[CST_FIRE_1].graphic
-	    =load_graphic(CST_FIRE_1_G);
+    main_types[CST_FIRE_DONE1].group = GROUP_FIRE;
+    main_types[CST_FIRE_DONE1].graphic = load_graphic(CST_FIRE_DONE1_G);
 
-    main_types[CST_FIRE_2].group=GROUP_FIRE;
-    main_types[CST_FIRE_2].graphic
-	    =load_graphic(CST_FIRE_2_G);
+    main_types[CST_FIRE_DONE2].group = GROUP_FIRE;
+    main_types[CST_FIRE_DONE2].graphic = load_graphic(CST_FIRE_DONE2_G);
 
-    main_types[CST_FIRE_3].group=GROUP_FIRE;
-    main_types[CST_FIRE_3].graphic
-	    =load_graphic(CST_FIRE_3_G);
+    main_types[CST_FIRE_DONE3].group = GROUP_FIRE;
+    main_types[CST_FIRE_DONE3].graphic = load_graphic(CST_FIRE_DONE3_G);
 
-    main_types[CST_FIRE_4].group=GROUP_FIRE;
-    main_types[CST_FIRE_4].graphic
-	    =load_graphic(CST_FIRE_4_G);
+    main_types[CST_FIRE_DONE4].group = GROUP_FIRE;
+    main_types[CST_FIRE_DONE4].graphic = load_graphic(CST_FIRE_DONE4_G);
 
-    main_types[CST_FIRE_5].group=GROUP_FIRE;
-    main_types[CST_FIRE_5].graphic
-	    =load_graphic(CST_FIRE_5_G);
-
-    main_types[CST_FIRE_DONE1].group=GROUP_FIRE;
-    main_types[CST_FIRE_DONE1].graphic
-	    =load_graphic(CST_FIRE_DONE1_G);
-
-    main_types[CST_FIRE_DONE2].group=GROUP_FIRE;
-    main_types[CST_FIRE_DONE2].graphic
-	    =load_graphic(CST_FIRE_DONE2_G);
-
-    main_types[CST_FIRE_DONE3].group=GROUP_FIRE;
-    main_types[CST_FIRE_DONE3].graphic
-	    =load_graphic(CST_FIRE_DONE3_G);
-
-    main_types[CST_FIRE_DONE4].group=GROUP_FIRE;
-    main_types[CST_FIRE_DONE4].graphic
-	    =load_graphic(CST_FIRE_DONE4_G);
-
-    main_types[CST_SHANTY].group=GROUP_SHANTY;
-    main_types[CST_SHANTY].graphic=load_graphic(CST_SHANTY_G);
+    main_types[CST_SHANTY].group = GROUP_SHANTY;
+    main_types[CST_SHANTY].graphic = load_graphic(CST_SHANTY_G);
 #endif
 
-    main_types[CST_USED].group=GROUP_USED;
-    main_types[CST_USED].graphic=0;         /* Won't be dereferenced! */
+    main_types[CST_USED].group = GROUP_USED;
+    main_types[CST_USED].graphic = 0;   /* Won't be dereferenced! */
 }
 
-
-
-int
-get_group_of_type (short type)
+int get_group_of_type(short type)
 {
-    if( type == CST_NONE ) return GROUP_BARE;
+    if (type == CST_NONE)
+        return GROUP_BARE;
     return main_types[type].group;
 }
 
-void
-set_map_groups (void)
+void set_map_groups(void)
 {
     int x, y;
     for (x = 0; x &lt; WORLD_SIDE_LEN; x++) {
         for (y = 0; y &lt; WORLD_SIDE_LEN; y++) {
-            MP_GROUP(x,y) = get_group_of_type(MP_TYPE(x,y));
+            MP_GROUP(x, y) = get_group_of_type(MP_TYPE(x, y));
         }
     }
 }
 
-int
-get_group_cost (short group)
+int get_group_cost(short group)
 {
-    return (int) ((float) main_groups[group].cost
-		  + ((float) main_groups[group].cost
-		     * ((float) main_groups[group].cost_mul
-			* (float) tech_level) 
-		     / (float) MAX_TECH_LEVEL));
+    return (int)((float)main_groups[group].cost
+                 + ((float)main_groups[group].cost * ((float)main_groups[group].cost_mul * (float)tech_level)
+                    / (float)MAX_TECH_LEVEL));
 }
 
-void 
-get_type_name (short type, char * s) 
+void get_type_name(short type, char *s)
 {
-     short g;
-     g = get_group_of_type (type);
-     strcpy (s, _(main_groups[g].name));
+    short g;
+    g = get_group_of_type(type);
+    strcpy(s, _(main_groups[g].name));
 }
 
-int
-get_type_cost (short type)
+int get_type_cost(short type)
 {
-    return get_group_cost ((short) get_group_of_type (type));
+    return get_group_cost((short)get_group_of_type(type));
 }

Modified: trunk/src/lincity/lintypes.h
===================================================================
--- trunk/src/lincity/lintypes.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/lintypes.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -17,32 +17,30 @@
 #define NUM_OF_GROUPS    47
 #define GROUP_NAME_LEN   20
 
-struct GROUP
-{
-    const char* name;      /* name of group */
-    unsigned short        no_credit;   /* TRUE if need credit to build */
-    unsigned short        group;       /* This is redundant: it must match
-					  the index into the table */
-    unsigned short        size;
-    int   colour;         /* summary map colour */
-    int   cost_mul;       /* group cost multiplier */
-    int   bul_cost;       /* group bulldoze cost */
-    int   fire_chance;    /* probability of fire */
-    int   cost;           /* group cost */
-    int   tech;           /* group cost */
+struct GROUP {
+    const char *name;           /* name of group */
+    unsigned short no_credit;   /* TRUE if need credit to build */
+    unsigned short group;       /* This is redundant: it must match
+                                   the index into the table */
+    unsigned short size;
+    int colour;                 /* summary map colour */
+    int cost_mul;               /* group cost multiplier */
+    int bul_cost;               /* group bulldoze cost */
+    int fire_chance;            /* probability of fire */
+    int cost;                   /* group cost */
+    int tech;                   /* group cost */
 };
 
-struct TYPE
-{
-    int group;          /* What group does this type belong to? */
-    char* graphic;      /* Bitmap of the graphic */
+struct TYPE {
+    int group;                  /* What group does this type belong to? */
+    char *graphic;              /* Bitmap of the graphic */
 };
 
-int get_group_of_type (short selected_type);
-void set_map_groups (void);
-int get_type_cost (short type);
-int get_group_cost (short group);
-void get_type_name (short type, char * s);
+int get_group_of_type(short selected_type);
+void set_map_groups(void);
+int get_type_cost(short type);
+int get_group_cost(short group);
+void get_type_name(short type, char *s);
 
 extern struct GROUP main_groups[NUM_OF_GROUPS];
 extern struct TYPE main_types[NUM_OF_TYPES];

Modified: trunk/src/lincity/modules/blacksmith.cpp
===================================================================
--- trunk/src/lincity/modules/blacksmith.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/blacksmith.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -9,102 +9,90 @@
 #include &quot;blacksmith.h&quot;
 //#include &quot;cliglobs.h&quot;
 
-
-void
-do_blacksmith (int x, int y)
+void do_blacksmith(int x, int y)
 {
-  /*
-    // int_1 contains the goods at the blacksmith
-    // int_2 contains the goods made - for the animation
-    // int_3 contains the coal store
-    // int_4 is the animation trigger time
-    // int_5 is the % made so far this month
-    // int_6 is the % capacity last month
-    // int_7 contains the jobs stored at the blacksmith
-  */
-  if (MP_INFO(x,y).int_3 &lt; MAX_COAL_AT_BLACKSMITH)
-    if (get_coal (x, y, BLACKSMITH_GET_COAL) != 0)
-      MP_INFO(x,y).int_3 += BLACKSMITH_GET_COAL;
+    /*
+       // int_1 contains the goods at the blacksmith
+       // int_2 contains the goods made - for the animation
+       // int_3 contains the coal store
+       // int_4 is the animation trigger time
+       // int_5 is the % made so far this month
+       // int_6 is the % capacity last month
+       // int_7 contains the jobs stored at the blacksmith
+     */
+    if (MP_INFO(x, y).int_3 &lt; MAX_COAL_AT_BLACKSMITH)
+        if (get_coal(x, y, BLACKSMITH_GET_COAL) != 0)
+            MP_INFO(x, y).int_3 += BLACKSMITH_GET_COAL;
 
-  if (MP_INFO(x,y).int_1 &lt; MAX_GOODS_AT_BLACKSMITH
-      &amp;&amp; MP_INFO(x,y).int_3 &gt;= BLACKSMITH_COAL_USED)
-    {
-      if (get_steel (x, y, BLACKSMITH_STEEL_USED) != 0)
-	{
-	  MP_INFO(x,y).int_1 += GOODS_MADE_BY_BLACKSMITH;
-	  MP_INFO(x,y).int_3 -= BLACKSMITH_COAL_USED;
-	}
+    if (MP_INFO(x, y).int_1 &lt; MAX_GOODS_AT_BLACKSMITH &amp;&amp; MP_INFO(x, y).int_3 &gt;= BLACKSMITH_COAL_USED) {
+        if (get_steel(x, y, BLACKSMITH_STEEL_USED) != 0) {
+            MP_INFO(x, y).int_1 += GOODS_MADE_BY_BLACKSMITH;
+            MP_INFO(x, y).int_3 -= BLACKSMITH_COAL_USED;
+        }
     }
 
-  if (MP_INFO(x,y).int_7 &lt; BLACKSMITH_JOBS) {
-  	if (get_jobs (x, y, BLACKSMITH_JOBS))
-		MP_INFO(x,y).int_7 = BLACKSMITH_JOBS;
-  }
+    if (MP_INFO(x, y).int_7 &lt; BLACKSMITH_JOBS) {
+        if (get_jobs(x, y, BLACKSMITH_JOBS))
+            MP_INFO(x, y).int_7 = BLACKSMITH_JOBS;
+    }
 
-  if (MP_INFO(x,y).int_7 &gt;= BLACKSMITH_JOBS) {
-	if (MP_INFO(x,y).int_1 &gt; GOODS_MADE_BY_BLACKSMITH) {
-		if (put_goods (x, y, GOODS_MADE_BY_BLACKSMITH - 1) != 0) {
-		      MP_INFO(x,y).int_1 -= (GOODS_MADE_BY_BLACKSMITH - 1);
-		      MP_INFO(x,y).int_2 += (GOODS_MADE_BY_BLACKSMITH - 1);
-		      MP_INFO(x,y).int_5++;
-		      MP_INFO(x,y).int_7 -= BLACKSMITH_JOBS;
-		}
-	}
-  } else {
-    MP_TYPE(x,y) = CST_BLACKSMITH_0;
-  }
+    if (MP_INFO(x, y).int_7 &gt;= BLACKSMITH_JOBS) {
+        if (MP_INFO(x, y).int_1 &gt; GOODS_MADE_BY_BLACKSMITH) {
+            if (put_goods(x, y, GOODS_MADE_BY_BLACKSMITH - 1) != 0) {
+                MP_INFO(x, y).int_1 -= (GOODS_MADE_BY_BLACKSMITH - 1);
+                MP_INFO(x, y).int_2 += (GOODS_MADE_BY_BLACKSMITH - 1);
+                MP_INFO(x, y).int_5++;
+                MP_INFO(x, y).int_7 -= BLACKSMITH_JOBS;
+            }
+        }
+    } else {
+        MP_TYPE(x, y) = CST_BLACKSMITH_0;
+    }
 
-  if (MP_INFO(x,y).int_2 &gt; BLACKSMITH_BATCH
-      &amp;&amp; real_time &gt;= MP_INFO(x,y).int_4)
-    {
-      MP_INFO(x,y).int_4 = real_time + BLACKSMITH_ANIM_SPEED;
-      switch (MP_TYPE(x,y))
-	{
-	case (CST_BLACKSMITH_0):
-	  MP_TYPE(x,y) = CST_BLACKSMITH_1;
-	  break;
-	case (CST_BLACKSMITH_1):
-	  MP_TYPE(x,y) = CST_BLACKSMITH_2;
-	  break;
-	case (CST_BLACKSMITH_2):
-	  MP_TYPE(x,y) = CST_BLACKSMITH_3;
-	  break;
-	case (CST_BLACKSMITH_3):
-	  MP_TYPE(x,y) = CST_BLACKSMITH_4;
-	  break;
-	case (CST_BLACKSMITH_4):
-	  MP_TYPE(x,y) = CST_BLACKSMITH_5;
-	  break;
-	case (CST_BLACKSMITH_5):
-	  MP_TYPE(x,y) = CST_BLACKSMITH_6;
-	  break;
-	case (CST_BLACKSMITH_6):
-	  MP_TYPE(x,y) = CST_BLACKSMITH_1;
-	  MP_INFO(x,y).int_2 = 0;
-	  MP_POL(x,y)++;
-	  break;
-	}
+    if (MP_INFO(x, y).int_2 &gt; BLACKSMITH_BATCH &amp;&amp; real_time &gt;= MP_INFO(x, y).int_4) {
+        MP_INFO(x, y).int_4 = real_time + BLACKSMITH_ANIM_SPEED;
+        switch (MP_TYPE(x, y)) {
+        case (CST_BLACKSMITH_0):
+            MP_TYPE(x, y) = CST_BLACKSMITH_1;
+            break;
+        case (CST_BLACKSMITH_1):
+            MP_TYPE(x, y) = CST_BLACKSMITH_2;
+            break;
+        case (CST_BLACKSMITH_2):
+            MP_TYPE(x, y) = CST_BLACKSMITH_3;
+            break;
+        case (CST_BLACKSMITH_3):
+            MP_TYPE(x, y) = CST_BLACKSMITH_4;
+            break;
+        case (CST_BLACKSMITH_4):
+            MP_TYPE(x, y) = CST_BLACKSMITH_5;
+            break;
+        case (CST_BLACKSMITH_5):
+            MP_TYPE(x, y) = CST_BLACKSMITH_6;
+            break;
+        case (CST_BLACKSMITH_6):
+            MP_TYPE(x, y) = CST_BLACKSMITH_1;
+            MP_INFO(x, y).int_2 = 0;
+            MP_POL(x, y)++;
+            break;
+        }
     }
-  if (total_time % 100 == 0)
-    {
-      MP_INFO(x,y).int_6 = MP_INFO(x,y).int_5;
-      MP_INFO(x,y).int_5 = 0;
+    if (total_time % 100 == 0) {
+        MP_INFO(x, y).int_6 = MP_INFO(x, y).int_5;
+        MP_INFO(x, y).int_5 = 0;
     }
 }
 
-void
-mps_blacksmith (int x, int y)
+void mps_blacksmith(int x, int y)
 {
-  int i = 0;
+    int i = 0;
 
-  mps_store_title(i++,_(&quot;Blacksmith&quot;));
-  i++;
+    mps_store_title(i++, _(&quot;Blacksmith&quot;));
+    i++;
 
-  mps_store_sfp(i++,_(&quot;Capacity&quot;), MP_INFO(x,y).int_6);
-  i++;
-  mps_store_title(i++,_(&quot;Inventory&quot;));
-  mps_store_sfp(i++,_(&quot;Goods&quot;),
-		MP_INFO(x,y).int_1 * 100.0 / MAX_GOODS_AT_BLACKSMITH);
-  mps_store_sfp(i++,_(&quot;Coal&quot;), 
-		MP_INFO(x,y).int_3 * 100.0 / MAX_COAL_AT_BLACKSMITH);
+    mps_store_sfp(i++, _(&quot;Capacity&quot;), MP_INFO(x, y).int_6);
+    i++;
+    mps_store_title(i++, _(&quot;Inventory&quot;));
+    mps_store_sfp(i++, _(&quot;Goods&quot;), MP_INFO(x, y).int_1 * 100.0 / MAX_GOODS_AT_BLACKSMITH);
+    mps_store_sfp(i++, _(&quot;Coal&quot;), MP_INFO(x, y).int_3 * 100.0 / MAX_COAL_AT_BLACKSMITH);
 }

Modified: trunk/src/lincity/modules/blacksmith.h
===================================================================
--- trunk/src/lincity/modules/blacksmith.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/blacksmith.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -9,6 +9,6 @@
 #define __blacksmith_h__
 
 void do_blacksmith(int x, int y);
-void mps_blacksmith (int x, int y);
+void mps_blacksmith(int x, int y);
 
 #endif /* __blacksmith_h__ */

Modified: trunk/src/lincity/modules/coal_power.cpp
===================================================================
--- trunk/src/lincity/modules/coal_power.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/coal_power.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -8,8 +8,8 @@
 #include &quot;modules.h&quot;
 #include &quot;../power.h&quot;
 #include &quot;coal_power.h&quot;
-#include &quot;../transport.h&quot;  /* XXX: This seems to be an anomaly; no other modules
-			  use XY_IS_TRANSPORT */
+#include &quot;../transport.h&quot;       /* XXX: This seems to be an anomaly; no other modules
+                                   use XY_IS_TRANSPORT */
 
 /*** Coal Power ***/
 /*
@@ -22,91 +22,79 @@
   // int_7 is grid_timestamp
 */
 
-
-void
-do_power_source_coal (int x, int y)
+void do_power_source_coal(int x, int y)
 {
 
     /* Need coal?  Try transport. */
-    if (MP_INFO(x,y).int_2 &lt; MAX_COAL_AT_POWER_STATION) {
+    if (MP_INFO(x, y).int_2 &lt; MAX_COAL_AT_POWER_STATION) {
 
-	/* left side */
-	if (XY_IS_TRANSPORT(x-1, y+1) &amp;&amp; MP_INFO(x-1, y+1).int_3 &gt; 0) {
-	    if (get_jobs (x, y, JOBS_LOAD_COAL) != 0)
-	    {
-		MP_INFO(x,y).int_2 += (MP_INFO(x-1, y+1).int_3 / 2
-				       + ((MP_INFO(x-1, y+1).int_3) % 2));
-		MP_INFO(x-1, y+1).int_3 /= 2;
-		MP_POL(x,y)++;
-	    }
-	}
-	/* top side */
-	else if (XY_IS_TRANSPORT(x+1, y-1) &amp;&amp; MP_INFO(x+1, y-1).int_3 &gt; 0) {
-	    if (get_jobs (x, y, JOBS_LOAD_COAL) != 0)
-		MP_INFO(x,y).int_2 += (MP_INFO(x+1, y-1).int_3 / 2
-				       + ((MP_INFO(x+1, y-1).int_3) % 2));
-	    MP_INFO(x + 1,y - 1).int_3 /= 2;
-	    MP_POL(x,y)++;
-	}
+        /* left side */
+        if (XY_IS_TRANSPORT(x - 1, y + 1) &amp;&amp; MP_INFO(x - 1, y + 1).int_3 &gt; 0) {
+            if (get_jobs(x, y, JOBS_LOAD_COAL) != 0) {
+                MP_INFO(x, y).int_2 += (MP_INFO(x - 1, y + 1).int_3 / 2 + ((MP_INFO(x - 1, y + 1).int_3) % 2));
+                MP_INFO(x - 1, y + 1).int_3 /= 2;
+                MP_POL(x, y)++;
+            }
+        }
+        /* top side */
+        else if (XY_IS_TRANSPORT(x + 1, y - 1) &amp;&amp; MP_INFO(x + 1, y - 1).int_3 &gt; 0) {
+            if (get_jobs(x, y, JOBS_LOAD_COAL) != 0)
+                MP_INFO(x, y).int_2 += (MP_INFO(x + 1, y - 1).int_3 / 2 + ((MP_INFO(x + 1, y - 1).int_3) % 2));
+            MP_INFO(x + 1, y - 1).int_3 /= 2;
+            MP_POL(x, y)++;
+        }
     }
 
     /* Need jobs?  get_jobs. */
-    if ((MP_INFO(x,y).int_3 + JOBS_COALPS_GENERATE + 10)
-	&lt; MAX_JOBS_AT_COALPS)
-	if (get_jobs (x, y, JOBS_COALPS_GENERATE + 10) != 0)
-	    MP_INFO(x,y).int_3 += JOBS_COALPS_GENERATE + 10;
+    if ((MP_INFO(x, y).int_3 + JOBS_COALPS_GENERATE + 10)
+        &lt; MAX_JOBS_AT_COALPS)
+        if (get_jobs(x, y, JOBS_COALPS_GENERATE + 10) != 0)
+            MP_INFO(x, y).int_3 += JOBS_COALPS_GENERATE + 10;
 
     /* Generate Power */
-    if (MP_INFO(x,y).int_2 &gt; POWERS_COAL_OUTPUT / 500 &amp;&amp;
-	MP_INFO(x,y).int_3 &gt; JOBS_COALPS_GENERATE) 
-    {
-	MP_INFO(x,y).int_5 = MP_INFO(x,y).int_1;
-	MP_INFO(x,y).int_3 -= JOBS_COALPS_GENERATE;
-	MP_INFO(x,y).int_2 -= POWERS_COAL_OUTPUT / 500;
-	coal_used += POWERS_COAL_OUTPUT / 500;
-	MP_POL(x,y) += POWERS_COAL_POLLUTION;
-	grid[MP_INFO(x,y).int_6]-&gt;avail_power += MP_INFO(x,y).int_1;
+    if (MP_INFO(x, y).int_2 &gt; POWERS_COAL_OUTPUT / 500 &amp;&amp; MP_INFO(x, y).int_3 &gt; JOBS_COALPS_GENERATE) {
+        MP_INFO(x, y).int_5 = MP_INFO(x, y).int_1;
+        MP_INFO(x, y).int_3 -= JOBS_COALPS_GENERATE;
+        MP_INFO(x, y).int_2 -= POWERS_COAL_OUTPUT / 500;
+        coal_used += POWERS_COAL_OUTPUT / 500;
+        MP_POL(x, y) += POWERS_COAL_POLLUTION;
+        grid[MP_INFO(x, y).int_6]-&gt;avail_power += MP_INFO(x, y).int_1;
     }
 
     /* Animation */
     /* choose a graphic */
-    if (MP_INFO(x,y).int_2 &gt; (MAX_COAL_AT_POWER_STATION
-			      - (MAX_COAL_AT_POWER_STATION / 5)))
-	MP_TYPE(x,y) = CST_POWERS_COAL_FULL;
-    else if (MP_INFO(x,y).int_2 &gt; (MAX_COAL_AT_POWER_STATION / 2))
-	MP_TYPE(x,y) = CST_POWERS_COAL_MED;
-    else if (MP_INFO(x,y).int_2 &gt; (MAX_COAL_AT_POWER_STATION / 10))
-	MP_TYPE(x,y) = CST_POWERS_COAL_LOW;
+    if (MP_INFO(x, y).int_2 &gt; (MAX_COAL_AT_POWER_STATION - (MAX_COAL_AT_POWER_STATION / 5)))
+        MP_TYPE(x, y) = CST_POWERS_COAL_FULL;
+    else if (MP_INFO(x, y).int_2 &gt; (MAX_COAL_AT_POWER_STATION / 2))
+        MP_TYPE(x, y) = CST_POWERS_COAL_MED;
+    else if (MP_INFO(x, y).int_2 &gt; (MAX_COAL_AT_POWER_STATION / 10))
+        MP_TYPE(x, y) = CST_POWERS_COAL_LOW;
     else
-	MP_TYPE(x,y) = CST_POWERS_COAL_EMPTY;
+        MP_TYPE(x, y) = CST_POWERS_COAL_EMPTY;
 }
 
-void
-mps_coal_power (int x, int y)
+void mps_coal_power(int x, int y)
 {
-  int i = 0;
+    int i = 0;
 
-  char s[12];
+    char s[12];
 
-  mps_store_title(i++,_(&quot;Coal&quot;));
-  mps_store_title(i++,_(&quot;Power Station&quot;));
-  i++;
+    mps_store_title(i++, _(&quot;Coal&quot;));
+    mps_store_title(i++, _(&quot;Power Station&quot;));
+    i++;
 
-  format_power (s, sizeof(s), MP_INFO(x,y).int_1);
-  mps_store_title(i++,_(&quot;Max Output&quot;));
-  mps_store_title(i++,s);
-  i++;
+    format_power(s, sizeof(s), MP_INFO(x, y).int_1);
+    mps_store_title(i++, _(&quot;Max Output&quot;));
+    mps_store_title(i++, s);
+    i++;
 
-  format_power (s, sizeof(s), MP_INFO(x,y).int_5);
-  mps_store_title(i++,_(&quot;Current Output&quot;));
-  mps_store_title(i++,s);
-  i++;
+    format_power(s, sizeof(s), MP_INFO(x, y).int_5);
+    mps_store_title(i++, _(&quot;Current Output&quot;));
+    mps_store_title(i++, s);
+    i++;
 
-  mps_store_sfp(i++,_(&quot;Coal&quot;),
-		MP_INFO(x,y).int_2 * 100.0 / MAX_COAL_AT_POWER_STATION);
-  mps_store_sfp(i++,_(&quot;Jobs&quot;), 
-		MP_INFO(x,y).int_3 * 100.0 / MAX_JOBS_AT_COALPS);
-  mps_store_sfp(i++,_(&quot;Tech&quot;),
-		MP_INFO(x,y).int_4 * 100.0 / MAX_TECH_LEVEL);  
-  mps_store_sd(i++,_(&quot;Grid ID&quot;), MP_INFO(x,y).int_6);
+    mps_store_sfp(i++, _(&quot;Coal&quot;), MP_INFO(x, y).int_2 * 100.0 / MAX_COAL_AT_POWER_STATION);
+    mps_store_sfp(i++, _(&quot;Jobs&quot;), MP_INFO(x, y).int_3 * 100.0 / MAX_JOBS_AT_COALPS);
+    mps_store_sfp(i++, _(&quot;Tech&quot;), MP_INFO(x, y).int_4 * 100.0 / MAX_TECH_LEVEL);
+    mps_store_sd(i++, _(&quot;Grid ID&quot;), MP_INFO(x, y).int_6);
 }

Modified: trunk/src/lincity/modules/coal_power.h
===================================================================
--- trunk/src/lincity/modules/coal_power.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/coal_power.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -9,6 +9,6 @@
 #define __coal_power_h__
 
 void do_power_source_coal(int x, int y);
-void mps_coal_power (int, int);
+void mps_coal_power(int, int);
 
 #endif /* __coal_power_h__ */

Modified: trunk/src/lincity/modules/coalmine.cpp
===================================================================
--- trunk/src/lincity/modules/coalmine.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/coalmine.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -8,171 +8,135 @@
 #include &quot;modules.h&quot;
 #include &quot;coalmine.h&quot;
 
-
-void
-do_coalmine (int x, int y)
+void do_coalmine(int x, int y)
 {
-  /*
-     // int_1 is the coal at the surface
-     // int_2 is the coal reserve under the ground. More than one mine can claim the coal under ground!
-     // int_3 is the jobs collected.
-   */
-  int xx, yy, xs, ys, xe, ye, cr;
-  if (MP_INFO(x,y).int_1 &lt; (DIG_MORE_COAL_TRIGGER - 1000))
-    {
-      if (MP_INFO(x,y).int_2 &lt; 0)
-	return;			/* run out of reserves */
+    /*
+       // int_1 is the coal at the surface
+       // int_2 is the coal reserve under the ground. More than one mine can claim the coal under ground!
+       // int_3 is the jobs collected.
+     */
+    int xx, yy, xs, ys, xe, ye, cr;
+    if (MP_INFO(x, y).int_1 &lt; (DIG_MORE_COAL_TRIGGER - 1000)) {
+        if (MP_INFO(x, y).int_2 &lt; 0)
+            return;             /* run out of reserves */
 
-      xs = x - COAL_RESERVE_SEARCH_LEN;
-      if (xs &lt; 0)
-	xs = 0;
-      ys = y - COAL_RESERVE_SEARCH_LEN;
-      if (ys &lt; 0)
-	ys = 0;
-      xe = x + COAL_RESERVE_SEARCH_LEN;
-      if (xe &gt; WORLD_SIDE_LEN)
-	xe = WORLD_SIDE_LEN;
-      ye = y + COAL_RESERVE_SEARCH_LEN;
-      if (ye &gt; WORLD_SIDE_LEN)
-	ye = WORLD_SIDE_LEN;
-      cr = 0;
-      for (yy = ys; yy &lt; ye; yy++)
-	for (xx = xs; xx &lt; xe; xx++)
-	  cr += MP_INFO(xx,yy).coal_reserve;
-      MP_INFO(x,y).int_2 = cr;
-      if (cr &gt; 0)
-	{
-	  if (get_jobs (x, y, JOBS_DIG_COAL
-			- MP_INFO(x,y).int_3) != 0)
-	    {
-	      MP_INFO(x,y).int_3 = 0;
-	      for (yy = ys; yy &lt; ye; yy++)
-		for (xx = xs; xx &lt; xe; xx++)
-		  if (MP_INFO(xx,yy).coal_reserve &gt; 0)
-		    {
-		      MP_INFO(xx,yy).coal_reserve--;
-		      MP_INFO(x,y).int_1 += 1000;
-		      coal_made += 1000;
-		      coal_tax += 1000;
-		      sust_dig_ore_coal_tip_flag = 0;
-		      MP_POL(x,y) += COALMINE_POLLUTION;
-		      yy = ye;
-		      xx = xe;	/* break out */
+        xs = x - COAL_RESERVE_SEARCH_LEN;
+        if (xs &lt; 0)
+            xs = 0;
+        ys = y - COAL_RESERVE_SEARCH_LEN;
+        if (ys &lt; 0)
+            ys = 0;
+        xe = x + COAL_RESERVE_SEARCH_LEN;
+        if (xe &gt; WORLD_SIDE_LEN)
+            xe = WORLD_SIDE_LEN;
+        ye = y + COAL_RESERVE_SEARCH_LEN;
+        if (ye &gt; WORLD_SIDE_LEN)
+            ye = WORLD_SIDE_LEN;
+        cr = 0;
+        for (yy = ys; yy &lt; ye; yy++)
+            for (xx = xs; xx &lt; xe; xx++)
+                cr += MP_INFO(xx, yy).coal_reserve;
+        MP_INFO(x, y).int_2 = cr;
+        if (cr &gt; 0) {
+            if (get_jobs(x, y, JOBS_DIG_COAL - MP_INFO(x, y).int_3) != 0) {
+                MP_INFO(x, y).int_3 = 0;
+                for (yy = ys; yy &lt; ye; yy++)
+                    for (xx = xs; xx &lt; xe; xx++)
+                        if (MP_INFO(xx, yy).coal_reserve &gt; 0) {
+                            MP_INFO(xx, yy).coal_reserve--;
+                            MP_INFO(x, y).int_1 += 1000;
+                            coal_made += 1000;
+                            coal_tax += 1000;
+                            sust_dig_ore_coal_tip_flag = 0;
+                            MP_POL(x, y) += COALMINE_POLLUTION;
+                            yy = ye;
+                            xx = xe;    /* break out */
 
-		    }
-	    }
-	  else if (get_jobs (x, y, JOBS_DIG_COAL / 10) != 0)
-	    MP_INFO(x,y).int_3 += JOBS_DIG_COAL / 10;
-	  else if (get_jobs (x, y, JOBS_DIG_COAL / 50) != 0)
-	    MP_INFO(x,y).int_3 += JOBS_DIG_COAL / 50;
-	}
-      else
-	{
-	  MP_INFO(x,y).int_1 = 0;
-	  MP_INFO(x,y).int_2 = -1;
-	}
+                        }
+            } else if (get_jobs(x, y, JOBS_DIG_COAL / 10) != 0)
+                MP_INFO(x, y).int_3 += JOBS_DIG_COAL / 10;
+            else if (get_jobs(x, y, JOBS_DIG_COAL / 50) != 0)
+                MP_INFO(x, y).int_3 += JOBS_DIG_COAL / 50;
+        } else {
+            MP_INFO(x, y).int_1 = 0;
+            MP_INFO(x, y).int_2 = -1;
+        }
     }
-  /* put it on the railway */
-  if (MP_GROUP(x - 1,y) == GROUP_RAIL
-      &amp;&amp; MP_INFO(x - 1,y).int_3 &lt; MAX_COAL_ON_RAIL
-      &amp;&amp; MP_INFO(x,y).int_1 &gt;= (MAX_COAL_ON_RAIL
-				  - MP_INFO(x - 1,y).int_3))
-    {
-      if (get_jobs (x, y, JOBS_LOAD_COAL) != 0)
-	{
-	  MP_INFO(x,y).int_1
-	    -= (MAX_COAL_ON_RAIL - MP_INFO(x - 1,y).int_3);
-	  MP_INFO(x - 1,y).int_3 = MAX_COAL_ON_RAIL;
-	}
+    /* put it on the railway */
+    if (MP_GROUP(x - 1, y) == GROUP_RAIL
+        &amp;&amp; MP_INFO(x - 1, y).int_3 &lt; MAX_COAL_ON_RAIL
+        &amp;&amp; MP_INFO(x, y).int_1 &gt;= (MAX_COAL_ON_RAIL - MP_INFO(x - 1, y).int_3)) {
+        if (get_jobs(x, y, JOBS_LOAD_COAL) != 0) {
+            MP_INFO(x, y).int_1 -= (MAX_COAL_ON_RAIL - MP_INFO(x - 1, y).int_3);
+            MP_INFO(x - 1, y).int_3 = MAX_COAL_ON_RAIL;
+        }
     }
-  if (MP_GROUP(x,y-1) == GROUP_RAIL
-      &amp;&amp; MP_INFO(x,y - 1).int_3 &lt; MAX_COAL_ON_RAIL
-      &amp;&amp; MP_INFO(x,y).int_1 &gt;= (MAX_COAL_ON_RAIL
-				  - MP_INFO(x,y - 1).int_3))
-    {
-      if (get_jobs (x, y, JOBS_LOAD_COAL) != 0)
-	{
-	  MP_INFO(x,y).int_1
-	    -= (MAX_COAL_ON_RAIL - MP_INFO(x,y - 1).int_3);
-	  MP_INFO(x,y - 1).int_3 = MAX_COAL_ON_RAIL;
-	}
+    if (MP_GROUP(x, y - 1) == GROUP_RAIL
+        &amp;&amp; MP_INFO(x, y - 1).int_3 &lt; MAX_COAL_ON_RAIL
+        &amp;&amp; MP_INFO(x, y).int_1 &gt;= (MAX_COAL_ON_RAIL - MP_INFO(x, y - 1).int_3)) {
+        if (get_jobs(x, y, JOBS_LOAD_COAL) != 0) {
+            MP_INFO(x, y).int_1 -= (MAX_COAL_ON_RAIL - MP_INFO(x, y - 1).int_3);
+            MP_INFO(x, y - 1).int_3 = MAX_COAL_ON_RAIL;
+        }
     }
-  /* put it on the road */
-  if (MP_GROUP(x-1,y) == GROUP_ROAD
-      &amp;&amp; MP_INFO(x - 1,y).int_3 &lt; MAX_COAL_ON_ROAD
-      &amp;&amp; MP_INFO(x,y).int_1 &gt;= (MAX_COAL_ON_ROAD
-				  - MP_INFO(x - 1,y).int_3))
-    {
-      if (get_jobs (x, y, JOBS_LOAD_COAL) != 0)
-	{
-	  MP_INFO(x,y).int_1
-	    -= (MAX_COAL_ON_ROAD - MP_INFO(x - 1,y).int_3);
-	  MP_INFO(x - 1,y).int_3 = MAX_COAL_ON_ROAD;
-	}
+    /* put it on the road */
+    if (MP_GROUP(x - 1, y) == GROUP_ROAD
+        &amp;&amp; MP_INFO(x - 1, y).int_3 &lt; MAX_COAL_ON_ROAD
+        &amp;&amp; MP_INFO(x, y).int_1 &gt;= (MAX_COAL_ON_ROAD - MP_INFO(x - 1, y).int_3)) {
+        if (get_jobs(x, y, JOBS_LOAD_COAL) != 0) {
+            MP_INFO(x, y).int_1 -= (MAX_COAL_ON_ROAD - MP_INFO(x - 1, y).int_3);
+            MP_INFO(x - 1, y).int_3 = MAX_COAL_ON_ROAD;
+        }
     }
-  if (MP_GROUP(x,y-1) == GROUP_ROAD
-      &amp;&amp; MP_INFO(x,y - 1).int_3 &lt; MAX_COAL_ON_ROAD
-      &amp;&amp; MP_INFO(x,y).int_1 &gt;= (MAX_COAL_ON_ROAD
-				  - MP_INFO(x,y - 1).int_3))
-    {
-      if (get_jobs (x, y, JOBS_LOAD_COAL) != 0)
-	{
-	  MP_INFO(x,y).int_1
-	    -= (MAX_COAL_ON_ROAD - MP_INFO(x,y - 1).int_3);
-	  MP_INFO(x,y - 1).int_3 = MAX_COAL_ON_ROAD;
-	}
+    if (MP_GROUP(x, y - 1) == GROUP_ROAD
+        &amp;&amp; MP_INFO(x, y - 1).int_3 &lt; MAX_COAL_ON_ROAD
+        &amp;&amp; MP_INFO(x, y).int_1 &gt;= (MAX_COAL_ON_ROAD - MP_INFO(x, y - 1).int_3)) {
+        if (get_jobs(x, y, JOBS_LOAD_COAL) != 0) {
+            MP_INFO(x, y).int_1 -= (MAX_COAL_ON_ROAD - MP_INFO(x, y - 1).int_3);
+            MP_INFO(x, y - 1).int_3 = MAX_COAL_ON_ROAD;
+        }
     }
-  /* put it on the tracks */
-  if (MP_GROUP(x-1,y) == GROUP_TRACK
-      &amp;&amp; MP_INFO(x - 1,y).int_3 &lt; MAX_COAL_ON_TRACK
-      &amp;&amp; MP_INFO(x,y).int_1 &gt;= (MAX_COAL_ON_TRACK
-				  - MP_INFO(x - 1,y).int_3))
-    {
-      if (get_jobs (x, y, JOBS_LOAD_COAL) != 0)
-	{
-	  MP_INFO(x,y).int_1
-	    -= (MAX_COAL_ON_TRACK - MP_INFO(x - 1,y).int_3);
-	  MP_INFO(x - 1,y).int_3 = MAX_COAL_ON_TRACK;
-	}
+    /* put it on the tracks */
+    if (MP_GROUP(x - 1, y) == GROUP_TRACK
+        &amp;&amp; MP_INFO(x - 1, y).int_3 &lt; MAX_COAL_ON_TRACK
+        &amp;&amp; MP_INFO(x, y).int_1 &gt;= (MAX_COAL_ON_TRACK - MP_INFO(x - 1, y).int_3)) {
+        if (get_jobs(x, y, JOBS_LOAD_COAL) != 0) {
+            MP_INFO(x, y).int_1 -= (MAX_COAL_ON_TRACK - MP_INFO(x - 1, y).int_3);
+            MP_INFO(x - 1, y).int_3 = MAX_COAL_ON_TRACK;
+        }
     }
-  if (MP_GROUP(x,y-1) == GROUP_TRACK
-      &amp;&amp; MP_INFO(x,y - 1).int_3 &lt; MAX_COAL_ON_TRACK
-      &amp;&amp; MP_INFO(x,y).int_1 &gt;= (MAX_COAL_ON_TRACK
-				  - MP_INFO(x,y - 1).int_3))
-    {
-      if (get_jobs (x, y, JOBS_LOAD_COAL) != 0)
-	{
-	  MP_INFO(x,y).int_1
-	    -= (MAX_COAL_ON_TRACK - MP_INFO(x,y - 1).int_3);
-	  MP_INFO(x,y - 1).int_3 = MAX_COAL_ON_TRACK;
-	}
+    if (MP_GROUP(x, y - 1) == GROUP_TRACK
+        &amp;&amp; MP_INFO(x, y - 1).int_3 &lt; MAX_COAL_ON_TRACK
+        &amp;&amp; MP_INFO(x, y).int_1 &gt;= (MAX_COAL_ON_TRACK - MP_INFO(x, y - 1).int_3)) {
+        if (get_jobs(x, y, JOBS_LOAD_COAL) != 0) {
+            MP_INFO(x, y).int_1 -= (MAX_COAL_ON_TRACK - MP_INFO(x, y - 1).int_3);
+            MP_INFO(x, y - 1).int_3 = MAX_COAL_ON_TRACK;
+        }
     }
 
-  /* choose a graphic */
-  if (MP_INFO(x,y).int_1 &gt; (MAX_COAL_AT_MINE - (MAX_COAL_AT_MINE / 5)))
-    MP_TYPE(x,y) = CST_COALMINE_FULL;
-  else if (MP_INFO(x,y).int_1 &gt; (MAX_COAL_AT_MINE / 2))
-    MP_TYPE(x,y) = CST_COALMINE_MED;
-  else if (MP_INFO(x,y).int_1 &gt; 0)
-    MP_TYPE(x,y) = CST_COALMINE_LOW;
-  else
-    MP_TYPE(x,y) = CST_COALMINE_EMPTY;
+    /* choose a graphic */
+    if (MP_INFO(x, y).int_1 &gt; (MAX_COAL_AT_MINE - (MAX_COAL_AT_MINE / 5)))
+        MP_TYPE(x, y) = CST_COALMINE_FULL;
+    else if (MP_INFO(x, y).int_1 &gt; (MAX_COAL_AT_MINE / 2))
+        MP_TYPE(x, y) = CST_COALMINE_MED;
+    else if (MP_INFO(x, y).int_1 &gt; 0)
+        MP_TYPE(x, y) = CST_COALMINE_LOW;
+    else
+        MP_TYPE(x, y) = CST_COALMINE_EMPTY;
 }
 
-void
-mps_coalmine (int x, int y)
+void mps_coalmine(int x, int y)
 {
-  int i = 0;
+    int i = 0;
 
-  mps_store_title(i++,_(&quot;Coal Mine&quot;));
-  i++;
+    mps_store_title(i++, _(&quot;Coal Mine&quot;));
+    i++;
 
-  mps_store_sfp(i++,_(&quot;Stock&quot;),
-		MP_INFO(x,y).int_1 * 100 / MAX_COAL_AT_MINE);
+    mps_store_sfp(i++, _(&quot;Stock&quot;), MP_INFO(x, y).int_1 * 100 / MAX_COAL_AT_MINE);
 
-  if (MP_INFO(x,y).int_2 &gt; 0) {
-      mps_store_sd(i++, _(&quot;Reserve&quot;), MP_INFO(x,y).int_2);
-  } else {
-      mps_store_ss(i++, _(&quot;Reserve&quot;), _(&quot;EMPTY&quot;));
-  }
+    if (MP_INFO(x, y).int_2 &gt; 0) {
+        mps_store_sd(i++, _(&quot;Reserve&quot;), MP_INFO(x, y).int_2);
+    } else {
+        mps_store_ss(i++, _(&quot;Reserve&quot;), _(&quot;EMPTY&quot;));
+    }
 }

Modified: trunk/src/lincity/modules/coalmine.h
===================================================================
--- trunk/src/lincity/modules/coalmine.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/coalmine.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -9,6 +9,6 @@
 #define __coalmine_h__
 
 void do_coalmine(int x, int y);
-void mps_coalmine (int x, int y);
+void mps_coalmine(int x, int y);
 
 #endif /* __coalmine_h__ */

Modified: trunk/src/lincity/modules/commune.cpp
===================================================================
--- trunk/src/lincity/modules/commune.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/commune.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -10,178 +10,176 @@
 #include &lt;cstdlib&gt;
 #include &lt;math.h&gt;
 
-void
-do_commune (int x, int y)
+void do_commune(int x, int y)
 {
-  /*
-    // int_1 is the animation trigger time
-    // int_2 is the steelflag/trackflag
-    // int_3 is the coal sold in the last 100 days 200 units is 100%
-    // steel adds more.
-    // int_4 is the months without selling much coal,steel,ore
-    // int_5 is the coal, ore, steel waste flags for last month
-    // int_6 is the coal, ore, steel waste flags so far this month
-  */
-  /* GCS -- I folded the trackflag into int_2, changing the logic slightly.
-     This change only affects the animation. */
-  int trackflag = 0;
-  int coalprod = 2;
-  /* stick coal and ore on tracks, in SMALL doses. */
-  if (use_waterwell) {
-      int w = 0;
-      int n = 0;
-      /* Check underground water, and reduce production accordingly */
-      for (int i = 0; i &lt; MP_SIZE(x,y); i++) {
-          for (int j = 0; j &lt; MP_SIZE(x,y); j++) {
-              n++;
-              if (HAS_UGWATER(x+i,y+j))
-                  w++;
-          }
-      }
-      if (w &lt; n / 3) 
-          coalprod = 0;
-      else if (w &lt; (2 * n) / 3)
-          coalprod = 1;
-  }
+    /*
+       // int_1 is the animation trigger time
+       // int_2 is the steelflag/trackflag
+       // int_3 is the coal sold in the last 100 days 200 units is 100%
+       // steel adds more.
+       // int_4 is the months without selling much coal,steel,ore
+       // int_5 is the coal, ore, steel waste flags for last month
+       // int_6 is the coal, ore, steel waste flags so far this month
+     */
+    /* GCS -- I folded the trackflag into int_2, changing the logic slightly.
+       This change only affects the animation. */
+    int trackflag = 0;
+    int coalprod = 2;
+    /* stick coal and ore on tracks, in SMALL doses. */
+    if (use_waterwell) {
+        int w = 0;
+        int n = 0;
+        /* Check underground water, and reduce production accordingly */
+        for (int i = 0; i &lt; MP_SIZE(x, y); i++) {
+            for (int j = 0; j &lt; MP_SIZE(x, y); j++) {
+                n++;
+                if (HAS_UGWATER(x + i, y + j))
+                    w++;
+            }
+        }
+        if (w &lt; n / 3)
+            coalprod = 0;
+        else if (w &lt; (2 * n) / 3)
+            coalprod = 1;
+    }
 
-  if (put_coal (x, y, coalprod) != 0) {
-      trackflag = 1;
-      MP_INFO(x,y).int_3++;
-      MP_INFO(x,y).int_6 |= 1;
-  }
-  if (put_ore (x, y, 6) != 0) {
-      trackflag = 1;
-      MP_INFO(x,y).int_3++;
-      MP_INFO(x,y).int_6 |= 2;
-  }
-  /* recycle a bit of waste */
-  if (get_waste (x, y, 20) != 0) {
-      trackflag = 1;
-      MP_INFO(x,y).int_3++;
-      MP_INFO(x,y).int_6 |= 8;
-  }
-  if (total_time % 10 == 0) {
-      MP_INFO(x,y).int_2 = 1;
-      if (put_steel (x, y, 2) != 0) {
-	  MP_INFO(x,y).int_3++;
-	  MP_INFO(x,y).int_6 |= 4;
-      } else {
-	MP_INFO(x,y).int_2 = 0;
-      }
-      if (trackflag) {
-	MP_INFO(x,y).int_2 = 0;
-      }
-  }
-
-  /* each month. /AL1: is there a reason for day 48 ? */
-  if (total_time % 100 == 1) {
-    MP_INFO(x,y).int_5 = MP_INFO(x,y).int_6;
-    MP_INFO(x,y).int_6 = 0;
-    if (MP_INFO(x,y).int_5 &amp; 4) { //producing steel
-        if (MP_TYPE(x,y) &lt; CST_COMMUNE_7){
-	    MP_TYPE(x,y) += 5;
+    if (put_coal(x, y, coalprod) != 0) {
+        trackflag = 1;
+        MP_INFO(x, y).int_3++;
+        MP_INFO(x, y).int_6 |= 1;
+    }
+    if (put_ore(x, y, 6) != 0) {
+        trackflag = 1;
+        MP_INFO(x, y).int_3++;
+        MP_INFO(x, y).int_6 |= 2;
+    }
+    /* recycle a bit of waste */
+    if (get_waste(x, y, 20) != 0) {
+        trackflag = 1;
+        MP_INFO(x, y).int_3++;
+        MP_INFO(x, y).int_6 |= 8;
+    }
+    if (total_time % 10 == 0) {
+        MP_INFO(x, y).int_2 = 1;
+        if (put_steel(x, y, 2) != 0) {
+            MP_INFO(x, y).int_3++;
+            MP_INFO(x, y).int_6 |= 4;
+        } else {
+            MP_INFO(x, y).int_2 = 0;
         }
-    } else {
-        if (MP_TYPE(x,y) &gt;= CST_COMMUNE_7){
-	        MP_TYPE(x,y) -= 5;
+        if (trackflag) {
+            MP_INFO(x, y).int_2 = 0;
         }
     }
 
-    if (MP_INFO(x,y).int_3 &gt; 0)	/*  &gt;0% */ {
-	  MP_INFO(x,y).int_3 = 0;
-	  if (--MP_INFO(x,y).int_4 &lt; 0)
-              MP_INFO(x,y).int_4 = 0;
-    } else {
-	  MP_INFO(x,y).int_3 = 0;
-	  MP_INFO(x,y).int_4++;
-	  /* Communes without production only last 10 years */
-	  if (MP_INFO(x,y).int_4 &gt; 120)	/* 10 years */ {
-              if (use_waterwell) {
-                  int s =  MP_SIZE(x,y);
-                  /* first destroy the commune, then fill it with correct tiles
-                   * maybe paranoid, but tile is 4x4 thus becomes 16 tiles 1x1
-                   */
-                  do_bulldoze_area (CST_DESERT, x, y);
-                  for (int i = 0; i &lt; s; i++) {
-                      for (int j = 0; j &lt; s; j++)
-                          if (HAS_UGWATER(x+i,y+j))
-                                do_bulldoze_area (CST_PARKLAND_PLANE, x+i, y+j);
-                          else
-                                do_bulldoze_area (CST_DESERT, x+i, y+j);
-                  }
-              } else {
-                  do_bulldoze_area (CST_PARKLAND_PLANE, x, y);
-              }
-	      return;
-          }
+    /* each month. /AL1: is there a reason for day 48 ? */
+    if (total_time % 100 == 1) {
+        MP_INFO(x, y).int_5 = MP_INFO(x, y).int_6;
+        MP_INFO(x, y).int_6 = 0;
+        if (MP_INFO(x, y).int_5 &amp; 4) {  //producing steel
+            if (MP_TYPE(x, y) &lt; CST_COMMUNE_7) {
+                MP_TYPE(x, y) += 5;
+            }
+        } else {
+            if (MP_TYPE(x, y) &gt;= CST_COMMUNE_7) {
+                MP_TYPE(x, y) -= 5;
+            }
+        }
+
+        if (MP_INFO(x, y).int_3 &gt; 0) {  /*  &gt;0% */
+            MP_INFO(x, y).int_3 = 0;
+            if (--MP_INFO(x, y).int_4 &lt; 0)
+                MP_INFO(x, y).int_4 = 0;
+        } else {
+            MP_INFO(x, y).int_3 = 0;
+            MP_INFO(x, y).int_4++;
+            /* Communes without production only last 10 years */
+            if (MP_INFO(x, y).int_4 &gt; 120) {    /* 10 years */
+                if (use_waterwell) {
+                    int s = MP_SIZE(x, y);
+                    /* first destroy the commune, then fill it with correct tiles
+                     * maybe paranoid, but tile is 4x4 thus becomes 16 tiles 1x1
+                     */
+                    do_bulldoze_area(CST_DESERT, x, y);
+                    for (int i = 0; i &lt; s; i++) {
+                        for (int j = 0; j &lt; s; j++)
+                            if (HAS_UGWATER(x + i, y + j))
+                                do_bulldoze_area(CST_PARKLAND_PLANE, x + i, y + j);
+                            else
+                                do_bulldoze_area(CST_DESERT, x + i, y + j);
+                    }
+                } else {
+                    do_bulldoze_area(CST_PARKLAND_PLANE, x, y);
+                }
+                return;
+            }
+        }
     }
-  }
 
-  /* animate */
-  if (real_time &gt;= MP_INFO(x,y).int_1) {
-      MP_INFO(x,y).int_1 = real_time + COMMUNE_ANIM_SPEED - 25 + (rand() % 50);
-      switch (MP_TYPE(x,y)) {
+    /* animate */
+    if (real_time &gt;= MP_INFO(x, y).int_1) {
+        MP_INFO(x, y).int_1 = real_time + COMMUNE_ANIM_SPEED - 25 + (rand() % 50);
+        switch (MP_TYPE(x, y)) {
         case (CST_COMMUNE_1):
-          MP_TYPE(x,y) = CST_COMMUNE_2;
-          break;
+            MP_TYPE(x, y) = CST_COMMUNE_2;
+            break;
         case (CST_COMMUNE_2):
-          MP_TYPE(x,y) = CST_COMMUNE_3;
-          break;
+            MP_TYPE(x, y) = CST_COMMUNE_3;
+            break;
         case (CST_COMMUNE_3):
-          MP_TYPE(x,y) = CST_COMMUNE_4;
-          break;
+            MP_TYPE(x, y) = CST_COMMUNE_4;
+            break;
         case (CST_COMMUNE_4):
-          MP_TYPE(x,y) = CST_COMMUNE_5;
-          break;
+            MP_TYPE(x, y) = CST_COMMUNE_5;
+            break;
         case (CST_COMMUNE_5):
-          MP_TYPE(x,y) = CST_COMMUNE_6;
-          break;
+            MP_TYPE(x, y) = CST_COMMUNE_6;
+            break;
         case (CST_COMMUNE_6):
-          MP_TYPE(x,y) = CST_COMMUNE_2;
-          break;
+            MP_TYPE(x, y) = CST_COMMUNE_2;
+            break;
         case (CST_COMMUNE_7):
-          MP_TYPE(x,y) = CST_COMMUNE_8;
-          break;
+            MP_TYPE(x, y) = CST_COMMUNE_8;
+            break;
         case (CST_COMMUNE_8):
-          MP_TYPE(x,y) = CST_COMMUNE_9;
-          break;
+            MP_TYPE(x, y) = CST_COMMUNE_9;
+            break;
         case (CST_COMMUNE_9):
-          MP_TYPE(x,y) = CST_COMMUNE_10;
-          break;
+            MP_TYPE(x, y) = CST_COMMUNE_10;
+            break;
         case (CST_COMMUNE_10):
-          MP_TYPE(x,y) = CST_COMMUNE_11;
-          break;
+            MP_TYPE(x, y) = CST_COMMUNE_11;
+            break;
         case (CST_COMMUNE_11):
-          MP_TYPE(x,y) = CST_COMMUNE_7;
-          break;
+            MP_TYPE(x, y) = CST_COMMUNE_7;
+            break;
         default:
-          MP_TYPE(x,y) = CST_COMMUNE_1;
-          break;
-	    }
-        if( MP_INFO(x,y).int_5 == 0 ){ //not producing anything
-          MP_TYPE(x,y) = CST_COMMUNE_1;
+            MP_TYPE(x, y) = CST_COMMUNE_1;
+            break;
         }
+        if (MP_INFO(x, y).int_5 == 0) { //not producing anything
+            MP_TYPE(x, y) = CST_COMMUNE_1;
+        }
     }
 
 }
 
-void
-mps_commune (int x, int y)
+void mps_commune(int x, int y)
 {
     int i = 0;
-    const char * p;
+    const char *p;
 
-    mps_store_title(i++,_(&quot;Commune&quot;));
+    mps_store_title(i++, _(&quot;Commune&quot;));
     i++;
     i++;
-    mps_store_title(i++,_(&quot;Activity&quot;));
+    mps_store_title(i++, _(&quot;Activity&quot;));
     i++;
-    p = (MP_INFO(x,y).int_5 &amp; 1) ? _(&quot;Yes&quot;) : _(&quot;No&quot;);
-    mps_store_ss(i++,_(&quot;Coal&quot;),p);
-    p = (MP_INFO(x,y).int_5 &amp; 2) ? _(&quot;Yes&quot;) : _(&quot;No&quot;);
-    mps_store_ss(i++,_(&quot;Ore&quot;),p);
-    p = (MP_INFO(x,y).int_5 &amp; 4) ? _(&quot;Yes&quot;) : _(&quot;No&quot;);
-    mps_store_ss(i++,_(&quot;Steel&quot;),p);
-    p = (MP_INFO(x,y).int_5 &amp; 8) ? _(&quot;Yes&quot;) : _(&quot;No&quot;);
-    mps_store_ss(i++,_(&quot;Waste&quot;),p);
+    p = (MP_INFO(x, y).int_5 &amp; 1) ? _(&quot;Yes&quot;) : _(&quot;No&quot;);
+    mps_store_ss(i++, _(&quot;Coal&quot;), p);
+    p = (MP_INFO(x, y).int_5 &amp; 2) ? _(&quot;Yes&quot;) : _(&quot;No&quot;);
+    mps_store_ss(i++, _(&quot;Ore&quot;), p);
+    p = (MP_INFO(x, y).int_5 &amp; 4) ? _(&quot;Yes&quot;) : _(&quot;No&quot;);
+    mps_store_ss(i++, _(&quot;Steel&quot;), p);
+    p = (MP_INFO(x, y).int_5 &amp; 8) ? _(&quot;Yes&quot;) : _(&quot;No&quot;);
+    mps_store_ss(i++, _(&quot;Waste&quot;), p);
 }

Modified: trunk/src/lincity/modules/commune.h
===================================================================
--- trunk/src/lincity/modules/commune.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/commune.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -9,6 +9,6 @@
 #define __commune_h__
 
 void do_commune(int x, int y);
-void mps_commune (int x, int y);
+void mps_commune(int x, int y);
 
 #endif /* __commune_h__ */

Modified: trunk/src/lincity/modules/cricket.cpp
===================================================================
--- trunk/src/lincity/modules/cricket.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/cricket.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -8,100 +8,90 @@
 #include &quot;modules.h&quot;
 #include &quot;cricket.h&quot;
 
-void
-do_cricket (int x, int y)
+void do_cricket(int x, int y)
 {
-  /*
-     // int_1 is the jobs stored at the pavillion
-     // int_2 is the goods stored at the pavillion
-     // int_3 is the animation flag
-     // int_4 is the time of the next frame
-   */
-  if (MP_INFO(x,y).int_1
-      &lt; (MAX_JOBS_AT_CRICKET - CRICKET_GET_JOBS))
-    if (get_jobs (x, y, CRICKET_GET_JOBS) != 0)
-      MP_INFO(x,y).int_1 += CRICKET_GET_JOBS;
-  if (MP_INFO(x,y).int_2
-      &lt; (MAX_GOODS_AT_CRICKET - CRICKET_GET_GOODS))
-    if (get_goods (x, y, CRICKET_GET_GOODS) != 0)
-      MP_INFO(x,y).int_2 += CRICKET_GET_GOODS;
-  /* animate */
-  if (MP_INFO(x,y).int_3 &amp;&amp; real_time &gt; MP_INFO(x,y).int_4)
-    {
-      MP_INFO(x,y).int_4 = real_time + CRICKET_ANIMATION_SPEED;
-      switch (MP_TYPE(x,y))
-	{
-	case (CST_CRICKET_1):
-	  MP_TYPE(x,y) = CST_CRICKET_2;
-	  break;
-	case (CST_CRICKET_2):
-	  MP_TYPE(x,y) = CST_CRICKET_3;
-	  break;
-	case (CST_CRICKET_3):
-	  MP_TYPE(x,y) = CST_CRICKET_4;
-	  break;
-	case (CST_CRICKET_4):
-	  MP_TYPE(x,y) = CST_CRICKET_5;
-	  break;
-	case (CST_CRICKET_5):
-	  MP_TYPE(x,y) = CST_CRICKET_6;
-	  break;
-	case (CST_CRICKET_6):
-	  MP_TYPE(x,y) = CST_CRICKET_7;
-	  break;
-	case (CST_CRICKET_7):
-	  MP_TYPE(x,y) = CST_CRICKET_1;
-	  MP_INFO(x,y).int_3 = 0;	/* disable anim */
+    /*
+       // int_1 is the jobs stored at the pavillion
+       // int_2 is the goods stored at the pavillion
+       // int_3 is the animation flag
+       // int_4 is the time of the next frame
+     */
+    if (MP_INFO(x, y).int_1 &lt; (MAX_JOBS_AT_CRICKET - CRICKET_GET_JOBS))
+        if (get_jobs(x, y, CRICKET_GET_JOBS) != 0)
+            MP_INFO(x, y).int_1 += CRICKET_GET_JOBS;
+    if (MP_INFO(x, y).int_2 &lt; (MAX_GOODS_AT_CRICKET - CRICKET_GET_GOODS))
+        if (get_goods(x, y, CRICKET_GET_GOODS) != 0)
+            MP_INFO(x, y).int_2 += CRICKET_GET_GOODS;
+    /* animate */
+    if (MP_INFO(x, y).int_3 &amp;&amp; real_time &gt; MP_INFO(x, y).int_4) {
+        MP_INFO(x, y).int_4 = real_time + CRICKET_ANIMATION_SPEED;
+        switch (MP_TYPE(x, y)) {
+        case (CST_CRICKET_1):
+            MP_TYPE(x, y) = CST_CRICKET_2;
+            break;
+        case (CST_CRICKET_2):
+            MP_TYPE(x, y) = CST_CRICKET_3;
+            break;
+        case (CST_CRICKET_3):
+            MP_TYPE(x, y) = CST_CRICKET_4;
+            break;
+        case (CST_CRICKET_4):
+            MP_TYPE(x, y) = CST_CRICKET_5;
+            break;
+        case (CST_CRICKET_5):
+            MP_TYPE(x, y) = CST_CRICKET_6;
+            break;
+        case (CST_CRICKET_6):
+            MP_TYPE(x, y) = CST_CRICKET_7;
+            break;
+        case (CST_CRICKET_7):
+            MP_TYPE(x, y) = CST_CRICKET_1;
+            MP_INFO(x, y).int_3 = 0;    /* disable anim */
 
-	  break;
-	}
+            break;
+        }
     }
 
-  /* That's all. Cover is done by different functions every 3 months or so. */
+    /* That's all. Cover is done by different functions every 3 months or so. */
 
-  cricket_cost += CRICKET_RUNNING_COST;
+    cricket_cost += CRICKET_RUNNING_COST;
 }
 
-
-void
-do_cricket_cover (int x, int y)
+void do_cricket_cover(int x, int y)
 {
-  int xx, x1, x2, y1, y2;
-  if (MP_INFO(x,y).int_1 &lt; (CRICKET_JOBS * DAYS_BETWEEN_COVER) ||
-      MP_INFO(x,y).int_2 &lt; (CRICKET_GOODS * DAYS_BETWEEN_COVER))
-    return;
-  MP_INFO(x,y).int_1 -= (CRICKET_JOBS * DAYS_BETWEEN_COVER);
-  MP_INFO(x,y).int_2 -= (CRICKET_GOODS * DAYS_BETWEEN_COVER);
-  MP_INFO(x,y).int_3 = 1;	/* turn on animation */
+    int xx, x1, x2, y1, y2;
+    if (MP_INFO(x, y).int_1 &lt; (CRICKET_JOBS * DAYS_BETWEEN_COVER) ||
+        MP_INFO(x, y).int_2 &lt; (CRICKET_GOODS * DAYS_BETWEEN_COVER))
+        return;
+    MP_INFO(x, y).int_1 -= (CRICKET_JOBS * DAYS_BETWEEN_COVER);
+    MP_INFO(x, y).int_2 -= (CRICKET_GOODS * DAYS_BETWEEN_COVER);
+    MP_INFO(x, y).int_3 = 1;    /* turn on animation */
 
-  x1 = x - CRICKET_RANGE;
-  if (x1 &lt; 0)
-    x1 = 0;
-  x2 = x + CRICKET_RANGE;
-  if (x2 &gt; WORLD_SIDE_LEN)
-    x2 = WORLD_SIDE_LEN;
-  y1 = y - CRICKET_RANGE;
-  if (y1 &lt; 0)
-    y1 = 0;
-  y2 = y + CRICKET_RANGE;
-  if (y2 &gt; WORLD_SIDE_LEN)
-    y2 = WORLD_SIDE_LEN;
-  for (; y1 &lt; y2; y1++)
-    for (xx = x1; xx &lt; x2; xx++)
-      MP_INFO(xx,y1).flags |= FLAG_CRICKET_COVER;
+    x1 = x - CRICKET_RANGE;
+    if (x1 &lt; 0)
+        x1 = 0;
+    x2 = x + CRICKET_RANGE;
+    if (x2 &gt; WORLD_SIDE_LEN)
+        x2 = WORLD_SIDE_LEN;
+    y1 = y - CRICKET_RANGE;
+    if (y1 &lt; 0)
+        y1 = 0;
+    y2 = y + CRICKET_RANGE;
+    if (y2 &gt; WORLD_SIDE_LEN)
+        y2 = WORLD_SIDE_LEN;
+    for (; y1 &lt; y2; y1++)
+        for (xx = x1; xx &lt; x2; xx++)
+            MP_INFO(xx, y1).flags |= FLAG_CRICKET_COVER;
 }
 
-void
-mps_cricket (int x, int y)
+void mps_cricket(int x, int y)
 {
     int i = 0;
 
-    mps_store_title(i++,_(&quot;Sports field&quot;));
+    mps_store_title(i++, _(&quot;Sports field&quot;));
     i++;
-    mps_store_title(i++,_(&quot;Inventory&quot;));
-    mps_store_sfp(i++,_(&quot;Jobs&quot;),
-		  MP_INFO(x,y).int_1 * 100.0 / MAX_JOBS_AT_CRICKET);
-    mps_store_sfp(i++,_(&quot;Goods&quot;),
-		  MP_INFO(x,y).int_2 * 100.0 / MAX_GOODS_AT_CRICKET);
+    mps_store_title(i++, _(&quot;Inventory&quot;));
+    mps_store_sfp(i++, _(&quot;Jobs&quot;), MP_INFO(x, y).int_1 * 100.0 / MAX_JOBS_AT_CRICKET);
+    mps_store_sfp(i++, _(&quot;Goods&quot;), MP_INFO(x, y).int_2 * 100.0 / MAX_GOODS_AT_CRICKET);
 
 }

Modified: trunk/src/lincity/modules/cricket.h
===================================================================
--- trunk/src/lincity/modules/cricket.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/cricket.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -10,6 +10,6 @@
 
 void do_cricket(int x, int y);
 void do_cricket_cover(int x, int y);
-void mps_cricket (int x, int y);
+void mps_cricket(int x, int y);
 
 #endif /* __cricket_h__ */

Modified: trunk/src/lincity/modules/fire.cpp
===================================================================
--- trunk/src/lincity/modules/fire.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/fire.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -9,81 +9,74 @@
 #include &quot;fire.h&quot;
 #include &lt;stdlib.h&gt;
 
-void
-do_fire (int x, int y)
+void do_fire(int x, int y)
 {
-  /*
-    // int_1 is the next animation frame time
-    // int_2 is the fire length
-    // int_3 is the real_time before the fire can spread or -1 if triggered 
-    // int_4 is the idle land length
-  */
-  int i;
-  /* this so we don't get whole blocks changing in one go. */
-  if (MP_INFO(x,y).int_2 == 0)
+    /*
+       // int_1 is the next animation frame time
+       // int_2 is the fire length
+       // int_3 is the real_time before the fire can spread or -1 if triggered 
+       // int_4 is the idle land length
+     */
+    int i;
+    /* this so we don't get whole blocks changing in one go. */
+    if (MP_INFO(x, y).int_2 == 0)
 
-    MP_INFO(x,y).int_2 = rand () % (FIRE_LENGTH / 5);
-  if (MP_INFO(x,y).int_2 &gt; FIRE_LENGTH)
-    {
-      if (MP_INFO(x,y).int_4 == 0)	/* rand length here also */
-	MP_INFO(x,y).int_4 = rand () % (AFTER_FIRE_LENGTH / 6);
-      MP_INFO(x,y).int_4++;
-      if (MP_INFO(x,y).int_4 &gt; AFTER_FIRE_LENGTH)
-          if (use_waterwell) {
-              do_bulldoze_area (CST_DESERT, x, y);
-          } else {
-              do_bulldoze_area (CST_GREEN, x, y);
-          }
-      else if (MP_INFO(x,y).int_4 &gt; (3 * AFTER_FIRE_LENGTH) / 4)
-	MP_TYPE(x,y) = CST_FIRE_DONE4;
-      else if (MP_INFO(x,y).int_4 &gt; (2 * AFTER_FIRE_LENGTH) / 4)
-	MP_TYPE(x,y) = CST_FIRE_DONE3;
-      else if (MP_INFO(x,y).int_4 &gt; (AFTER_FIRE_LENGTH) / 4)
-	MP_TYPE(x,y) = CST_FIRE_DONE2;
-      else
-	MP_TYPE(x,y) = CST_FIRE_DONE1;
-      return;
+        MP_INFO(x, y).int_2 = rand() % (FIRE_LENGTH / 5);
+    if (MP_INFO(x, y).int_2 &gt; FIRE_LENGTH) {
+        if (MP_INFO(x, y).int_4 == 0)   /* rand length here also */
+            MP_INFO(x, y).int_4 = rand() % (AFTER_FIRE_LENGTH / 6);
+        MP_INFO(x, y).int_4++;
+        if (MP_INFO(x, y).int_4 &gt; AFTER_FIRE_LENGTH)
+            if (use_waterwell) {
+                do_bulldoze_area(CST_DESERT, x, y);
+            } else {
+                do_bulldoze_area(CST_GREEN, x, y);
+        } else if (MP_INFO(x, y).int_4 &gt; (3 * AFTER_FIRE_LENGTH) / 4)
+            MP_TYPE(x, y) = CST_FIRE_DONE4;
+        else if (MP_INFO(x, y).int_4 &gt; (2 * AFTER_FIRE_LENGTH) / 4)
+            MP_TYPE(x, y) = CST_FIRE_DONE3;
+        else if (MP_INFO(x, y).int_4 &gt; (AFTER_FIRE_LENGTH) / 4)
+            MP_TYPE(x, y) = CST_FIRE_DONE2;
+        else
+            MP_TYPE(x, y) = CST_FIRE_DONE1;
+        return;
     }
-  MP_INFO(x,y).int_2++;
-  if (real_time &gt; MP_INFO(x,y).int_1)
-    {
-      MP_INFO(x,y).int_1 = real_time + FIRE_ANIMATION_SPEED;
-      if (MP_TYPE(x,y) == CST_FIRE_1)
-	MP_TYPE(x,y) = CST_FIRE_2;
-      else if (MP_TYPE(x,y) == CST_FIRE_2)
-	MP_TYPE(x,y) = CST_FIRE_3;
-      else if (MP_TYPE(x,y) == CST_FIRE_3)
-	MP_TYPE(x,y) = CST_FIRE_4;
-      else if (MP_TYPE(x,y) == CST_FIRE_4)
-	MP_TYPE(x,y) = CST_FIRE_5;
-      else if (MP_TYPE(x,y) == CST_FIRE_5)
-	MP_TYPE(x,y) = CST_FIRE_1;
+    MP_INFO(x, y).int_2++;
+    if (real_time &gt; MP_INFO(x, y).int_1) {
+        MP_INFO(x, y).int_1 = real_time + FIRE_ANIMATION_SPEED;
+        if (MP_TYPE(x, y) == CST_FIRE_1)
+            MP_TYPE(x, y) = CST_FIRE_2;
+        else if (MP_TYPE(x, y) == CST_FIRE_2)
+            MP_TYPE(x, y) = CST_FIRE_3;
+        else if (MP_TYPE(x, y) == CST_FIRE_3)
+            MP_TYPE(x, y) = CST_FIRE_4;
+        else if (MP_TYPE(x, y) == CST_FIRE_4)
+            MP_TYPE(x, y) = CST_FIRE_5;
+        else if (MP_TYPE(x, y) == CST_FIRE_5)
+            MP_TYPE(x, y) = CST_FIRE_1;
     }
-  if (MP_INFO(x,y).int_3 == -1)
-    {
-      if ((rand () % FIRE_DAYS_PER_SPREAD) == 1)
-	{
-	  i = rand () % 4;
-	  switch (i)
-	    {
-	    case (0):
-	      do_random_fire (x - 1, y, 0);
-	      break;
-	    case (1):
-	      do_random_fire (x, y - 1, 0);
-	      break;
-	    case (2):
-	      do_random_fire (x + 1, y, 0);
-	      break;
-	    case (3):
-	      do_random_fire (x, y + 1, 0);
-	      break;
-	    }
-	}
+    if (MP_INFO(x, y).int_3 == -1) {
+        if ((rand() % FIRE_DAYS_PER_SPREAD) == 1) {
+            i = rand() % 4;
+            switch (i) {
+            case (0):
+                do_random_fire(x - 1, y, 0);
+                break;
+            case (1):
+                do_random_fire(x, y - 1, 0);
+                break;
+            case (2):
+                do_random_fire(x + 1, y, 0);
+                break;
+            case (3):
+                do_random_fire(x, y + 1, 0);
+                break;
+            }
+        }
     }
-  /* check here 'cos we can wait in the ok box for ever. */
-  else if (MP_INFO(x,y).int_3 == 0)
-    MP_INFO(x,y).int_3 = real_time + 15000;	/* 15 secs seem fair */
-  else if (real_time &gt;= MP_INFO(x,y).int_3)
-    MP_INFO(x,y).int_3 = -1;
+    /* check here 'cos we can wait in the ok box for ever. */
+    else if (MP_INFO(x, y).int_3 == 0)
+        MP_INFO(x, y).int_3 = real_time + 15000;        /* 15 secs seem fair */
+    else if (real_time &gt;= MP_INFO(x, y).int_3)
+        MP_INFO(x, y).int_3 = -1;
 }

Modified: trunk/src/lincity/modules/firestation.cpp
===================================================================
--- trunk/src/lincity/modules/firestation.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/firestation.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -8,120 +8,107 @@
 #include &quot;modules.h&quot;
 #include &quot;firestation.h&quot;
 
-
-void
-do_firestation (int x, int y)
+void do_firestation(int x, int y)
 {
-  /*
-     // int_1 is the jobs stored at the fire station
-     // int_2 is the goods stored at the fire station
-     // int_3 is the animation flag
-     // int_4 is the time of the next frame
-     // int_5 is the pause counter
-   */
+    /*
+       // int_1 is the jobs stored at the fire station
+       // int_2 is the goods stored at the fire station
+       // int_3 is the animation flag
+       // int_4 is the time of the next frame
+       // int_5 is the pause counter
+     */
     /* XXX: should note whether we actually _produced_ fire cover in int_6 */
-  if (MP_INFO(x,y).int_1
-      &lt; (MAX_JOBS_AT_FIRESTATION - FIRESTATION_GET_JOBS))
-    if (get_jobs (x, y, FIRESTATION_GET_JOBS) != 0)
-      MP_INFO(x,y).int_1 += FIRESTATION_GET_JOBS;
-  if (MP_INFO(x,y).int_2
-      &lt; (MAX_GOODS_AT_FIRESTATION - FIRESTATION_GET_GOODS))
-    if (get_goods (x, y, FIRESTATION_GET_GOODS) != 0)
-      MP_INFO(x,y).int_2 += FIRESTATION_GET_GOODS;
-  /* animate */
-  if (MP_INFO(x,y).int_3 &amp;&amp; real_time &gt; MP_INFO(x,y).int_4)
-    {
-      MP_INFO(x,y).int_4 = real_time + FIRESTATION_ANIMATION_SPEED;
-      if (MP_INFO(x,y).int_5 &gt; 0)
-	MP_INFO(x,y).int_5--;
-      else
-	{
-	  switch (MP_TYPE(x,y))
-	    {
-	    case (CST_FIRESTATION_1):
-	      MP_TYPE(x,y) = CST_FIRESTATION_2;
-	      break;
-	    case (CST_FIRESTATION_2):
-	      MP_TYPE(x,y) = CST_FIRESTATION_3;
-	      break;
-	    case (CST_FIRESTATION_3):
-	      MP_TYPE(x,y) = CST_FIRESTATION_4;
-	      break;
-	    case (CST_FIRESTATION_4):
-	      MP_TYPE(x,y) = CST_FIRESTATION_5;
-	      break;
-	    case (CST_FIRESTATION_5):
-	      MP_TYPE(x,y) = CST_FIRESTATION_6;
-	      break;
-	    case (CST_FIRESTATION_6):
-	      MP_TYPE(x,y) = CST_FIRESTATION_7;
-	      MP_INFO(x,y).int_5 = 10;	/* pause */
+    if (MP_INFO(x, y).int_1 &lt; (MAX_JOBS_AT_FIRESTATION - FIRESTATION_GET_JOBS))
+        if (get_jobs(x, y, FIRESTATION_GET_JOBS) != 0)
+            MP_INFO(x, y).int_1 += FIRESTATION_GET_JOBS;
+    if (MP_INFO(x, y).int_2 &lt; (MAX_GOODS_AT_FIRESTATION - FIRESTATION_GET_GOODS))
+        if (get_goods(x, y, FIRESTATION_GET_GOODS) != 0)
+            MP_INFO(x, y).int_2 += FIRESTATION_GET_GOODS;
+    /* animate */
+    if (MP_INFO(x, y).int_3 &amp;&amp; real_time &gt; MP_INFO(x, y).int_4) {
+        MP_INFO(x, y).int_4 = real_time + FIRESTATION_ANIMATION_SPEED;
+        if (MP_INFO(x, y).int_5 &gt; 0)
+            MP_INFO(x, y).int_5--;
+        else {
+            switch (MP_TYPE(x, y)) {
+            case (CST_FIRESTATION_1):
+                MP_TYPE(x, y) = CST_FIRESTATION_2;
+                break;
+            case (CST_FIRESTATION_2):
+                MP_TYPE(x, y) = CST_FIRESTATION_3;
+                break;
+            case (CST_FIRESTATION_3):
+                MP_TYPE(x, y) = CST_FIRESTATION_4;
+                break;
+            case (CST_FIRESTATION_4):
+                MP_TYPE(x, y) = CST_FIRESTATION_5;
+                break;
+            case (CST_FIRESTATION_5):
+                MP_TYPE(x, y) = CST_FIRESTATION_6;
+                break;
+            case (CST_FIRESTATION_6):
+                MP_TYPE(x, y) = CST_FIRESTATION_7;
+                MP_INFO(x, y).int_5 = 10;       /* pause */
 
-	      break;
-	    case (CST_FIRESTATION_7):
-	      MP_TYPE(x,y) = CST_FIRESTATION_8;
-	      break;
-	    case (CST_FIRESTATION_8):
-	      MP_TYPE(x,y) = CST_FIRESTATION_9;
-	      break;
-	    case (CST_FIRESTATION_9):
-	      MP_TYPE(x,y) = CST_FIRESTATION_10;
-	      break;
-	    case (CST_FIRESTATION_10):
-	      MP_TYPE(x,y) = CST_FIRESTATION_1;
-	      MP_INFO(x,y).int_3 = 0;		/* stop */
+                break;
+            case (CST_FIRESTATION_7):
+                MP_TYPE(x, y) = CST_FIRESTATION_8;
+                break;
+            case (CST_FIRESTATION_8):
+                MP_TYPE(x, y) = CST_FIRESTATION_9;
+                break;
+            case (CST_FIRESTATION_9):
+                MP_TYPE(x, y) = CST_FIRESTATION_10;
+                break;
+            case (CST_FIRESTATION_10):
+                MP_TYPE(x, y) = CST_FIRESTATION_1;
+                MP_INFO(x, y).int_3 = 0;        /* stop */
 
-	      break;
+                break;
 
-
-	    }
-	}
+            }
+        }
     }
-  /* That's all. Cover is done by different functions every 3 months or so. */
+    /* That's all. Cover is done by different functions every 3 months or so. */
 
-  fire_cost += FIRESTATION_RUNNING_COST;
+    fire_cost += FIRESTATION_RUNNING_COST;
 }
 
-
-void
-do_fire_cover (int x, int y)
+void do_fire_cover(int x, int y)
 {
-  int xx, x1, x2, y1, y2;
-  if (MP_INFO(x,y).int_1 &lt; (FIRESTATION_JOBS * DAYS_BETWEEN_COVER) ||
-      MP_INFO(x,y).int_2 &lt; (FIRESTATION_GOODS * DAYS_BETWEEN_COVER))
-    return;
-  MP_INFO(x,y).int_1 -= (FIRESTATION_JOBS * DAYS_BETWEEN_COVER);
-  MP_INFO(x,y).int_2 -= (FIRESTATION_GOODS * DAYS_BETWEEN_COVER);
-  MP_INFO(x,y).int_3 = 1;	/* turn on animation */
+    int xx, x1, x2, y1, y2;
+    if (MP_INFO(x, y).int_1 &lt; (FIRESTATION_JOBS * DAYS_BETWEEN_COVER) ||
+        MP_INFO(x, y).int_2 &lt; (FIRESTATION_GOODS * DAYS_BETWEEN_COVER))
+        return;
+    MP_INFO(x, y).int_1 -= (FIRESTATION_JOBS * DAYS_BETWEEN_COVER);
+    MP_INFO(x, y).int_2 -= (FIRESTATION_GOODS * DAYS_BETWEEN_COVER);
+    MP_INFO(x, y).int_3 = 1;    /* turn on animation */
 
-  x1 = x - FIRESTATION_RANGE;
-  if (x1 &lt; 0)
-    x1 = 0;
-  x2 = x + FIRESTATION_RANGE;
-  if (x2 &gt; WORLD_SIDE_LEN)
-    x2 = WORLD_SIDE_LEN;
-  y1 = y - FIRESTATION_RANGE;
-  if (y1 &lt; 0)
-    y1 = 0;
-  y2 = y + FIRESTATION_RANGE;
-  if (y2 &gt; WORLD_SIDE_LEN)
-    y2 = WORLD_SIDE_LEN;
-  for (; y1 &lt; y2; y1++)
-    for (xx = x1; xx &lt; x2; xx++)
-      MP_INFO(xx,y1).flags |= FLAG_FIRE_COVER;
+    x1 = x - FIRESTATION_RANGE;
+    if (x1 &lt; 0)
+        x1 = 0;
+    x2 = x + FIRESTATION_RANGE;
+    if (x2 &gt; WORLD_SIDE_LEN)
+        x2 = WORLD_SIDE_LEN;
+    y1 = y - FIRESTATION_RANGE;
+    if (y1 &lt; 0)
+        y1 = 0;
+    y2 = y + FIRESTATION_RANGE;
+    if (y2 &gt; WORLD_SIDE_LEN)
+        y2 = WORLD_SIDE_LEN;
+    for (; y1 &lt; y2; y1++)
+        for (xx = x1; xx &lt; x2; xx++)
+            MP_INFO(xx, y1).flags |= FLAG_FIRE_COVER;
 }
 
-void
-mps_firestation (int x, int y)
+void mps_firestation(int x, int y)
 {
     int i = 0;
 
-    mps_store_title(i++,_(&quot;Fire Station&quot;));
+    mps_store_title(i++, _(&quot;Fire Station&quot;));
     i++;
-    mps_store_title(i++,_(&quot;Inventory&quot;));
-    mps_store_sfp(i++,_(&quot;Jobs&quot;),
-		  MP_INFO(x,y).int_1 * 100.0 / MAX_JOBS_AT_FIRESTATION);
-    mps_store_sfp(i++,_(&quot;Goods&quot;),
-		  MP_INFO(x,y).int_2 * 100.0 / MAX_GOODS_AT_FIRESTATION);
+    mps_store_title(i++, _(&quot;Inventory&quot;));
+    mps_store_sfp(i++, _(&quot;Jobs&quot;), MP_INFO(x, y).int_1 * 100.0 / MAX_JOBS_AT_FIRESTATION);
+    mps_store_sfp(i++, _(&quot;Goods&quot;), MP_INFO(x, y).int_2 * 100.0 / MAX_GOODS_AT_FIRESTATION);
 
 }

Modified: trunk/src/lincity/modules/firestation.h
===================================================================
--- trunk/src/lincity/modules/firestation.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/firestation.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -10,6 +10,6 @@
 
 void do_firestation(int x, int y);
 void do_fire_cover(int x, int y);
-void mps_firestation (int x, int y);
+void mps_firestation(int x, int y);
 
 #endif /* __firestation_h__ */

Modified: trunk/src/lincity/modules/health_centre.cpp
===================================================================
--- trunk/src/lincity/modules/health_centre.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/health_centre.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -8,67 +8,57 @@
 #include &quot;modules.h&quot;
 #include &quot;health_centre.h&quot;
 
-
-void
-do_health_centre (int x, int y)
+void do_health_centre(int x, int y)
 {
-  /*
-     // int_1 is the jobs stored at the health centre
-     // int_2 is the goods stored at the health centre
-   */
-  if (MP_INFO(x,y).int_1
-      &lt; (MAX_JOBS_AT_HEALTH_CENTRE - HEALTH_CENTRE_GET_JOBS))
-    if (get_jobs (x, y, HEALTH_CENTRE_GET_JOBS) != 0)
-      MP_INFO(x,y).int_1 += HEALTH_CENTRE_GET_JOBS;
-  if (MP_INFO(x,y).int_2
-      &lt; (MAX_GOODS_AT_HEALTH_CENTRE - HEALTH_CENTRE_GET_GOODS))
-    if (get_goods (x, y, HEALTH_CENTRE_GET_GOODS) != 0)
-      MP_INFO(x,y).int_2 += HEALTH_CENTRE_GET_GOODS;
+    /*
+       // int_1 is the jobs stored at the health centre
+       // int_2 is the goods stored at the health centre
+     */
+    if (MP_INFO(x, y).int_1 &lt; (MAX_JOBS_AT_HEALTH_CENTRE - HEALTH_CENTRE_GET_JOBS))
+        if (get_jobs(x, y, HEALTH_CENTRE_GET_JOBS) != 0)
+            MP_INFO(x, y).int_1 += HEALTH_CENTRE_GET_JOBS;
+    if (MP_INFO(x, y).int_2 &lt; (MAX_GOODS_AT_HEALTH_CENTRE - HEALTH_CENTRE_GET_GOODS))
+        if (get_goods(x, y, HEALTH_CENTRE_GET_GOODS) != 0)
+            MP_INFO(x, y).int_2 += HEALTH_CENTRE_GET_GOODS;
 
-  /* That's all. Cover is done by different functions every 3 months or so. */
+    /* That's all. Cover is done by different functions every 3 months or so. */
 
-  health_cost += HEALTH_RUNNING_COST;
+    health_cost += HEALTH_RUNNING_COST;
 }
 
-
-void
-do_health_cover (int x, int y)
+void do_health_cover(int x, int y)
 {
-  int xx, x1, x2, y1, y2;
-  if (MP_INFO(x,y).int_1 &lt; (HEALTH_CENTRE_JOBS * DAYS_BETWEEN_COVER) ||
-      MP_INFO(x,y).int_2 &lt; (HEALTH_CENTRE_GOODS * DAYS_BETWEEN_COVER))
-    return;
-  MP_INFO(x,y).int_1 -= (HEALTH_CENTRE_JOBS * DAYS_BETWEEN_COVER);
-  MP_INFO(x,y).int_2 -= (HEALTH_CENTRE_GOODS * DAYS_BETWEEN_COVER);
-  x1 = x - HEALTH_CENTRE_RANGE;
-  if (x1 &lt; 0)
-    x1 = 0;
-  x2 = x + HEALTH_CENTRE_RANGE;
-  if (x2 &gt; WORLD_SIDE_LEN)
-    x2 = WORLD_SIDE_LEN;
-  y1 = y - HEALTH_CENTRE_RANGE;
-  if (y1 &lt; 0)
-    y1 = 0;
-  y2 = y + HEALTH_CENTRE_RANGE;
-  if (y2 &gt; WORLD_SIDE_LEN)
-    y2 = WORLD_SIDE_LEN;
-  for (; y1 &lt; y2; y1++)
-    for (xx = x1; xx &lt; x2; xx++)
-      MP_INFO(xx,y1).flags |= FLAG_HEALTH_COVER;
+    int xx, x1, x2, y1, y2;
+    if (MP_INFO(x, y).int_1 &lt; (HEALTH_CENTRE_JOBS * DAYS_BETWEEN_COVER) ||
+        MP_INFO(x, y).int_2 &lt; (HEALTH_CENTRE_GOODS * DAYS_BETWEEN_COVER))
+        return;
+    MP_INFO(x, y).int_1 -= (HEALTH_CENTRE_JOBS * DAYS_BETWEEN_COVER);
+    MP_INFO(x, y).int_2 -= (HEALTH_CENTRE_GOODS * DAYS_BETWEEN_COVER);
+    x1 = x - HEALTH_CENTRE_RANGE;
+    if (x1 &lt; 0)
+        x1 = 0;
+    x2 = x + HEALTH_CENTRE_RANGE;
+    if (x2 &gt; WORLD_SIDE_LEN)
+        x2 = WORLD_SIDE_LEN;
+    y1 = y - HEALTH_CENTRE_RANGE;
+    if (y1 &lt; 0)
+        y1 = 0;
+    y2 = y + HEALTH_CENTRE_RANGE;
+    if (y2 &gt; WORLD_SIDE_LEN)
+        y2 = WORLD_SIDE_LEN;
+    for (; y1 &lt; y2; y1++)
+        for (xx = x1; xx &lt; x2; xx++)
+            MP_INFO(xx, y1).flags |= FLAG_HEALTH_COVER;
 }
 
-
-void
-mps_health_centre (int x, int y)
+void mps_health_centre(int x, int y)
 {
     int i = 0;
 
-    mps_store_title(i++,_(&quot;Health Centre&quot;));
+    mps_store_title(i++, _(&quot;Health Centre&quot;));
     i++;
-    mps_store_title(i++,_(&quot;Inventory&quot;));
-    mps_store_sfp(i++,_(&quot;Jobs&quot;),
-		  MP_INFO(x,y).int_1 * 100.0 / MAX_JOBS_AT_HEALTH_CENTRE);
-    mps_store_sfp(i++,_(&quot;Goods&quot;),
-		  MP_INFO(x,y).int_2 * 100.0 / MAX_GOODS_AT_HEALTH_CENTRE);
+    mps_store_title(i++, _(&quot;Inventory&quot;));
+    mps_store_sfp(i++, _(&quot;Jobs&quot;), MP_INFO(x, y).int_1 * 100.0 / MAX_JOBS_AT_HEALTH_CENTRE);
+    mps_store_sfp(i++, _(&quot;Goods&quot;), MP_INFO(x, y).int_2 * 100.0 / MAX_GOODS_AT_HEALTH_CENTRE);
 
 }

Modified: trunk/src/lincity/modules/health_centre.h
===================================================================
--- trunk/src/lincity/modules/health_centre.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/health_centre.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -10,6 +10,6 @@
 
 void do_health_centre(int x, int y);
 void do_health_cover(int x, int y);
-void mps_health_centre (int x, int y);
+void mps_health_centre(int x, int y);
 
 #endif /* __health_centre_h__ */

Modified: trunk/src/lincity/modules/heavy_industry.cpp
===================================================================
--- trunk/src/lincity/modules/heavy_industry.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/heavy_industry.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -8,345 +8,282 @@
 #include &quot;modules.h&quot;
 #include &quot;heavy_industry.h&quot;
 
-
-void
-do_industry_h (int x, int y)
+void do_industry_h(int x, int y)
 {
-  int rawm, steel = 0;
-  /*
-     // int_1 is the steel produced this month so far
-     // int_2 is the amount of steel in store
-     // int_3 is the amount of raw materials in store (ore)
-     // int_4 is the coal in store
-     // int_5 is the percent max production last month
-     // int_6 is the time of the next animation frame.
-     // int_7 is whether we get power from coal (1) or elsewhere (0)
-   */
+    int rawm, steel = 0;
+    /*
+       // int_1 is the steel produced this month so far
+       // int_2 is the amount of steel in store
+       // int_3 is the amount of raw materials in store (ore)
+       // int_4 is the coal in store
+       // int_5 is the percent max production last month
+       // int_6 is the time of the next animation frame.
+       // int_7 is whether we get power from coal (1) or elsewhere (0)
+     */
 
-  /* See if there's any raw materials (ore) on the road/rail. If so, use some
-     jobs to get it.  First get some ore... 
-  */
-  int load;
-  if (MP_INFO(x,y).int_3 &lt; MAX_ORE_AT_INDUSTRY_H
-      &amp;&amp; ((MP_INFO(x - 1,y).flags &amp; FLAG_IS_TRANSPORT)
-	  != 0) &amp;&amp; MP_INFO(x - 1,y).int_5 &gt; 0)
-    if (get_jobs (x, y, JOBS_LOAD_ORE) != 0)
-      {
-        load = std::min(MAX_ORE_AT_INDUSTRY_H - MP_INFO(x,y).int_3,  
-            MP_INFO(x - 1,y).int_5 / 2 + ((MP_INFO(x - 1,y).int_5) % 2));
-	MP_INFO(x,y).int_3 += load;
-	MP_INFO(x - 1,y).int_5 -= load;
-      }
-  if (MP_INFO(x,y).int_3 &lt; MAX_ORE_AT_INDUSTRY_H
-      &amp;&amp; ((MP_INFO(x,y - 1).flags &amp; FLAG_IS_TRANSPORT)
-	  != 0) &amp;&amp; MP_INFO(x,y - 1).int_5 &gt; 0)
-    if (get_jobs (x, y, JOBS_LOAD_ORE) != 0)
-      {
-        load = std::min(MAX_ORE_AT_INDUSTRY_H - MP_INFO(x,y).int_3,  
-            MP_INFO(x,y - 1).int_5 / 2 + ((MP_INFO(x,y - 1).int_5) % 2));
-	MP_INFO(x,y).int_3 += load;
-	MP_INFO(x,y - 1).int_5 -= load;
-      }
-  /* then get some coal if needed */
-  if (MP_INFO(x,y).int_4 &lt; MAX_COAL_AT_INDUSTRY_H
-      &amp;&amp; ((MP_INFO(x - 1,y).flags &amp; FLAG_IS_TRANSPORT)
-	  != 0) &amp;&amp; MP_INFO(x - 1,y).int_3 &gt; 0)
-    if (get_jobs (x, y, JOBS_LOAD_COAL) != 0)
-      {
-        load = std::min(MAX_COAL_AT_INDUSTRY_H-MP_INFO(x,y).int_4,
-            MP_INFO(x - 1,y).int_3 / 2 + ((MP_INFO(x - 1,y).int_3) % 2));
-	MP_INFO(x,y).int_4 += load;
-	MP_INFO(x - 1,y).int_3 -= load;
-      }
-  if (MP_INFO(x,y).int_4 &lt; MAX_COAL_AT_INDUSTRY_H
-      &amp;&amp; ((MP_INFO(x,y - 1).flags &amp; FLAG_IS_TRANSPORT)
-	  != 0) &amp;&amp; MP_INFO(x,y - 1).int_3 &gt; 0)
-    if (get_jobs (x, y, JOBS_LOAD_COAL) != 0)
-      {
-        load = std::min(MAX_COAL_AT_INDUSTRY_H-MP_INFO(x,y).int_4,
-            MP_INFO(x,y - 1).int_3 / 2 + ((MP_INFO(x,y - 1).int_3) % 2));
-	MP_INFO(x,y).int_4 += load;
-	MP_INFO(x,y - 1).int_3 -= load;
-      }
+    /* See if there's any raw materials (ore) on the road/rail. If so, use some
+       jobs to get it.  First get some ore... 
+     */
+    int load;
+    if (MP_INFO(x, y).int_3 &lt; MAX_ORE_AT_INDUSTRY_H &amp;&amp; ((MP_INFO(x - 1, y).flags &amp; FLAG_IS_TRANSPORT)
+                                                        != 0) &amp;&amp; MP_INFO(x - 1, y).int_5 &gt; 0)
+        if (get_jobs(x, y, JOBS_LOAD_ORE) != 0) {
+            load = std::min(MAX_ORE_AT_INDUSTRY_H - MP_INFO(x, y).int_3,
+                            MP_INFO(x - 1, y).int_5 / 2 + ((MP_INFO(x - 1, y).int_5) % 2));
+            MP_INFO(x, y).int_3 += load;
+            MP_INFO(x - 1, y).int_5 -= load;
+        }
+    if (MP_INFO(x, y).int_3 &lt; MAX_ORE_AT_INDUSTRY_H &amp;&amp; ((MP_INFO(x, y - 1).flags &amp; FLAG_IS_TRANSPORT)
+                                                        != 0) &amp;&amp; MP_INFO(x, y - 1).int_5 &gt; 0)
+        if (get_jobs(x, y, JOBS_LOAD_ORE) != 0) {
+            load = std::min(MAX_ORE_AT_INDUSTRY_H - MP_INFO(x, y).int_3,
+                            MP_INFO(x, y - 1).int_5 / 2 + ((MP_INFO(x, y - 1).int_5) % 2));
+            MP_INFO(x, y).int_3 += load;
+            MP_INFO(x, y - 1).int_5 -= load;
+        }
+    /* then get some coal if needed */
+    if (MP_INFO(x, y).int_4 &lt; MAX_COAL_AT_INDUSTRY_H &amp;&amp; ((MP_INFO(x - 1, y).flags &amp; FLAG_IS_TRANSPORT)
+                                                         != 0) &amp;&amp; MP_INFO(x - 1, y).int_3 &gt; 0)
+        if (get_jobs(x, y, JOBS_LOAD_COAL) != 0) {
+            load = std::min(MAX_COAL_AT_INDUSTRY_H - MP_INFO(x, y).int_4,
+                            MP_INFO(x - 1, y).int_3 / 2 + ((MP_INFO(x - 1, y).int_3) % 2));
+            MP_INFO(x, y).int_4 += load;
+            MP_INFO(x - 1, y).int_3 -= load;
+        }
+    if (MP_INFO(x, y).int_4 &lt; MAX_COAL_AT_INDUSTRY_H &amp;&amp; ((MP_INFO(x, y - 1).flags &amp; FLAG_IS_TRANSPORT)
+                                                         != 0) &amp;&amp; MP_INFO(x, y - 1).int_3 &gt; 0)
+        if (get_jobs(x, y, JOBS_LOAD_COAL) != 0) {
+            load = std::min(MAX_COAL_AT_INDUSTRY_H - MP_INFO(x, y).int_4,
+                            MP_INFO(x, y - 1).int_3 / 2 + ((MP_INFO(x, y - 1).int_3) % 2));
+            MP_INFO(x, y).int_4 += load;
+            MP_INFO(x, y - 1).int_3 -= load;
+        }
 
-  rawm = MP_INFO(x,y).int_3;
-  if (rawm &gt; MAX_MADE_AT_INDUSTRY_H)
-    rawm = MAX_MADE_AT_INDUSTRY_H;
-  /* turn it into steel */
-  if (rawm &gt; 0 &amp;&amp; MP_INFO(x,y).int_2 &lt; (MAX_STEEL_ON_RAIL * 10))
-    {
-      if (get_jobs (x, y, ((rawm / 2) / JOBS_MAKE_STEEL) + 1) != 0)
-	{
-	  steel = (rawm) / ORE_MAKE_STEEL;
-	  MP_POL(x,y) += INDUSTRY_H_POLLUTION / 2;
-	}
-      else if (get_jobs (x, y, ((rawm / 4) / JOBS_MAKE_STEEL) + 1) != 0)
-	{
-	  steel = (rawm / 2) / ORE_MAKE_STEEL;
-	  MP_POL(x,y) += INDUSTRY_H_POLLUTION / 4;
-	}
-      else if (get_jobs (x, y, ((rawm / 10) / JOBS_MAKE_STEEL) + 1) != 0)
-	{
-	  steel = (rawm / 5) / ORE_MAKE_STEEL;
-	  MP_POL(x,y) += INDUSTRY_H_POLLUTION / 10;
-	}
+    rawm = MP_INFO(x, y).int_3;
+    if (rawm &gt; MAX_MADE_AT_INDUSTRY_H)
+        rawm = MAX_MADE_AT_INDUSTRY_H;
+    /* turn it into steel */
+    if (rawm &gt; 0 &amp;&amp; MP_INFO(x, y).int_2 &lt; (MAX_STEEL_ON_RAIL * 10)) {
+        if (get_jobs(x, y, ((rawm / 2) / JOBS_MAKE_STEEL) + 1) != 0) {
+            steel = (rawm) / ORE_MAKE_STEEL;
+            MP_POL(x, y) += INDUSTRY_H_POLLUTION / 2;
+        } else if (get_jobs(x, y, ((rawm / 4) / JOBS_MAKE_STEEL) + 1) != 0) {
+            steel = (rawm / 2) / ORE_MAKE_STEEL;
+            MP_POL(x, y) += INDUSTRY_H_POLLUTION / 4;
+        } else if (get_jobs(x, y, ((rawm / 10) / JOBS_MAKE_STEEL) + 1) != 0) {
+            steel = (rawm / 5) / ORE_MAKE_STEEL;
+            MP_POL(x, y) += INDUSTRY_H_POLLUTION / 10;
+        }
     }
-  /* do this here rather than later 'cos maybe steel/=5 */
-  MP_INFO(x,y).int_3 -= steel * ORE_MAKE_STEEL;
-  ore_used += steel * ORE_MAKE_STEEL;
-  /* check there was enough electricity, or back up to 1/10 of the 
-     production. ie same work and material useage for less production. 
-     XXX: there is no reason material usage should be the same 
-     If no real power, see if we have enough coal to generate electricity.
-  */
-  if (get_power (x, y, steel * POWER_MAKE_STEEL, 1) == 0)
-    {
-      if (MP_INFO(x,y).int_4 &lt; (steel * 2))
-	{
-	  MP_INFO(x,y).flags &amp;= (0xffffffff - FLAG_POWERED);
-	  steel /= 5;
-	}
-      else
-	{
-	  MP_INFO(x,y).int_4 -= (steel * 2);
-	  coal_used += (steel * 2);
-	  MP_INFO(x,y).flags |= FLAG_POWERED;
-	  MP_INFO(x,y).int_7 = 1;
-	}
+    /* do this here rather than later 'cos maybe steel/=5 */
+    MP_INFO(x, y).int_3 -= steel * ORE_MAKE_STEEL;
+    ore_used += steel * ORE_MAKE_STEEL;
+    /* check there was enough electricity, or back up to 1/10 of the 
+       production. ie same work and material useage for less production. 
+       XXX: there is no reason material usage should be the same 
+       If no real power, see if we have enough coal to generate electricity.
+     */
+    if (get_power(x, y, steel * POWER_MAKE_STEEL, 1) == 0) {
+        if (MP_INFO(x, y).int_4 &lt; (steel * 2)) {
+            MP_INFO(x, y).flags &amp;= (0xffffffff - FLAG_POWERED);
+            steel /= 5;
+        } else {
+            MP_INFO(x, y).int_4 -= (steel * 2);
+            coal_used += (steel * 2);
+            MP_INFO(x, y).flags |= FLAG_POWERED;
+            MP_INFO(x, y).int_7 = 1;
+        }
+    } else {
+        MP_INFO(x, y).flags |= FLAG_POWERED;
+        MP_INFO(x, y).int_7 = 0;
     }
-  else 
-    {
-      MP_INFO(x,y).flags |= FLAG_POWERED;
-      MP_INFO(x,y).int_7 = 0;
+    MP_INFO(x, y).int_1 += steel;
+    MP_INFO(x, y).int_2 += steel;
+    /* now sell the steel to the road/rail */
+    if (MP_GROUP(x, y - 1) == GROUP_ROAD &amp;&amp; (MAX_STEEL_ON_ROAD - MP_INFO(x, y - 1).int_6)
+        &lt;= MP_INFO(x, y).int_2) {
+        MP_INFO(x, y).int_2 -= (MAX_STEEL_ON_ROAD - MP_INFO(x, y - 1).int_6);
+        MP_INFO(x, y - 1).int_6 = MAX_STEEL_ON_ROAD;
+    } else if (MP_GROUP(x, y - 1) == GROUP_RAIL &amp;&amp; (MAX_STEEL_ON_RAIL - MP_INFO(x, y - 1).int_6)
+               &lt;= MP_INFO(x, y).int_2) {
+        MP_INFO(x, y).int_2 -= (MAX_STEEL_ON_RAIL - MP_INFO(x, y - 1).int_6);
+        MP_INFO(x, y - 1).int_6 = MAX_STEEL_ON_RAIL;
+    } else if (MP_GROUP(x, y - 1) == GROUP_TRACK &amp;&amp; (MAX_STEEL_ON_TRACK - MP_INFO(x, y - 1).int_6)
+               &lt;= MP_INFO(x, y).int_2) {
+        MP_INFO(x, y).int_2 -= (MAX_STEEL_ON_TRACK - MP_INFO(x, y - 1).int_6);
+        MP_INFO(x, y - 1).int_6 = MAX_STEEL_ON_TRACK;
     }
-  MP_INFO(x,y).int_1 += steel;
-  MP_INFO(x,y).int_2 += steel;
-  /* now sell the steel to the road/rail */
-  if (MP_GROUP(x,y-1) == GROUP_ROAD 
-      &amp;&amp; (MAX_STEEL_ON_ROAD - MP_INFO(x,y - 1).int_6)
-      &lt;= MP_INFO(x,y).int_2)
-    {
-      MP_INFO(x,y).int_2 -= (MAX_STEEL_ON_ROAD
-			       - MP_INFO(x,y - 1).int_6);
-      MP_INFO(x,y - 1).int_6 = MAX_STEEL_ON_ROAD;
-    }
-  else if (MP_GROUP(x,y - 1) == GROUP_RAIL 
-	   &amp;&amp; (MAX_STEEL_ON_RAIL - MP_INFO(x,y - 1).int_6)
-	   &lt;= MP_INFO(x,y).int_2)
-    {
-      MP_INFO(x,y).int_2 -= (MAX_STEEL_ON_RAIL
-			       - MP_INFO(x,y - 1).int_6);
-      MP_INFO(x,y - 1).int_6 = MAX_STEEL_ON_RAIL;
-    }
-  else if (MP_GROUP(x,y-1) == GROUP_TRACK 
-	   &amp;&amp; (MAX_STEEL_ON_TRACK - MP_INFO(x,y - 1).int_6)
-	   &lt;= MP_INFO(x,y).int_2)
-    {
-      MP_INFO(x,y).int_2 -= (MAX_STEEL_ON_TRACK
-			       - MP_INFO(x,y - 1).int_6);
-      MP_INFO(x,y - 1).int_6 = MAX_STEEL_ON_TRACK;
-    }
 
-  if (MP_GROUP(x-1,y) == GROUP_ROAD 
-      &amp;&amp; (MAX_STEEL_ON_ROAD - MP_INFO(x - 1,y).int_6)
-      &lt;= MP_INFO(x,y).int_2)
-    {
-      MP_INFO(x,y).int_2 -= (MAX_STEEL_ON_ROAD
-			       - MP_INFO(x - 1,y).int_6);
-      MP_INFO(x - 1,y).int_6 = MAX_STEEL_ON_ROAD;
+    if (MP_GROUP(x - 1, y) == GROUP_ROAD &amp;&amp; (MAX_STEEL_ON_ROAD - MP_INFO(x - 1, y).int_6)
+        &lt;= MP_INFO(x, y).int_2) {
+        MP_INFO(x, y).int_2 -= (MAX_STEEL_ON_ROAD - MP_INFO(x - 1, y).int_6);
+        MP_INFO(x - 1, y).int_6 = MAX_STEEL_ON_ROAD;
+    } else if (MP_GROUP(x - 1, y) == GROUP_RAIL &amp;&amp; (MAX_STEEL_ON_RAIL - MP_INFO(x - 1, y).int_6)
+               &lt;= MP_INFO(x, y).int_2) {
+        MP_INFO(x, y).int_2 -= (MAX_STEEL_ON_RAIL - MP_INFO(x - 1, y).int_6);
+        MP_INFO(x - 1, y).int_6 = MAX_STEEL_ON_RAIL;
+    } else if (MP_GROUP(x - 1, y) == GROUP_TRACK &amp;&amp; (MAX_STEEL_ON_TRACK - MP_INFO(x - 1, y).int_6)
+               &lt;= MP_INFO(x, y).int_2) {
+        MP_INFO(x, y).int_2 -= (MAX_STEEL_ON_TRACK - MP_INFO(x - 1, y).int_6);
+        MP_INFO(x - 1, y).int_6 = MAX_STEEL_ON_TRACK;
     }
-  else if (MP_GROUP(x-1,y) == GROUP_RAIL 
-	   &amp;&amp; (MAX_STEEL_ON_RAIL - MP_INFO(x - 1,y).int_6)
-	   &lt;= MP_INFO(x,y).int_2)
-    {
-      MP_INFO(x,y).int_2 -= (MAX_STEEL_ON_RAIL
-			       - MP_INFO(x - 1,y).int_6);
-      MP_INFO(x - 1,y).int_6 = MAX_STEEL_ON_RAIL;
-    }
-  else if (MP_GROUP(x - 1,y) == GROUP_TRACK 
-	   &amp;&amp; (MAX_STEEL_ON_TRACK - MP_INFO(x - 1,y).int_6)
-	   &lt;= MP_INFO(x,y).int_2)
-    {
-      MP_INFO(x,y).int_2 -= (MAX_STEEL_ON_TRACK
-			       - MP_INFO(x - 1,y).int_6);
-      MP_INFO(x - 1,y).int_6 = MAX_STEEL_ON_TRACK;
-    }
 
-
-  /* now choose a graphic every month */
-  if ((total_time % NUMOF_DAYS_IN_MONTH) == NUMOF_DAYS_IN_MONTH - 1)
-    {
-      MP_INFO(x,y).int_5 = MP_INFO(x,y).int_1
-	/ (MAX_MADE_AT_INDUSTRY_H / ORE_MAKE_STEEL);
-      MP_INFO(x,y).int_1 = 0;
-      if (MP_INFO(x,y).int_5 &gt; 80)
-	{
-	  switch (MP_TYPE(x,y))
-	    {
-	    case (CST_INDUSTRY_H_H1):
-	    case (CST_INDUSTRY_H_H2):
-	    case (CST_INDUSTRY_H_H3):
-	    case (CST_INDUSTRY_H_H4):
-	    case (CST_INDUSTRY_H_H5):
-	    case (CST_INDUSTRY_H_H6):
-	    case (CST_INDUSTRY_H_H7):
-	    case (CST_INDUSTRY_H_H8):
-	      break;
-	    default:
-	      MP_TYPE(x,y) = CST_INDUSTRY_H_H1;
-	    }
-	}
-      else if (MP_INFO(x,y).int_5 &gt; 30)
-	{
-	  switch (MP_TYPE(x,y))
-	    {
-	    case (CST_INDUSTRY_H_M1):
-	    case (CST_INDUSTRY_H_M2):
-	    case (CST_INDUSTRY_H_M3):
-	    case (CST_INDUSTRY_H_M4):
-	    case (CST_INDUSTRY_H_M5):
-	    case (CST_INDUSTRY_H_M6):
-	    case (CST_INDUSTRY_H_M7):
-	    case (CST_INDUSTRY_H_M8):
-	      break;
-	    default:
-	      MP_TYPE(x,y) = CST_INDUSTRY_H_M1;
-	    }
-	}
-      else if (MP_INFO(x,y).int_5 &gt; 0)
-	{
-	  switch (MP_TYPE(x,y))
-	    {
-	    case (CST_INDUSTRY_H_L1):
-	    case (CST_INDUSTRY_H_L2):
-	    case (CST_INDUSTRY_H_L3):
-	    case (CST_INDUSTRY_H_L4):
-	    case (CST_INDUSTRY_H_L5):
-	    case (CST_INDUSTRY_H_L6):
-	    case (CST_INDUSTRY_H_L7):
-	    case (CST_INDUSTRY_H_L8):
-	      break;
-	    default:
-	      MP_TYPE(x,y) = CST_INDUSTRY_H_L1;
-	    }
-	}
-      else
-	MP_TYPE(x,y) = CST_INDUSTRY_H_C;
+    /* now choose a graphic every month */
+    if ((total_time % NUMOF_DAYS_IN_MONTH) == NUMOF_DAYS_IN_MONTH - 1) {
+        MP_INFO(x, y).int_5 = MP_INFO(x, y).int_1 / (MAX_MADE_AT_INDUSTRY_H / ORE_MAKE_STEEL);
+        MP_INFO(x, y).int_1 = 0;
+        if (MP_INFO(x, y).int_5 &gt; 80) {
+            switch (MP_TYPE(x, y)) {
+            case (CST_INDUSTRY_H_H1):
+            case (CST_INDUSTRY_H_H2):
+            case (CST_INDUSTRY_H_H3):
+            case (CST_INDUSTRY_H_H4):
+            case (CST_INDUSTRY_H_H5):
+            case (CST_INDUSTRY_H_H6):
+            case (CST_INDUSTRY_H_H7):
+            case (CST_INDUSTRY_H_H8):
+                break;
+            default:
+                MP_TYPE(x, y) = CST_INDUSTRY_H_H1;
+            }
+        } else if (MP_INFO(x, y).int_5 &gt; 30) {
+            switch (MP_TYPE(x, y)) {
+            case (CST_INDUSTRY_H_M1):
+            case (CST_INDUSTRY_H_M2):
+            case (CST_INDUSTRY_H_M3):
+            case (CST_INDUSTRY_H_M4):
+            case (CST_INDUSTRY_H_M5):
+            case (CST_INDUSTRY_H_M6):
+            case (CST_INDUSTRY_H_M7):
+            case (CST_INDUSTRY_H_M8):
+                break;
+            default:
+                MP_TYPE(x, y) = CST_INDUSTRY_H_M1;
+            }
+        } else if (MP_INFO(x, y).int_5 &gt; 0) {
+            switch (MP_TYPE(x, y)) {
+            case (CST_INDUSTRY_H_L1):
+            case (CST_INDUSTRY_H_L2):
+            case (CST_INDUSTRY_H_L3):
+            case (CST_INDUSTRY_H_L4):
+            case (CST_INDUSTRY_H_L5):
+            case (CST_INDUSTRY_H_L6):
+            case (CST_INDUSTRY_H_L7):
+            case (CST_INDUSTRY_H_L8):
+                break;
+            default:
+                MP_TYPE(x, y) = CST_INDUSTRY_H_L1;
+            }
+        } else
+            MP_TYPE(x, y) = CST_INDUSTRY_H_C;
     }
-  /* now animate */
-  if (real_time &gt;= MP_INFO(x,y).int_6)
-    {
-      MP_INFO(x,y).int_6 = real_time + INDUSTRY_H_ANIM_SPEED;
-      switch (MP_TYPE(x,y))
-	{
-	case (CST_INDUSTRY_H_L1):
-	  MP_TYPE(x,y) = CST_INDUSTRY_H_L2;
-	  break;
-	case (CST_INDUSTRY_H_L2):
-	  MP_TYPE(x,y) = CST_INDUSTRY_H_L3;
-	  break;
-	case (CST_INDUSTRY_H_L3):
-	  MP_TYPE(x,y) = CST_INDUSTRY_H_L4;
-	  break;
-	case (CST_INDUSTRY_H_L4):
-	  MP_TYPE(x,y) = CST_INDUSTRY_H_L5;
-	  break;
-	case (CST_INDUSTRY_H_L5):
-	  MP_TYPE(x,y) = CST_INDUSTRY_H_L6;
-	  break;
-	case (CST_INDUSTRY_H_L6):
-	  MP_TYPE(x,y) = CST_INDUSTRY_H_L7;
-	  break;
-	case (CST_INDUSTRY_H_L7):
-	  MP_TYPE(x,y) = CST_INDUSTRY_H_L8;
-	  break;
-	case (CST_INDUSTRY_H_L8):
-	  MP_TYPE(x,y) = CST_INDUSTRY_H_L1;
-	  break;
+    /* now animate */
+    if (real_time &gt;= MP_INFO(x, y).int_6) {
+        MP_INFO(x, y).int_6 = real_time + INDUSTRY_H_ANIM_SPEED;
+        switch (MP_TYPE(x, y)) {
+        case (CST_INDUSTRY_H_L1):
+            MP_TYPE(x, y) = CST_INDUSTRY_H_L2;
+            break;
+        case (CST_INDUSTRY_H_L2):
+            MP_TYPE(x, y) = CST_INDUSTRY_H_L3;
+            break;
+        case (CST_INDUSTRY_H_L3):
+            MP_TYPE(x, y) = CST_INDUSTRY_H_L4;
+            break;
+        case (CST_INDUSTRY_H_L4):
+            MP_TYPE(x, y) = CST_INDUSTRY_H_L5;
+            break;
+        case (CST_INDUSTRY_H_L5):
+            MP_TYPE(x, y) = CST_INDUSTRY_H_L6;
+            break;
+        case (CST_INDUSTRY_H_L6):
+            MP_TYPE(x, y) = CST_INDUSTRY_H_L7;
+            break;
+        case (CST_INDUSTRY_H_L7):
+            MP_TYPE(x, y) = CST_INDUSTRY_H_L8;
+            break;
+        case (CST_INDUSTRY_H_L8):
+            MP_TYPE(x, y) = CST_INDUSTRY_H_L1;
+            break;
 
-	case (CST_INDUSTRY_H_M1):
-	  MP_TYPE(x,y) = CST_INDUSTRY_H_M2;
-	  break;
-	case (CST_INDUSTRY_H_M2):
-	  MP_TYPE(x,y) = CST_INDUSTRY_H_M3;
-	  break;
-	case (CST_INDUSTRY_H_M3):
-	  MP_TYPE(x,y) = CST_INDUSTRY_H_M4;
-	  break;
-	case (CST_INDUSTRY_H_M4):
-	  MP_TYPE(x,y) = CST_INDUSTRY_H_M5;
-	  break;
-	case (CST_INDUSTRY_H_M5):
-	  MP_TYPE(x,y) = CST_INDUSTRY_H_M6;
-	  break;
-	case (CST_INDUSTRY_H_M6):
-	  MP_TYPE(x,y) = CST_INDUSTRY_H_M7;
-	  break;
-	case (CST_INDUSTRY_H_M7):
-	  MP_TYPE(x,y) = CST_INDUSTRY_H_M8;
-	  break;
-	case (CST_INDUSTRY_H_M8):
-	  MP_TYPE(x,y) = CST_INDUSTRY_H_M1;
-	  break;
+        case (CST_INDUSTRY_H_M1):
+            MP_TYPE(x, y) = CST_INDUSTRY_H_M2;
+            break;
+        case (CST_INDUSTRY_H_M2):
+            MP_TYPE(x, y) = CST_INDUSTRY_H_M3;
+            break;
+        case (CST_INDUSTRY_H_M3):
+            MP_TYPE(x, y) = CST_INDUSTRY_H_M4;
+            break;
+        case (CST_INDUSTRY_H_M4):
+            MP_TYPE(x, y) = CST_INDUSTRY_H_M5;
+            break;
+        case (CST_INDUSTRY_H_M5):
+            MP_TYPE(x, y) = CST_INDUSTRY_H_M6;
+            break;
+        case (CST_INDUSTRY_H_M6):
+            MP_TYPE(x, y) = CST_INDUSTRY_H_M7;
+            break;
+        case (CST_INDUSTRY_H_M7):
+            MP_TYPE(x, y) = CST_INDUSTRY_H_M8;
+            break;
+        case (CST_INDUSTRY_H_M8):
+            MP_TYPE(x, y) = CST_INDUSTRY_H_M1;
+            break;
 
-	case (CST_INDUSTRY_H_H1):
-	  MP_TYPE(x,y) = CST_INDUSTRY_H_H2;
-	  break;
-	case (CST_INDUSTRY_H_H2):
-	  MP_TYPE(x,y) = CST_INDUSTRY_H_H3;
-	  break;
-	case (CST_INDUSTRY_H_H3):
-	  MP_TYPE(x,y) = CST_INDUSTRY_H_H4;
-	  break;
-	case (CST_INDUSTRY_H_H4):
-	  MP_TYPE(x,y) = CST_INDUSTRY_H_H5;
-	  break;
-	case (CST_INDUSTRY_H_H5):
-	  MP_TYPE(x,y) = CST_INDUSTRY_H_H6;
-	  break;
-	case (CST_INDUSTRY_H_H6):
-	  MP_TYPE(x,y) = CST_INDUSTRY_H_H7;
-	  break;
-	case (CST_INDUSTRY_H_H7):
-	  MP_TYPE(x,y) = CST_INDUSTRY_H_H8;
-	  break;
-	case (CST_INDUSTRY_H_H8):
-	  MP_TYPE(x,y) = CST_INDUSTRY_H_H1;
-	  break;
+        case (CST_INDUSTRY_H_H1):
+            MP_TYPE(x, y) = CST_INDUSTRY_H_H2;
+            break;
+        case (CST_INDUSTRY_H_H2):
+            MP_TYPE(x, y) = CST_INDUSTRY_H_H3;
+            break;
+        case (CST_INDUSTRY_H_H3):
+            MP_TYPE(x, y) = CST_INDUSTRY_H_H4;
+            break;
+        case (CST_INDUSTRY_H_H4):
+            MP_TYPE(x, y) = CST_INDUSTRY_H_H5;
+            break;
+        case (CST_INDUSTRY_H_H5):
+            MP_TYPE(x, y) = CST_INDUSTRY_H_H6;
+            break;
+        case (CST_INDUSTRY_H_H6):
+            MP_TYPE(x, y) = CST_INDUSTRY_H_H7;
+            break;
+        case (CST_INDUSTRY_H_H7):
+            MP_TYPE(x, y) = CST_INDUSTRY_H_H8;
+            break;
+        case (CST_INDUSTRY_H_H8):
+            MP_TYPE(x, y) = CST_INDUSTRY_H_H1;
+            break;
 
-	}
+        }
     }
 }
 
-
-void
-mps_heavy_industry (int x, int y)
+void mps_heavy_industry(int x, int y)
 {
     int i = 0;
-    const char * p;
-  
-    mps_store_title(i++,_(&quot;Heavy&quot;));
-    mps_store_title(i++,_(&quot;Industry&quot;));
+    const char *p;
+
+    mps_store_title(i++, _(&quot;Heavy&quot;));
+    mps_store_title(i++, _(&quot;Industry&quot;));
     i++;
 
-    if ((MP_INFO(x,y).flags &amp; FLAG_POWERED) != 0) {
-	if (MP_INFO(x,y).int_7 == 1) {
-	    p = _(&quot;Coal&quot;);
-	} else {
-	    p = _(&quot;Grid&quot;);
-	}
+    if ((MP_INFO(x, y).flags &amp; FLAG_POWERED) != 0) {
+        if (MP_INFO(x, y).int_7 == 1) {
+            p = _(&quot;Coal&quot;);
+        } else {
+            p = _(&quot;Grid&quot;);
+        }
     } else {
-	p = _(&quot;NO&quot;);
+        p = _(&quot;NO&quot;);
     }
 
-    mps_store_ss(i++,_(&quot;Power&quot;),p);
+    mps_store_ss(i++, _(&quot;Power&quot;), p);
 
-    mps_store_sd(i++,_(&quot;Output&quot;), MP_INFO(x,y).int_1);
-    mps_store_sfp(i++,_(&quot;Store&quot;), 
-		 MP_INFO(x,y).int_2 * 100.0 / MAX_STEEL_AT_INDUSTRY_H);
-    mps_store_sfp(i++,_(&quot;Ore&quot;), 
-		 MP_INFO(x,y).int_3 * 100.0 / MAX_ORE_AT_INDUSTRY_H);
-    mps_store_sfp(i++,_(&quot;Coal&quot;),
-		 MP_INFO(x,y).int_4 * 100.0 / MAX_COAL_AT_INDUSTRY_H);
-    mps_store_sfp(i++,_(&quot;Capacity&quot;), MP_INFO(x,y).int_5);
+    mps_store_sd(i++, _(&quot;Output&quot;), MP_INFO(x, y).int_1);
+    mps_store_sfp(i++, _(&quot;Store&quot;), MP_INFO(x, y).int_2 * 100.0 / MAX_STEEL_AT_INDUSTRY_H);
+    mps_store_sfp(i++, _(&quot;Ore&quot;), MP_INFO(x, y).int_3 * 100.0 / MAX_ORE_AT_INDUSTRY_H);
+    mps_store_sfp(i++, _(&quot;Coal&quot;), MP_INFO(x, y).int_4 * 100.0 / MAX_COAL_AT_INDUSTRY_H);
+    mps_store_sfp(i++, _(&quot;Capacity&quot;), MP_INFO(x, y).int_5);
 }

Modified: trunk/src/lincity/modules/light_industry.cpp
===================================================================
--- trunk/src/lincity/modules/light_industry.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/light_industry.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -8,365 +8,283 @@
 #include &quot;modules.h&quot;
 #include &quot;light_industry.h&quot;
 
-
-void
-do_industry_l (int x, int y)
+void do_industry_l(int x, int y)
 {
-  int goods = 0;
-  double tmp_pol;
-  /*
-     // int_1 is the goods produced this month so far
-     // int_2 is the amount of goods in store.
-     // int_3 is the amount of ore in store.
-     // int_4 is the amount of steel in store.
-     // int_5 is the jobs stored.
-     // int_6 is the percent of capacity last month.
-     // int 7 is the next animation frame time.
-   */
-  /* first get some jobs */
-  if (MP_INFO(x,y).int_5 &lt; MAX_JOBS_AT_INDUSTRY_L - INDUSTRY_L_GET_JOBS)
-    {
-      if (get_jobs (x, y, INDUSTRY_L_GET_JOBS) != 0)
-	MP_INFO(x,y).int_5 += INDUSTRY_L_GET_JOBS;
-      else if (get_jobs (x, y, INDUSTRY_L_GET_JOBS / 10) != 0)
-	MP_INFO(x,y).int_5 += INDUSTRY_L_GET_JOBS / 10;
+    int goods = 0;
+    double tmp_pol;
+    /*
+       // int_1 is the goods produced this month so far
+       // int_2 is the amount of goods in store.
+       // int_3 is the amount of ore in store.
+       // int_4 is the amount of steel in store.
+       // int_5 is the jobs stored.
+       // int_6 is the percent of capacity last month.
+       // int 7 is the next animation frame time.
+     */
+    /* first get some jobs */
+    if (MP_INFO(x, y).int_5 &lt; MAX_JOBS_AT_INDUSTRY_L - INDUSTRY_L_GET_JOBS) {
+        if (get_jobs(x, y, INDUSTRY_L_GET_JOBS) != 0)
+            MP_INFO(x, y).int_5 += INDUSTRY_L_GET_JOBS;
+        else if (get_jobs(x, y, INDUSTRY_L_GET_JOBS / 10) != 0)
+            MP_INFO(x, y).int_5 += INDUSTRY_L_GET_JOBS / 10;
     }
-  /* if we don't have enough jobs we can't do anything */
-  if (MP_INFO(x,y).int_5 &lt; MIN_JOBS_AT_INDUSTRY_L)
-    return;
-  /* get some ore */
-  if (MP_INFO(x,y).int_3 &lt; (MAX_ORE_AT_INDUSTRY_L
-			      - INDUSTRY_L_GET_ORE))
-    {
-      if ((MP_INFO(x - 1,y).flags &amp; FLAG_IS_TRANSPORT) != 0
-	  &amp;&amp; MP_INFO(x - 1,y).int_5 &gt; 0)
-	{
-	  if (MP_INFO(x - 1,y).int_5 &gt;= INDUSTRY_L_GET_ORE)
-	    {
-	      MP_INFO(x,y).int_3 += INDUSTRY_L_GET_ORE;
-	      MP_INFO(x - 1,y).int_5 -= INDUSTRY_L_GET_ORE;
-	    }
-	  else
-	    {
-	      MP_INFO(x,y).int_3 += MP_INFO(x - 1,y).int_5;
-	      MP_INFO(x - 1,y).int_5 = 0;
-	    }
-	  MP_INFO(x,y).int_5 -= INDUSTRY_L_JOBS_LOAD_ORE;
-	}
+    /* if we don't have enough jobs we can't do anything */
+    if (MP_INFO(x, y).int_5 &lt; MIN_JOBS_AT_INDUSTRY_L)
+        return;
+    /* get some ore */
+    if (MP_INFO(x, y).int_3 &lt; (MAX_ORE_AT_INDUSTRY_L - INDUSTRY_L_GET_ORE)) {
+        if ((MP_INFO(x - 1, y).flags &amp; FLAG_IS_TRANSPORT) != 0 &amp;&amp; MP_INFO(x - 1, y).int_5 &gt; 0) {
+            if (MP_INFO(x - 1, y).int_5 &gt;= INDUSTRY_L_GET_ORE) {
+                MP_INFO(x, y).int_3 += INDUSTRY_L_GET_ORE;
+                MP_INFO(x - 1, y).int_5 -= INDUSTRY_L_GET_ORE;
+            } else {
+                MP_INFO(x, y).int_3 += MP_INFO(x - 1, y).int_5;
+                MP_INFO(x - 1, y).int_5 = 0;
+            }
+            MP_INFO(x, y).int_5 -= INDUSTRY_L_JOBS_LOAD_ORE;
+        }
     }
-  /* do we still need some ore? */
-  if (MP_INFO(x,y).int_3 &lt; (MAX_ORE_AT_INDUSTRY_L
-			      - INDUSTRY_L_GET_ORE))
-    {
-      if ((MP_INFO(x,y - 1).flags &amp; FLAG_IS_TRANSPORT) != 0
-	  &amp;&amp; MP_INFO(x,y - 1).int_5 &gt; 0)
-	{
-	  if (MP_INFO(x,y - 1).int_5 &gt;= INDUSTRY_L_GET_ORE)
-	    {
-	      MP_INFO(x,y).int_3 += INDUSTRY_L_GET_ORE;
-	      MP_INFO(x,y - 1).int_5 -= INDUSTRY_L_GET_ORE;
-	    }
-	  else
-	    {
-	      MP_INFO(x,y).int_3 += MP_INFO(x,y - 1).int_5;
-	      MP_INFO(x,y - 1).int_5 = 0;
-	    }
-	  MP_INFO(x,y).int_5 -= INDUSTRY_L_JOBS_LOAD_ORE;
-	}
+    /* do we still need some ore? */
+    if (MP_INFO(x, y).int_3 &lt; (MAX_ORE_AT_INDUSTRY_L - INDUSTRY_L_GET_ORE)) {
+        if ((MP_INFO(x, y - 1).flags &amp; FLAG_IS_TRANSPORT) != 0 &amp;&amp; MP_INFO(x, y - 1).int_5 &gt; 0) {
+            if (MP_INFO(x, y - 1).int_5 &gt;= INDUSTRY_L_GET_ORE) {
+                MP_INFO(x, y).int_3 += INDUSTRY_L_GET_ORE;
+                MP_INFO(x, y - 1).int_5 -= INDUSTRY_L_GET_ORE;
+            } else {
+                MP_INFO(x, y).int_3 += MP_INFO(x, y - 1).int_5;
+                MP_INFO(x, y - 1).int_5 = 0;
+            }
+            MP_INFO(x, y).int_5 -= INDUSTRY_L_JOBS_LOAD_ORE;
+        }
     }
-  /* then get some steel */
-  if (MP_INFO(x,y).int_4 &lt; (MAX_STEEL_AT_INDUSTRY_L
-			      - INDUSTRY_L_GET_STEEL))
-    {
-      if ((MP_INFO(x - 1,y).flags &amp; FLAG_IS_TRANSPORT) != 0
-	  &amp;&amp; MP_INFO(x - 1,y).int_6 &gt; 0)
-	{
-	  if (MP_INFO(x - 1,y).int_6 &gt;= INDUSTRY_L_GET_STEEL)
-	    {
-	      MP_INFO(x,y).int_4 += INDUSTRY_L_GET_STEEL;
-	      MP_INFO(x - 1,y).int_6 -= INDUSTRY_L_GET_STEEL;
-	    }
-	  else
-	    {
-	      MP_INFO(x,y).int_4
-		+= MP_INFO(x - 1,y).int_6;
-	      MP_INFO(x - 1,y).int_6 = 0;
-	    }
-	  MP_INFO(x,y).int_5 -= INDUSTRY_L_JOBS_LOAD_STEEL;
-	}
+    /* then get some steel */
+    if (MP_INFO(x, y).int_4 &lt; (MAX_STEEL_AT_INDUSTRY_L - INDUSTRY_L_GET_STEEL)) {
+        if ((MP_INFO(x - 1, y).flags &amp; FLAG_IS_TRANSPORT) != 0 &amp;&amp; MP_INFO(x - 1, y).int_6 &gt; 0) {
+            if (MP_INFO(x - 1, y).int_6 &gt;= INDUSTRY_L_GET_STEEL) {
+                MP_INFO(x, y).int_4 += INDUSTRY_L_GET_STEEL;
+                MP_INFO(x - 1, y).int_6 -= INDUSTRY_L_GET_STEEL;
+            } else {
+                MP_INFO(x, y).int_4 += MP_INFO(x - 1, y).int_6;
+                MP_INFO(x - 1, y).int_6 = 0;
+            }
+            MP_INFO(x, y).int_5 -= INDUSTRY_L_JOBS_LOAD_STEEL;
+        }
     }
-  /* do we still need some steel? */
-  if (MP_INFO(x,y).int_4 &lt; (MAX_STEEL_AT_INDUSTRY_L
-			      - INDUSTRY_L_GET_STEEL))
-    {
-      if ((MP_INFO(x,y - 1).flags &amp; FLAG_IS_TRANSPORT) != 0
-	  &amp;&amp; MP_INFO(x,y - 1).int_6 &gt; 0)
-	{
-	  if (MP_INFO(x,y - 1).int_6 &gt;= INDUSTRY_L_GET_STEEL)
-	    {
-	      MP_INFO(x,y).int_4 += INDUSTRY_L_GET_STEEL;
-	      MP_INFO(x,y - 1).int_6 -= INDUSTRY_L_GET_STEEL;
-	    }
-	  else
-	    {
-	      MP_INFO(x,y).int_4
-		+= MP_INFO(x,y - 1).int_6;
-	      MP_INFO(x,y - 1).int_6 = 0;
-	    }
-	  MP_INFO(x,y).int_5 -= INDUSTRY_L_JOBS_LOAD_STEEL;
-	}
+    /* do we still need some steel? */
+    if (MP_INFO(x, y).int_4 &lt; (MAX_STEEL_AT_INDUSTRY_L - INDUSTRY_L_GET_STEEL)) {
+        if ((MP_INFO(x, y - 1).flags &amp; FLAG_IS_TRANSPORT) != 0 &amp;&amp; MP_INFO(x, y - 1).int_6 &gt; 0) {
+            if (MP_INFO(x, y - 1).int_6 &gt;= INDUSTRY_L_GET_STEEL) {
+                MP_INFO(x, y).int_4 += INDUSTRY_L_GET_STEEL;
+                MP_INFO(x, y - 1).int_6 -= INDUSTRY_L_GET_STEEL;
+            } else {
+                MP_INFO(x, y).int_4 += MP_INFO(x, y - 1).int_6;
+                MP_INFO(x, y - 1).int_6 = 0;
+            }
+            MP_INFO(x, y).int_5 -= INDUSTRY_L_JOBS_LOAD_STEEL;
+        }
     }
-  /* now make some goods if there is room in inventory*/
-  if (MP_INFO(x,y).int_2 &lt; (MAX_GOODS_AT_INDUSTRY_L
-		      - (INDUSTRY_L_MAKE_GOODS * 8)) &amp;&amp; MP_INFO(x,y).int_3
-      &gt;= INDUSTRY_L_ORE_USED)
-    {
-      goods += INDUSTRY_L_MAKE_GOODS;
-      MP_INFO(x,y).int_3 -= INDUSTRY_L_ORE_USED;
-      ore_used += INDUSTRY_L_ORE_USED;
-      MP_INFO(x,y).int_5 -= INDUSTRY_L_JOBS_USED;
-      /* Pollution is now determined by amount of goods made and affected by
-	 technology 
-	 MP_POL(x,y) += INDUSTRY_L_POLLUTION; */
+    /* now make some goods if there is room in inventory */
+    if (MP_INFO(x, y).int_2 &lt; (MAX_GOODS_AT_INDUSTRY_L
+                               - (INDUSTRY_L_MAKE_GOODS * 8)) &amp;&amp; MP_INFO(x, y).int_3 &gt;= INDUSTRY_L_ORE_USED) {
+        goods += INDUSTRY_L_MAKE_GOODS;
+        MP_INFO(x, y).int_3 -= INDUSTRY_L_ORE_USED;
+        ore_used += INDUSTRY_L_ORE_USED;
+        MP_INFO(x, y).int_5 -= INDUSTRY_L_JOBS_USED;
+        /* Pollution is now determined by amount of goods made and affected by
+           technology 
+           MP_POL(x,y) += INDUSTRY_L_POLLUTION; */
 
-      /* multiply by 2 if we have steel. */
-      if (MP_INFO(x,y).int_4 &gt;= INDUSTRY_L_STEEL_USED)
-	{
-	  MP_INFO(x,y).int_4 -= INDUSTRY_L_STEEL_USED;
-	  goods += goods;
-	}
-      /* multipy by 4 if we can get power. */
+        /* multiply by 2 if we have steel. */
+        if (MP_INFO(x, y).int_4 &gt;= INDUSTRY_L_STEEL_USED) {
+            MP_INFO(x, y).int_4 -= INDUSTRY_L_STEEL_USED;
+            goods += goods;
+        }
+        /* multipy by 4 if we can get power. */
 
-      if (MP_INFO(x,y).int_3 &gt;= INDUSTRY_L_ORE_USED
-	  &amp;&amp; get_power (x, y, goods * 10, 1) != 0)
-	{
-	  goods *= 4;
-	  MP_INFO(x,y).flags |= FLAG_POWERED;
-	  /* and use more ore */
-	  MP_INFO(x,y).int_3 -= INDUSTRY_L_ORE_USED;
-	  ore_used += INDUSTRY_L_ORE_USED;
-	}
-      else
-	MP_INFO(x,y).flags &amp;= (0xffffffff - FLAG_POWERED);
+        if (MP_INFO(x, y).int_3 &gt;= INDUSTRY_L_ORE_USED &amp;&amp; get_power(x, y, goods * 10, 1) != 0) {
+            goods *= 4;
+            MP_INFO(x, y).flags |= FLAG_POWERED;
+            /* and use more ore */
+            MP_INFO(x, y).int_3 -= INDUSTRY_L_ORE_USED;
+            ore_used += INDUSTRY_L_ORE_USED;
+        } else
+            MP_INFO(x, y).flags &amp;= (0xffffffff - FLAG_POWERED);
     }
 
-  MP_INFO(x,y).int_1 += goods;
-  MP_INFO(x,y).int_2 += goods;
-  goods_made += goods;
+    MP_INFO(x, y).int_1 += goods;
+    MP_INFO(x, y).int_2 += goods;
+    goods_made += goods;
 
-  /* Pollution is based on goods produced and is affected by tech level above
-     1000 (displayed as 100) whereupon it is reduced by one percent per 10
-     tech_level points.  
-  */
-  /* XXX: it would be nice to convert tech-reduced air pollution into waste
-     to be hauled to a tip or recycled, and reduce that above tl 2000 */
+    /* Pollution is based on goods produced and is affected by tech level above
+       1000 (displayed as 100) whereupon it is reduced by one percent per 10
+       tech_level points.  
+     */
+    /* XXX: it would be nice to convert tech-reduced air pollution into waste
+       to be hauled to a tip or recycled, and reduce that above tl 2000 */
 
-  tmp_pol = (float)(INDUSTRY_L_POL_PER_GOOD * goods);
-  if (tech_level &gt; 1000) { 
-    double d;
-    d = (tech_level - 1000);
-    if (d &gt; 1000) 
-      d = 1000;
-    d /= 1000;
-    tmp_pol -= (tmp_pol * d);
-    if (tmp_pol &lt; 0) 
-      tmp_pol = 0;
-  }
+    tmp_pol = (float)(INDUSTRY_L_POL_PER_GOOD * goods);
+    if (tech_level &gt; 1000) {
+        double d;
+        d = (tech_level - 1000);
+        if (d &gt; 1000)
+            d = 1000;
+        d /= 1000;
+        tmp_pol -= (tmp_pol * d);
+        if (tmp_pol &lt; 0)
+            tmp_pol = 0;
+    }
 
-  MP_POL(x,y) += (int)tmp_pol;
+    MP_POL(x, y) += (int)tmp_pol;
 
-  /* now sell the goods to the road/rail/track */
-  if (MP_GROUP(x,y - 1) == GROUP_ROAD 
-      &amp;&amp; (MAX_GOODS_ON_ROAD - MP_INFO(x,y - 1).int_4) &lt;= MP_INFO(x,y).int_2)
-    {
-      MP_INFO(x,y).int_2 -= (MAX_GOODS_ON_ROAD - MP_INFO(x,y - 1).int_4);
-      MP_INFO(x,y - 1).int_4 = MAX_GOODS_ON_ROAD;
+    /* now sell the goods to the road/rail/track */
+    if (MP_GROUP(x, y - 1) == GROUP_ROAD &amp;&amp; (MAX_GOODS_ON_ROAD - MP_INFO(x, y - 1).int_4) &lt;= MP_INFO(x, y).int_2) {
+        MP_INFO(x, y).int_2 -= (MAX_GOODS_ON_ROAD - MP_INFO(x, y - 1).int_4);
+        MP_INFO(x, y - 1).int_4 = MAX_GOODS_ON_ROAD;
+    } else if (MP_GROUP(x, y - 1) == GROUP_RAIL &amp;&amp; (MAX_GOODS_ON_RAIL - MP_INFO(x, y - 1).int_4)
+               &lt;= MP_INFO(x, y).int_2) {
+        MP_INFO(x, y).int_2 -= (MAX_GOODS_ON_RAIL - MP_INFO(x, y - 1).int_4);
+        MP_INFO(x, y - 1).int_4 = MAX_GOODS_ON_RAIL;
+    } else if (MP_GROUP(x, y - 1) == GROUP_TRACK &amp;&amp; (MAX_GOODS_ON_TRACK - MP_INFO(x, y - 1).int_4)
+               &lt;= MP_INFO(x, y).int_2) {
+        MP_INFO(x, y).int_2 -= (MAX_GOODS_ON_TRACK - MP_INFO(x, y - 1).int_4);
+        MP_INFO(x, y - 1).int_4 = MAX_GOODS_ON_TRACK;
     }
-  else if (MP_GROUP(x,y - 1) == GROUP_RAIL 
-	   &amp;&amp; (MAX_GOODS_ON_RAIL - MP_INFO(x,y - 1).int_4) 
-	   &lt;= MP_INFO(x,y).int_2)
-    {
-      MP_INFO(x,y).int_2 -= (MAX_GOODS_ON_RAIL
-			       - MP_INFO(x,y - 1).int_4);
-      MP_INFO(x,y - 1).int_4 = MAX_GOODS_ON_RAIL;
-    }
-  else if (MP_GROUP(x,y - 1) == GROUP_TRACK 
-	   &amp;&amp; (MAX_GOODS_ON_TRACK - MP_INFO(x,y - 1).int_4)
-	   &lt;= MP_INFO(x,y).int_2)
-    {
-      MP_INFO(x,y).int_2 -= (MAX_GOODS_ON_TRACK
-			       - MP_INFO(x,y - 1).int_4);
-      MP_INFO(x,y - 1).int_4 = MAX_GOODS_ON_TRACK;
-    }
 
-
-  if (MP_GROUP(x - 1,y) == GROUP_ROAD 
-      &amp;&amp; (MAX_GOODS_ON_ROAD - MP_INFO(x - 1,y).int_4)
-      &lt;= MP_INFO(x,y).int_2)
-    {
-      MP_INFO(x,y).int_2 -= (MAX_GOODS_ON_ROAD
-			       - MP_INFO(x - 1,y).int_4);
-      MP_INFO(x - 1,y).int_4 = MAX_GOODS_ON_ROAD;
+    if (MP_GROUP(x - 1, y) == GROUP_ROAD &amp;&amp; (MAX_GOODS_ON_ROAD - MP_INFO(x - 1, y).int_4)
+        &lt;= MP_INFO(x, y).int_2) {
+        MP_INFO(x, y).int_2 -= (MAX_GOODS_ON_ROAD - MP_INFO(x - 1, y).int_4);
+        MP_INFO(x - 1, y).int_4 = MAX_GOODS_ON_ROAD;
+    } else if (MP_GROUP(x - 1, y) == GROUP_RAIL &amp;&amp; (MAX_GOODS_ON_RAIL - MP_INFO(x - 1, y).int_4)
+               &lt;= MP_INFO(x, y).int_2) {
+        MP_INFO(x, y).int_2 -= (MAX_GOODS_ON_RAIL - MP_INFO(x - 1, y).int_4);
+        MP_INFO(x - 1, y).int_4 = MAX_GOODS_ON_RAIL;
+    } else if (MP_GROUP(x - 1, y) == GROUP_TRACK &amp;&amp; (MAX_GOODS_ON_TRACK - MP_INFO(x - 1, y).int_4)
+               &lt;= MP_INFO(x, y).int_2) {
+        MP_INFO(x, y).int_2 -= (MAX_GOODS_ON_TRACK - MP_INFO(x - 1, y).int_4);
+        MP_INFO(x - 1, y).int_4 = MAX_GOODS_ON_TRACK;
     }
-  else if (MP_GROUP(x - 1,y) == GROUP_RAIL 
-	   &amp;&amp; (MAX_GOODS_ON_RAIL - MP_INFO(x - 1,y).int_4)
-	   &lt;= MP_INFO(x,y).int_2)
-    {
-      MP_INFO(x,y).int_2 -= (MAX_GOODS_ON_RAIL
-			       - MP_INFO(x - 1,y).int_4);
-      MP_INFO(x - 1,y).int_4 = MAX_GOODS_ON_RAIL;
-    }
-  else if (MP_GROUP(x-1,y) == GROUP_TRACK 
-	   &amp;&amp; (MAX_GOODS_ON_TRACK - MP_INFO(x - 1,y).int_4)
-	   &lt;= MP_INFO(x,y).int_2)
-    {
-      MP_INFO(x,y).int_2 -= (MAX_GOODS_ON_TRACK
-			       - MP_INFO(x - 1,y).int_4);
-      MP_INFO(x - 1,y).int_4 = MAX_GOODS_ON_TRACK;
-    }
 
-  /* now choose a graphic every month */
-  if ((total_time % NUMOF_DAYS_IN_MONTH) == NUMOF_DAYS_IN_MONTH - 1)
-    {
-      MP_INFO(x,y).int_6 = (MP_INFO(x,y).int_1)
-	/ (INDUSTRY_L_MAKE_GOODS * 8);
-      MP_INFO(x,y).int_1 = 0;
-      if (MP_INFO(x,y).int_6 &gt; 80)
-	{
-	  switch (MP_TYPE(x,y))
-	    {
-	    case (CST_INDUSTRY_L_H1):
-	    case (CST_INDUSTRY_L_H2):
-	    case (CST_INDUSTRY_L_H3):
-	    case (CST_INDUSTRY_L_H4):
-	      break;
-	    default:
-	      MP_TYPE(x,y) = CST_INDUSTRY_L_H1;
-	    }
-	}
-      else if (MP_INFO(x,y).int_6 &gt; 55)
-	{
-	  switch (MP_TYPE(x,y))
-	    {
-	    case (CST_INDUSTRY_L_M1):
-	    case (CST_INDUSTRY_L_M2):
-	    case (CST_INDUSTRY_L_M3):
-	    case (CST_INDUSTRY_L_M4):
-	      break;
-	    default:
-	      MP_TYPE(x,y) = CST_INDUSTRY_L_M1;
-	    }
-	}
-      else if (MP_INFO(x,y).int_6 &gt; 25)
-	{
-	  switch (MP_TYPE(x,y))
-	    {
-	    case (CST_INDUSTRY_L_L1):
-	    case (CST_INDUSTRY_L_L2):
-	    case (CST_INDUSTRY_L_L3):
-	    case (CST_INDUSTRY_L_L4):
-	      break;
-	    default:
-	      MP_TYPE(x,y) = CST_INDUSTRY_L_L1;
-	    }
-	}
-      else if (MP_INFO(x,y).int_6 &gt; 0)
-	{
-	  switch (MP_TYPE(x,y))
-	    {
-	    case (CST_INDUSTRY_L_Q1):
-	    case (CST_INDUSTRY_L_Q2):
-	    case (CST_INDUSTRY_L_Q3):
-	    case (CST_INDUSTRY_L_Q4):
-	      break;
-	    default:
-	      MP_TYPE(x,y) = CST_INDUSTRY_L_Q1;
-	    }
-	}
-      else
-	MP_TYPE(x,y) = CST_INDUSTRY_L_C;
+    /* now choose a graphic every month */
+    if ((total_time % NUMOF_DAYS_IN_MONTH) == NUMOF_DAYS_IN_MONTH - 1) {
+        MP_INFO(x, y).int_6 = (MP_INFO(x, y).int_1)
+            / (INDUSTRY_L_MAKE_GOODS * 8);
+        MP_INFO(x, y).int_1 = 0;
+        if (MP_INFO(x, y).int_6 &gt; 80) {
+            switch (MP_TYPE(x, y)) {
+            case (CST_INDUSTRY_L_H1):
+            case (CST_INDUSTRY_L_H2):
+            case (CST_INDUSTRY_L_H3):
+            case (CST_INDUSTRY_L_H4):
+                break;
+            default:
+                MP_TYPE(x, y) = CST_INDUSTRY_L_H1;
+            }
+        } else if (MP_INFO(x, y).int_6 &gt; 55) {
+            switch (MP_TYPE(x, y)) {
+            case (CST_INDUSTRY_L_M1):
+            case (CST_INDUSTRY_L_M2):
+            case (CST_INDUSTRY_L_M3):
+            case (CST_INDUSTRY_L_M4):
+                break;
+            default:
+                MP_TYPE(x, y) = CST_INDUSTRY_L_M1;
+            }
+        } else if (MP_INFO(x, y).int_6 &gt; 25) {
+            switch (MP_TYPE(x, y)) {
+            case (CST_INDUSTRY_L_L1):
+            case (CST_INDUSTRY_L_L2):
+            case (CST_INDUSTRY_L_L3):
+            case (CST_INDUSTRY_L_L4):
+                break;
+            default:
+                MP_TYPE(x, y) = CST_INDUSTRY_L_L1;
+            }
+        } else if (MP_INFO(x, y).int_6 &gt; 0) {
+            switch (MP_TYPE(x, y)) {
+            case (CST_INDUSTRY_L_Q1):
+            case (CST_INDUSTRY_L_Q2):
+            case (CST_INDUSTRY_L_Q3):
+            case (CST_INDUSTRY_L_Q4):
+                break;
+            default:
+                MP_TYPE(x, y) = CST_INDUSTRY_L_Q1;
+            }
+        } else
+            MP_TYPE(x, y) = CST_INDUSTRY_L_C;
     }
-  /* now animate */
-  if (real_time &gt;= MP_INFO(x,y).int_7)
-    {
-      MP_INFO(x,y).int_7 = real_time + INDUSTRY_L_ANIM_SPEED;
-      switch (MP_TYPE(x,y))
-	{
-	case (CST_INDUSTRY_L_Q1):
-	  MP_TYPE(x,y) = CST_INDUSTRY_L_Q2;
-	  break;
-	case (CST_INDUSTRY_L_Q2):
-	  MP_TYPE(x,y) = CST_INDUSTRY_L_Q3;
-	  break;
-	case (CST_INDUSTRY_L_Q3):
-	  MP_TYPE(x,y) = CST_INDUSTRY_L_Q4;
-	  break;
-	case (CST_INDUSTRY_L_Q4):
-	  MP_TYPE(x,y) = CST_INDUSTRY_L_Q1;
-	  break;
-	case (CST_INDUSTRY_L_L1):
-	  MP_TYPE(x,y) = CST_INDUSTRY_L_L2;
-	  break;
-	case (CST_INDUSTRY_L_L2):
-	  MP_TYPE(x,y) = CST_INDUSTRY_L_L3;
-	  break;
-	case (CST_INDUSTRY_L_L3):
-	  MP_TYPE(x,y) = CST_INDUSTRY_L_L4;
-	  break;
-	case (CST_INDUSTRY_L_L4):
-	  MP_TYPE(x,y) = CST_INDUSTRY_L_L1;
-	  break;
-	case (CST_INDUSTRY_L_M1):
-	  MP_TYPE(x,y) = CST_INDUSTRY_L_M2;
-	  break;
-	case (CST_INDUSTRY_L_M2):
-	  MP_TYPE(x,y) = CST_INDUSTRY_L_M3;
-	  break;
-	case (CST_INDUSTRY_L_M3):
-	  MP_TYPE(x,y) = CST_INDUSTRY_L_M4;
-	  break;
-	case (CST_INDUSTRY_L_M4):
-	  MP_TYPE(x,y) = CST_INDUSTRY_L_M1;
-	  break;
-	case (CST_INDUSTRY_L_H1):
-	  MP_TYPE(x,y) = CST_INDUSTRY_L_H2;
-	  break;
-	case (CST_INDUSTRY_L_H2):
-	  MP_TYPE(x,y) = CST_INDUSTRY_L_H3;
-	  break;
-	case (CST_INDUSTRY_L_H3):
-	  MP_TYPE(x,y) = CST_INDUSTRY_L_H4;
-	  break;
-	case (CST_INDUSTRY_L_H4):
-	  MP_TYPE(x,y) = CST_INDUSTRY_L_H1;
-	  break;
-	}
+    /* now animate */
+    if (real_time &gt;= MP_INFO(x, y).int_7) {
+        MP_INFO(x, y).int_7 = real_time + INDUSTRY_L_ANIM_SPEED;
+        switch (MP_TYPE(x, y)) {
+        case (CST_INDUSTRY_L_Q1):
+            MP_TYPE(x, y) = CST_INDUSTRY_L_Q2;
+            break;
+        case (CST_INDUSTRY_L_Q2):
+            MP_TYPE(x, y) = CST_INDUSTRY_L_Q3;
+            break;
+        case (CST_INDUSTRY_L_Q3):
+            MP_TYPE(x, y) = CST_INDUSTRY_L_Q4;
+            break;
+        case (CST_INDUSTRY_L_Q4):
+            MP_TYPE(x, y) = CST_INDUSTRY_L_Q1;
+            break;
+        case (CST_INDUSTRY_L_L1):
+            MP_TYPE(x, y) = CST_INDUSTRY_L_L2;
+            break;
+        case (CST_INDUSTRY_L_L2):
+            MP_TYPE(x, y) = CST_INDUSTRY_L_L3;
+            break;
+        case (CST_INDUSTRY_L_L3):
+            MP_TYPE(x, y) = CST_INDUSTRY_L_L4;
+            break;
+        case (CST_INDUSTRY_L_L4):
+            MP_TYPE(x, y) = CST_INDUSTRY_L_L1;
+            break;
+        case (CST_INDUSTRY_L_M1):
+            MP_TYPE(x, y) = CST_INDUSTRY_L_M2;
+            break;
+        case (CST_INDUSTRY_L_M2):
+            MP_TYPE(x, y) = CST_INDUSTRY_L_M3;
+            break;
+        case (CST_INDUSTRY_L_M3):
+            MP_TYPE(x, y) = CST_INDUSTRY_L_M4;
+            break;
+        case (CST_INDUSTRY_L_M4):
+            MP_TYPE(x, y) = CST_INDUSTRY_L_M1;
+            break;
+        case (CST_INDUSTRY_L_H1):
+            MP_TYPE(x, y) = CST_INDUSTRY_L_H2;
+            break;
+        case (CST_INDUSTRY_L_H2):
+            MP_TYPE(x, y) = CST_INDUSTRY_L_H3;
+            break;
+        case (CST_INDUSTRY_L_H3):
+            MP_TYPE(x, y) = CST_INDUSTRY_L_H4;
+            break;
+        case (CST_INDUSTRY_L_H4):
+            MP_TYPE(x, y) = CST_INDUSTRY_L_H1;
+            break;
+        }
     }
 }
 
-
-void
-mps_light_industry (int x, int y)
+void mps_light_industry(int x, int y)
 {
-  int i = 0;
-  const char * p;
+    int i = 0;
+    const char *p;
 
-  mps_store_title(i++,_(&quot;Light&quot;));
-  mps_store_title(i++,_(&quot;Industry&quot;));
+    mps_store_title(i++, _(&quot;Light&quot;));
+    mps_store_title(i++, _(&quot;Industry&quot;));
 
-  i++;
+    i++;
 
-  p = ((MP_INFO(x,y).flags &amp; FLAG_POWERED) != 0) ? _(&quot;YES&quot;) : _(&quot;NO&quot;);
-  mps_store_ss(i++,_(&quot;Power&quot;),p);
+    p = ((MP_INFO(x, y).flags &amp; FLAG_POWERED) != 0) ? _(&quot;YES&quot;) : _(&quot;NO&quot;);
+    mps_store_ss(i++, _(&quot;Power&quot;), p);
 
-  mps_store_sd(i++,_(&quot;Output&quot;),MP_INFO(x,y).int_1);
+    mps_store_sd(i++, _(&quot;Output&quot;), MP_INFO(x, y).int_1);
 
-  mps_store_sfp(i++,_(&quot;Store&quot;),
-		MP_INFO(x,y).int_2 * 100.0 / MAX_GOODS_AT_INDUSTRY_L);
-  mps_store_sfp(i++,_(&quot;Ore&quot;),
-		MP_INFO(x,y).int_3 * 100.0 / MAX_ORE_AT_INDUSTRY_L);
-  mps_store_sfp(i++,_(&quot;Steel&quot;), 
-		MP_INFO(x,y).int_4 * 100.0 / MAX_STEEL_AT_INDUSTRY_L);
-  mps_store_sfp(i++,_(&quot;Capacity&quot;),
-		MP_INFO(x,y).int_6);
+    mps_store_sfp(i++, _(&quot;Store&quot;), MP_INFO(x, y).int_2 * 100.0 / MAX_GOODS_AT_INDUSTRY_L);
+    mps_store_sfp(i++, _(&quot;Ore&quot;), MP_INFO(x, y).int_3 * 100.0 / MAX_ORE_AT_INDUSTRY_L);
+    mps_store_sfp(i++, _(&quot;Steel&quot;), MP_INFO(x, y).int_4 * 100.0 / MAX_STEEL_AT_INDUSTRY_L);
+    mps_store_sfp(i++, _(&quot;Capacity&quot;), MP_INFO(x, y).int_6);
 }

Modified: trunk/src/lincity/modules/market.cpp
===================================================================
--- trunk/src/lincity/modules/market.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/market.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -14,1160 +14,992 @@
 #include &quot;lcintl.h&quot;
 #include &quot;market.h&quot;
 
-
-int
-get_jobs (int x, int y, int jobs)
+int get_jobs(int x, int y, int jobs)
 {
-  int q;
-  if (numof_markets &gt; 0)
-    {
-      for (q = 0; q &lt; numof_markets; q++)
-	{
-	  if ((abs (marketx[q] - x) &lt; MARKET_RANGE
-	       &amp;&amp; abs (markety[q] - y) &lt; MARKET_RANGE
-	       &amp;&amp; (MP_INFO(marketx[q],markety[q]).int_2 &gt; (3 * jobs / 2))))
-	    {
-	      MP_INFO(marketx[q],markety[q]).int_2 -= jobs;
-	      income_tax += jobs;
-	      return (1);
-	    }
-	}
+    int q;
+    if (numof_markets &gt; 0) {
+        for (q = 0; q &lt; numof_markets; q++) {
+            if ((abs(marketx[q] - x) &lt; MARKET_RANGE
+                 &amp;&amp; abs(markety[q] - y) &lt; MARKET_RANGE &amp;&amp; (MP_INFO(marketx[q], markety[q]).int_2 &gt; (3 * jobs / 2)))) {
+                MP_INFO(marketx[q], markety[q]).int_2 -= jobs;
+                income_tax += jobs;
+                return (1);
+            }
+        }
     }
-  if (get_stuff (x, y, jobs, T_JOBS) != 0)
-    {
-      income_tax += jobs;
-      return (1);
+    if (get_stuff(x, y, jobs, T_JOBS) != 0) {
+        income_tax += jobs;
+        return (1);
     }
-  return (0);
+    return (0);
 }
 
-int
-put_jobs (int x, int y, int jobs)
+int put_jobs(int x, int y, int jobs)
 {
-  int q;
-  if (numof_markets &gt; 0) {
-      for (q = 0; q &lt; numof_markets; q++) {
-	  if (MP_INFO(marketx[q],markety[q]).int_2
-	      &gt;= (MAX_JOBS_IN_MARKET - jobs))
-	    continue;
-	  if (abs (marketx[q] - x) &lt; EMPLOYER_RANGE
-	      &amp;&amp; abs (markety[q] - y) &lt; EMPLOYER_RANGE)
-	    {
-	      MP_INFO(marketx[q],markety[q]).int_2 += jobs;
-	      return (1);
-	    }
-	}
+    int q;
+    if (numof_markets &gt; 0) {
+        for (q = 0; q &lt; numof_markets; q++) {
+            if (MP_INFO(marketx[q], markety[q]).int_2 &gt;= (MAX_JOBS_IN_MARKET - jobs))
+                continue;
+            if (abs(marketx[q] - x) &lt; EMPLOYER_RANGE &amp;&amp; abs(markety[q] - y) &lt; EMPLOYER_RANGE) {
+                MP_INFO(marketx[q], markety[q]).int_2 += jobs;
+                return (1);
+            }
+        }
     }
-  if (put_stuff (x, y, jobs, T_JOBS) != 0) {
-      return (1);
-  }
-  return (0);
+    if (put_stuff(x, y, jobs, T_JOBS) != 0) {
+        return (1);
+    }
+    return (0);
 }
 
-int
-get_food (int x, int y, int food)
+int get_food(int x, int y, int food)
 {
-  int q;
-  if (numof_markets &gt; 0)
-    {
-      for (q = 0; q &lt; numof_markets; q++)
-	{
-	  if ((abs (marketx[q] - x) &lt; MARKET_RANGE)
-	      &amp;&amp; (abs (markety[q] - y) &lt; MARKET_RANGE)
-	      &amp;&amp; (MP_INFO(marketx[q],markety[q]).int_1
-		  &gt; food))
-	    {
-	      MP_INFO(marketx[q],markety[q]).int_1 -= food;
-	      return (1);
-	    }
-	}
+    int q;
+    if (numof_markets &gt; 0) {
+        for (q = 0; q &lt; numof_markets; q++) {
+            if ((abs(marketx[q] - x) &lt; MARKET_RANGE)
+                &amp;&amp; (abs(markety[q] - y) &lt; MARKET_RANGE)
+                &amp;&amp; (MP_INFO(marketx[q], markety[q]).int_1 &gt; food)) {
+                MP_INFO(marketx[q], markety[q]).int_1 -= food;
+                return (1);
+            }
+        }
     }
-  if (get_stuff (x, y, food, T_FOOD) != 0)
-    return (1);
-  return (0);
+    if (get_stuff(x, y, food, T_FOOD) != 0)
+        return (1);
+    return (0);
 }
 
-int
-put_food (int x, int y, int food)
+int put_food(int x, int y, int food)
 {
-  int q;
-  if (numof_markets &gt; 0)
-    {
-      for (q = 0; q &lt; numof_markets; q++)
-	{
-	  if (MP_INFO(marketx[q],markety[q]).int_1
-	      &gt;= (MAX_FOOD_IN_MARKET - food))
-	    continue;
-	  if ((abs (marketx[q] - x) &lt; ORG_FARM_RANGE)
-	      &amp;&amp; (abs (markety[q] - y) &lt; ORG_FARM_RANGE))
-	    {
-	      MP_INFO(marketx[q],markety[q]).int_1 += food;
-	      return (1);
-	    }
-	}
+    int q;
+    if (numof_markets &gt; 0) {
+        for (q = 0; q &lt; numof_markets; q++) {
+            if (MP_INFO(marketx[q], markety[q]).int_1 &gt;= (MAX_FOOD_IN_MARKET - food))
+                continue;
+            if ((abs(marketx[q] - x) &lt; ORG_FARM_RANGE)
+                &amp;&amp; (abs(markety[q] - y) &lt; ORG_FARM_RANGE)) {
+                MP_INFO(marketx[q], markety[q]).int_1 += food;
+                return (1);
+            }
+        }
     }
-  if (put_stuff (x, y, food, T_FOOD) != 0)
-    return (1);
-  return (0);
+    if (put_stuff(x, y, food, T_FOOD) != 0)
+        return (1);
+    return (0);
 }
 
-
-int
-get_goods (int x, int y, int goods)
+int get_goods(int x, int y, int goods)
 {
-  int q;
-  if (numof_markets &gt; 0)
-    {
-      for (q = 0; q &lt; numof_markets; q++)
-	{
-	  if (abs (marketx[q] - x) &lt; MARKET_RANGE
-	      &amp;&amp; abs (markety[q] - y) &lt; MARKET_RANGE
-	      &amp;&amp; (MP_INFO(marketx[q],markety[q]).int_4
-		  &gt; goods))
-	    {
-	      MP_INFO(marketx[q],markety[q]).int_4 -= goods;
-	      goods_tax += goods;
-	      goods_used += goods;
-	      /* make the waste here. */
-	      MP_INFO(marketx[q],markety[q]).int_7 += goods / 3;
-	      return (1);
-	    }
-	}
+    int q;
+    if (numof_markets &gt; 0) {
+        for (q = 0; q &lt; numof_markets; q++) {
+            if (abs(marketx[q] - x) &lt; MARKET_RANGE
+                &amp;&amp; abs(markety[q] - y) &lt; MARKET_RANGE &amp;&amp; (MP_INFO(marketx[q], markety[q]).int_4 &gt; goods)) {
+                MP_INFO(marketx[q], markety[q]).int_4 -= goods;
+                goods_tax += goods;
+                goods_used += goods;
+                /* make the waste here. */
+                MP_INFO(marketx[q], markety[q]).int_7 += goods / 3;
+                return (1);
+            }
+        }
     }
-  if (get_stuff (x, y, goods, T_GOODS) != 0)
-    {
-      put_stuff (x, y, goods / 3, T_WASTE);
-      goods_tax += goods;
-      goods_used += goods;
-      return (1);
+    if (get_stuff(x, y, goods, T_GOODS) != 0) {
+        put_stuff(x, y, goods / 3, T_WASTE);
+        goods_tax += goods;
+        goods_used += goods;
+        return (1);
     }
-  return (0);
+    return (0);
 }
 
-int
-put_goods (int x, int y, int goods)
+int put_goods(int x, int y, int goods)
 {
-  int q;
-  if (numof_markets &gt; 0)
-    {
-      for (q = 0; q &lt; numof_markets; q++)
-	{
-	  if (MP_INFO(marketx[q],markety[q]).int_4
-	      &gt;= (MAX_GOODS_IN_MARKET - goods))
-	    continue;
-	  if ((abs (marketx[q] - x) &lt; MARKET_RANGE)
-	      &amp;&amp; (abs (markety[q] - y) &lt; MARKET_RANGE))
-	    {
-	      MP_INFO(marketx[q],markety[q]).int_4 += goods;
-	      return (1);
-	    }
-	}
+    int q;
+    if (numof_markets &gt; 0) {
+        for (q = 0; q &lt; numof_markets; q++) {
+            if (MP_INFO(marketx[q], markety[q]).int_4 &gt;= (MAX_GOODS_IN_MARKET - goods))
+                continue;
+            if ((abs(marketx[q] - x) &lt; MARKET_RANGE)
+                &amp;&amp; (abs(markety[q] - y) &lt; MARKET_RANGE)) {
+                MP_INFO(marketx[q], markety[q]).int_4 += goods;
+                return (1);
+            }
+        }
     }
-  if (put_stuff (x, y, goods, T_GOODS) != 0)
-    return (1);
-  return (0);
+    if (put_stuff(x, y, goods, T_GOODS) != 0)
+        return (1);
+    return (0);
 }
 
-int
-put_waste (int x, int y, int waste)
+int put_waste(int x, int y, int waste)
 {
-  int q;
-  if (numof_markets &gt; 0)
-    {
-      for (q = 0; q &lt; numof_markets; q++)
-	{
-	  if (MP_INFO(marketx[q],markety[q]).int_7
-	      &gt;= (MAX_WASTE_IN_MARKET - waste))
-	    continue;
-	  if ((abs (marketx[q] - x) &lt; MARKET_RANGE)
-	      &amp;&amp; (abs (markety[q] - y) &lt; MARKET_RANGE))
-	    {
-	      MP_INFO(marketx[q],markety[q]).int_7 += waste;
-	      return (1);
-	    }
-	}
+    int q;
+    if (numof_markets &gt; 0) {
+        for (q = 0; q &lt; numof_markets; q++) {
+            if (MP_INFO(marketx[q], markety[q]).int_7 &gt;= (MAX_WASTE_IN_MARKET - waste))
+                continue;
+            if ((abs(marketx[q] - x) &lt; MARKET_RANGE)
+                &amp;&amp; (abs(markety[q] - y) &lt; MARKET_RANGE)) {
+                MP_INFO(marketx[q], markety[q]).int_7 += waste;
+                return (1);
+            }
+        }
     }
-  if (put_stuff (x, y, waste, T_WASTE) != 0)
-    return (1);
-  return (0);
+    if (put_stuff(x, y, waste, T_WASTE) != 0)
+        return (1);
+    return (0);
 }
 
-int
-get_waste (int x, int y, int waste)
+int get_waste(int x, int y, int waste)
 {
-  int q;
-  if (numof_markets &gt; 0)
-    {
-      for (q = 0; q &lt; numof_markets; q++)
-	{
-	  if ((abs (marketx[q] - x) &lt; MARKET_RANGE)
-	      &amp;&amp; (abs (markety[q] - y) &lt; MARKET_RANGE)
-	      &amp;&amp; (MP_INFO(marketx[q],markety[q]).int_7
-		  &gt; waste))
-	    {
-	      MP_INFO(marketx[q],markety[q]).int_7 -= waste;
-	      return (1);
-	    }
-	}
+    int q;
+    if (numof_markets &gt; 0) {
+        for (q = 0; q &lt; numof_markets; q++) {
+            if ((abs(marketx[q] - x) &lt; MARKET_RANGE)
+                &amp;&amp; (abs(markety[q] - y) &lt; MARKET_RANGE)
+                &amp;&amp; (MP_INFO(marketx[q], markety[q]).int_7 &gt; waste)) {
+                MP_INFO(marketx[q], markety[q]).int_7 -= waste;
+                return (1);
+            }
+        }
     }
-  if (get_stuff (x, y, waste, T_WASTE) != 0)
-    return (1);
-  return (0);
+    if (get_stuff(x, y, waste, T_WASTE) != 0)
+        return (1);
+    return (0);
 }
 
-
-int
-get_steel (int x, int y, int steel)
+int get_steel(int x, int y, int steel)
 {
-  int q;
-  if (numof_markets &gt; 0)
-    {
-      for (q = 0; q &lt; numof_markets; q++)
-	{
-	  if ((abs (marketx[q] - x) &lt; MARKET_RANGE)
-	      &amp;&amp; (abs (markety[q] - y) &lt; MARKET_RANGE)
-	      &amp;&amp; (MP_INFO(marketx[q],markety[q]).int_6
-		  &gt; steel))
-	    {
-	      MP_INFO(marketx[q],markety[q]).int_6 -= steel;
-	      return (1);
-	    }
-	}
+    int q;
+    if (numof_markets &gt; 0) {
+        for (q = 0; q &lt; numof_markets; q++) {
+            if ((abs(marketx[q] - x) &lt; MARKET_RANGE)
+                &amp;&amp; (abs(markety[q] - y) &lt; MARKET_RANGE)
+                &amp;&amp; (MP_INFO(marketx[q], markety[q]).int_6 &gt; steel)) {
+                MP_INFO(marketx[q], markety[q]).int_6 -= steel;
+                return (1);
+            }
+        }
     }
-  if (get_stuff (x, y, steel, T_STEEL) != 0)
-    return (1);
-  return (0);
+    if (get_stuff(x, y, steel, T_STEEL) != 0)
+        return (1);
+    return (0);
 }
 
-int
-put_steel (int x, int y, int steel)
+int put_steel(int x, int y, int steel)
 {
-  int q;
-  if (numof_markets &gt; 0)
-    {
-      for (q = 0; q &lt; numof_markets; q++)
-	{
-	  if (MP_INFO(marketx[q],markety[q]).int_6
-	      &gt;= (MAX_STEEL_IN_MARKET - steel))
-	    continue;
-	  if ((abs (marketx[q] - x) &lt; MARKET_RANGE)
-	      &amp;&amp; (abs (markety[q] - y) &lt; MARKET_RANGE))
-	    {
-	      MP_INFO(marketx[q],markety[q]).int_6 += steel;
-	      return (1);
-	    }
-	}
+    int q;
+    if (numof_markets &gt; 0) {
+        for (q = 0; q &lt; numof_markets; q++) {
+            if (MP_INFO(marketx[q], markety[q]).int_6 &gt;= (MAX_STEEL_IN_MARKET - steel))
+                continue;
+            if ((abs(marketx[q] - x) &lt; MARKET_RANGE)
+                &amp;&amp; (abs(markety[q] - y) &lt; MARKET_RANGE)) {
+                MP_INFO(marketx[q], markety[q]).int_6 += steel;
+                return (1);
+            }
+        }
     }
-  if (put_stuff (x, y, steel, T_STEEL) != 0)
-    return (1);
-  return (0);
+    if (put_stuff(x, y, steel, T_STEEL) != 0)
+        return (1);
+    return (0);
 }
 
-
-int
-get_ore (int x, int y, int ore)
+int get_ore(int x, int y, int ore)
 {
-  int q;
-  if (numof_markets &gt; 0)
-    {
-      for (q = 0; q &lt; numof_markets; q++)
-	{
-	  if ((abs (marketx[q] - x) &lt; MARKET_RANGE)
-	      &amp;&amp; (abs (markety[q] - y) &lt; MARKET_RANGE)
-	      &amp;&amp; (MP_INFO(marketx[q],markety[q]).int_5
-		  &gt; ore))
-	    {
-	      MP_INFO(marketx[q],markety[q]).int_5 -= ore;
-	      return (1);
-	    }
-	}
+    int q;
+    if (numof_markets &gt; 0) {
+        for (q = 0; q &lt; numof_markets; q++) {
+            if ((abs(marketx[q] - x) &lt; MARKET_RANGE)
+                &amp;&amp; (abs(markety[q] - y) &lt; MARKET_RANGE)
+                &amp;&amp; (MP_INFO(marketx[q], markety[q]).int_5 &gt; ore)) {
+                MP_INFO(marketx[q], markety[q]).int_5 -= ore;
+                return (1);
+            }
+        }
     }
-  if (get_stuff (x, y, ore, T_ORE) != 0)
-    return (1);
-  return (0);
+    if (get_stuff(x, y, ore, T_ORE) != 0)
+        return (1);
+    return (0);
 }
 
-int
-put_ore (int x, int y, int ore)
+int put_ore(int x, int y, int ore)
 {
-  int q;
-  if (numof_markets &gt; 0)
-    {
-      for (q = 0; q &lt; numof_markets; q++)
-	{
-	  if (MP_INFO(marketx[q],markety[q]).int_5
-	      &gt;= (MAX_ORE_IN_MARKET - ore))
-	    continue;
-	  if ((abs (marketx[q] - x) &lt; MARKET_RANGE)
-	      &amp;&amp; (abs (markety[q] - y) &lt; MARKET_RANGE))
-	    {
-	      MP_INFO(marketx[q],markety[q]).int_5 += ore;
-	      return (1);
-	    }
-	}
+    int q;
+    if (numof_markets &gt; 0) {
+        for (q = 0; q &lt; numof_markets; q++) {
+            if (MP_INFO(marketx[q], markety[q]).int_5 &gt;= (MAX_ORE_IN_MARKET - ore))
+                continue;
+            if ((abs(marketx[q] - x) &lt; MARKET_RANGE)
+                &amp;&amp; (abs(markety[q] - y) &lt; MARKET_RANGE)) {
+                MP_INFO(marketx[q], markety[q]).int_5 += ore;
+                return (1);
+            }
+        }
     }
-  if (put_stuff (x, y, ore, T_ORE) != 0)
-    return (1);
-  return (0);
+    if (put_stuff(x, y, ore, T_ORE) != 0)
+        return (1);
+    return (0);
 }
 
-
-int
-get_coal (int x, int y, int coal)
+int get_coal(int x, int y, int coal)
 {
-  int q;
-  if (numof_markets &gt; 0)
-    {
-      for (q = 0; q &lt; numof_markets; q++)
-	{
-	  if ((abs (marketx[q] - x) &lt; MARKET_RANGE)
-	      &amp;&amp; (abs (markety[q] - y) &lt; MARKET_RANGE)
-	      &amp;&amp; (MP_INFO(marketx[q],markety[q]).int_3
-		  &gt; coal))
-	    {
-	      MP_INFO(marketx[q],markety[q]).int_3 -= coal;
-	      return (1);
-	    }
-	}
+    int q;
+    if (numof_markets &gt; 0) {
+        for (q = 0; q &lt; numof_markets; q++) {
+            if ((abs(marketx[q] - x) &lt; MARKET_RANGE)
+                &amp;&amp; (abs(markety[q] - y) &lt; MARKET_RANGE)
+                &amp;&amp; (MP_INFO(marketx[q], markety[q]).int_3 &gt; coal)) {
+                MP_INFO(marketx[q], markety[q]).int_3 -= coal;
+                return (1);
+            }
+        }
     }
-  if (get_stuff (x, y, coal, T_COAL) != 0)
-    return (1);
-  return (0);
+    if (get_stuff(x, y, coal, T_COAL) != 0)
+        return (1);
+    return (0);
 }
 
-int
-put_coal (int x, int y, int coal)
+int put_coal(int x, int y, int coal)
 {
-  int q;
-  if (numof_markets &gt; 0)
-    {
-      for (q = 0; q &lt; numof_markets; q++)
-	{
-	  if (MP_INFO(marketx[q],markety[q]).int_3
-	      &gt;= (MAX_COAL_IN_MARKET - coal))
-	    continue;
-	  if ((abs (marketx[q] - x) &lt; MARKET_RANGE)
-	      &amp;&amp; (abs (markety[q] - y) &lt; MARKET_RANGE))
-	    {
-	      MP_INFO(marketx[q],markety[q]).int_3 += coal;
-	      return (1);
-	    }
-	}
+    int q;
+    if (numof_markets &gt; 0) {
+        for (q = 0; q &lt; numof_markets; q++) {
+            if (MP_INFO(marketx[q], markety[q]).int_3 &gt;= (MAX_COAL_IN_MARKET - coal))
+                continue;
+            if ((abs(marketx[q] - x) &lt; MARKET_RANGE)
+                &amp;&amp; (abs(markety[q] - y) &lt; MARKET_RANGE)) {
+                MP_INFO(marketx[q], markety[q]).int_3 += coal;
+                return (1);
+            }
+        }
     }
-  if (put_stuff (x, y, coal, T_COAL) != 0)
-    return (1);
-  return (0);
+    if (put_stuff(x, y, coal, T_COAL) != 0)
+        return (1);
+    return (0);
 }
 
+int add_a_market(int x, int y)
+{                               /* add to marketx markety to list */
+    if (numof_markets &gt;= MAX_NUMOF_MARKETS)
+        return (0);
+    marketx[numof_markets] = x;
+    markety[numof_markets] = y;
+    numof_markets++;
+    /* oh dear. Got to bootstap markets with jobs, otherwise power won't work
+     * GCS: Is this still true?
+     * AL1: FIXME it seems not :) it's just needed to wait for periodic event
+     */
 
-int
-add_a_market (int x, int y)	/* add to marketx markety to list */
-{
-  if (numof_markets &gt;= MAX_NUMOF_MARKETS)
-    return (0);
-  marketx[numof_markets] = x;
-  markety[numof_markets] = y;
-  numof_markets++;
-  /* oh dear. Got to bootstap markets with jobs, otherwise power won't work
-   * GCS: Is this still true?
-   * AL1: FIXME it seems not :) it's just needed to wait for periodic event
-   */
-
-  MP_INFO(x,y).int_2 = 2000;
-  return (1);
+    MP_INFO(x, y).int_2 = 2000;
+    return (1);
 }
 
-void
-remove_a_market (int x, int y)
+void remove_a_market(int x, int y)
 {
-  /* AL1: Could use present jobs to try put_everything elsewhere
-   * at least half of the content
-   */
-  int q;
-  for (q = 0; q &lt; numof_markets; q++)
-    if (marketx[q] == x &amp;&amp; markety[q] == y)
-      break;
-  for (; q &lt; numof_markets; q++)
-    {
-      marketx[q] = marketx[q + 1];
-      markety[q] = markety[q + 1];
+    /* AL1: Could use present jobs to try put_everything elsewhere
+     * at least half of the content
+     */
+    int q;
+    for (q = 0; q &lt; numof_markets; q++)
+        if (marketx[q] == x &amp;&amp; markety[q] == y)
+            break;
+    for (; q &lt; numof_markets; q++) {
+        marketx[q] = marketx[q + 1];
+        markety[q] = markety[q + 1];
     }
-  numof_markets--;
+    numof_markets--;
 }
 
-void
-do_market (int x, int y)
+void do_market(int x, int y)
 {
-  /*
-     //  int_1 contains the food it holds
-     //  int_2 contains the jobs
-     //  int_3 contains the coal
-     //  int_4 contains the goods
-     //  int_5 contains the ore
-     //  int_6 contains the steel
-     //  int_7 contains the waste
-   */
+    /*
+       //  int_1 contains the food it holds
+       //  int_2 contains the jobs
+       //  int_3 contains the coal
+       //  int_4 contains the goods
+       //  int_5 contains the ore
+       //  int_6 contains the steel
+       //  int_7 contains the waste
+     */
 
-  int extra_jobs = 0;
+    int extra_jobs = 0;
 
-  shuffle_markets ();
+    shuffle_markets();
 
-  if (x &gt; 0 &amp;&amp; (MP_INFO(x - 1,y).flags &amp; FLAG_IS_TRANSPORT) != 0)
-    extra_jobs += deal_with_transport (x, y, x - 1, y);
-  if (x &gt; 0 &amp;&amp; (MP_INFO(x - 1,y + 1).flags &amp; FLAG_IS_TRANSPORT) != 0)
-    extra_jobs += deal_with_transport (x, y, x - 1, y + 1);
-  if (y &gt; 0 &amp;&amp; (MP_INFO(x,y - 1).flags &amp; FLAG_IS_TRANSPORT) != 0)
-    extra_jobs += deal_with_transport (x, y, x, y - 1);
-  if (y &gt; 0 &amp;&amp; (MP_INFO(x + 1,y - 1).flags &amp; FLAG_IS_TRANSPORT) != 0)
-    extra_jobs += deal_with_transport (x, y, x + 1, y - 1);
-  if (x &lt; WORLD_SIDE_LEN - 2
-      &amp;&amp; (MP_INFO(x + 2,y).flags &amp; FLAG_IS_TRANSPORT) != 0)
-    extra_jobs += deal_with_transport (x, y, x + 2, y);
-  if (x &lt; WORLD_SIDE_LEN - 2
-      &amp;&amp; (MP_INFO(x + 2,y + 1).flags &amp; FLAG_IS_TRANSPORT) != 0)
-    extra_jobs += deal_with_transport (x, y, x + 2, y + 1);
-  if (y &lt; WORLD_SIDE_LEN - 2
-      &amp;&amp; (MP_INFO(x,y + 2).flags &amp; FLAG_IS_TRANSPORT) != 0)
-    extra_jobs += deal_with_transport (x, y, x, y + 2);
-  if (y &lt; WORLD_SIDE_LEN - 2
-      &amp;&amp; (MP_INFO(x + 1,y + 2).flags &amp; FLAG_IS_TRANSPORT) != 0)
-    extra_jobs += deal_with_transport (x, y, x + 1, y + 2);
+    if (x &gt; 0 &amp;&amp; (MP_INFO(x - 1, y).flags &amp; FLAG_IS_TRANSPORT) != 0)
+        extra_jobs += deal_with_transport(x, y, x - 1, y);
+    if (x &gt; 0 &amp;&amp; (MP_INFO(x - 1, y + 1).flags &amp; FLAG_IS_TRANSPORT) != 0)
+        extra_jobs += deal_with_transport(x, y, x - 1, y + 1);
+    if (y &gt; 0 &amp;&amp; (MP_INFO(x, y - 1).flags &amp; FLAG_IS_TRANSPORT) != 0)
+        extra_jobs += deal_with_transport(x, y, x, y - 1);
+    if (y &gt; 0 &amp;&amp; (MP_INFO(x + 1, y - 1).flags &amp; FLAG_IS_TRANSPORT) != 0)
+        extra_jobs += deal_with_transport(x, y, x + 1, y - 1);
+    if (x &lt; WORLD_SIDE_LEN - 2 &amp;&amp; (MP_INFO(x + 2, y).flags &amp; FLAG_IS_TRANSPORT) != 0)
+        extra_jobs += deal_with_transport(x, y, x + 2, y);
+    if (x &lt; WORLD_SIDE_LEN - 2 &amp;&amp; (MP_INFO(x + 2, y + 1).flags &amp; FLAG_IS_TRANSPORT) != 0)
+        extra_jobs += deal_with_transport(x, y, x + 2, y + 1);
+    if (y &lt; WORLD_SIDE_LEN - 2 &amp;&amp; (MP_INFO(x, y + 2).flags &amp; FLAG_IS_TRANSPORT) != 0)
+        extra_jobs += deal_with_transport(x, y, x, y + 2);
+    if (y &lt; WORLD_SIDE_LEN - 2 &amp;&amp; (MP_INFO(x + 1, y + 2).flags &amp; FLAG_IS_TRANSPORT) != 0)
+        extra_jobs += deal_with_transport(x, y, x + 1, y + 2);
 
-  if (MP_INFO(x,y).int_1 &gt; MAX_FOOD_IN_MARKET)
-    MP_INFO(x,y).int_1 = MAX_FOOD_IN_MARKET;
-  if (MP_INFO(x,y).int_2 &gt; MAX_JOBS_IN_MARKET)
-    MP_INFO(x,y).int_2 = MAX_JOBS_IN_MARKET;
-  if (MP_INFO(x,y).int_4 &gt; MAX_GOODS_IN_MARKET)
-    MP_INFO(x,y).int_4 = MAX_GOODS_IN_MARKET;
+    if (MP_INFO(x, y).int_1 &gt; MAX_FOOD_IN_MARKET)
+        MP_INFO(x, y).int_1 = MAX_FOOD_IN_MARKET;
+    if (MP_INFO(x, y).int_2 &gt; MAX_JOBS_IN_MARKET)
+        MP_INFO(x, y).int_2 = MAX_JOBS_IN_MARKET;
+    if (MP_INFO(x, y).int_4 &gt; MAX_GOODS_IN_MARKET)
+        MP_INFO(x, y).int_4 = MAX_GOODS_IN_MARKET;
 
-  /* now choose a graphic only dependent on food (for now anyway) */
-  if (total_time % 25 == 17)
-    {
-      if (MP_INFO(x,y).int_1 &lt;= 0)
-	{
-	  if (MP_INFO(x,y).int_2 &gt; 0)
-	    MP_TYPE(x,y) = CST_MARKET_LOW;
-	  else
-	    MP_TYPE(x,y) = CST_MARKET_EMPTY;
-	}
-      else if (MP_INFO(x,y).int_1 &lt; (MARKET_FOOD_SEARCH_TRIGGER / 2))
-	MP_TYPE(x,y) = CST_MARKET_LOW;
-      else if (MP_INFO(x,y).int_1
-	       &lt; (MAX_FOOD_IN_MARKET - MAX_FOOD_IN_MARKET / 4))
-	MP_TYPE(x,y) = CST_MARKET_MED;
-      else
-	MP_TYPE(x,y) = CST_MARKET_FULL;
+    /* now choose a graphic only dependent on food (for now anyway) */
+    if (total_time % 25 == 17) {
+        if (MP_INFO(x, y).int_1 &lt;= 0) {
+            if (MP_INFO(x, y).int_2 &gt; 0)
+                MP_TYPE(x, y) = CST_MARKET_LOW;
+            else
+                MP_TYPE(x, y) = CST_MARKET_EMPTY;
+        } else if (MP_INFO(x, y).int_1 &lt; (MARKET_FOOD_SEARCH_TRIGGER / 2))
+            MP_TYPE(x, y) = CST_MARKET_LOW;
+        else if (MP_INFO(x, y).int_1 &lt; (MAX_FOOD_IN_MARKET - MAX_FOOD_IN_MARKET / 4))
+            MP_TYPE(x, y) = CST_MARKET_MED;
+        else
+            MP_TYPE(x, y) = CST_MARKET_FULL;
     }
 
-  /* now employ some people */
-  get_jobs (x, y, 1 + (extra_jobs / 5));
+    /* now employ some people */
+    get_jobs(x, y, 1 + (extra_jobs / 5));
 
-  /* keep the pbars accurate */
-  inventory(x,y);
+    /* keep the pbars accurate */
+    inventory(x, y);
 }
 
-void
-shuffle_markets (void)
+void shuffle_markets(void)
 {
-  register int x;
-  int q, r, m;
-  m = (numof_markets / 4) + 1;
-  for (x = 0; x &lt; m; x++)
-    {
-      r = rand () % numof_markets;
-      if (r == x)
-	continue;
-      q = marketx[x];
-      marketx[x] = marketx[r];
-      marketx[r] = q;
-      q = markety[x];
-      markety[x] = markety[r];
-      markety[r] = q;
+    register int x;
+    int q, r, m;
+    m = (numof_markets / 4) + 1;
+    for (x = 0; x &lt; m; x++) {
+        r = rand() % numof_markets;
+        if (r == x)
+            continue;
+        q = marketx[x];
+        marketx[x] = marketx[r];
+        marketx[r] = q;
+        q = markety[x];
+        markety[x] = markety[r];
+        markety[r] = q;
     }
 }
 
-
-int
-deal_with_transport (int x, int y, int tx, int ty)
+int deal_with_transport(int x, int y, int tx, int ty)
 {
-  int i, r, extra_jobs = 3, flags;
-  flags = MP_INFO(x,y).flags;
-  /* tracks */
-  if (MP_GROUP(tx,ty) == GROUP_TRACK)
-    {
-      /* food */
-      if ((flags &amp; FLAG_MB_FOOD) != 0)
-	{
-	  r = (MAX_FOOD_IN_MARKET * 1000)
-	    / (MAX_FOOD_ON_TRACK + MAX_FOOD_IN_MARKET);
-	  i = MP_INFO(x,y).int_1 + MP_INFO(tx,ty).int_1;
-	  MP_INFO(x,y).int_1 = (i * r) / 1000;
-	  MP_INFO(tx,ty).int_1 = i - MP_INFO(x,y).int_1;
-	}
+    int i, r, extra_jobs = 3, flags;
+    flags = MP_INFO(x, y).flags;
+    /* tracks */
+    if (MP_GROUP(tx, ty) == GROUP_TRACK) {
+        /* food */
+        if ((flags &amp; FLAG_MB_FOOD) != 0) {
+            r = (MAX_FOOD_IN_MARKET * 1000)
+                / (MAX_FOOD_ON_TRACK + MAX_FOOD_IN_MARKET);
+            i = MP_INFO(x, y).int_1 + MP_INFO(tx, ty).int_1;
+            MP_INFO(x, y).int_1 = (i * r) / 1000;
+            MP_INFO(tx, ty).int_1 = i - MP_INFO(x, y).int_1;
+        }
 
-      /* jobs */
-      if ((flags &amp; FLAG_MB_JOBS) != 0)
-	{
-	  r = (MAX_JOBS_IN_MARKET * 1000)
-	    / (MAX_JOBS_ON_TRACK + MAX_JOBS_IN_MARKET);
-	  i = MP_INFO(x,y).int_2 + MP_INFO(tx,ty).int_2;
-	  MP_INFO(x,y).int_2 = (i * r) / 1000;
-	  MP_INFO(tx,ty).int_2 = i - MP_INFO(x,y).int_2;
-	}
+        /* jobs */
+        if ((flags &amp; FLAG_MB_JOBS) != 0) {
+            r = (MAX_JOBS_IN_MARKET * 1000)
+                / (MAX_JOBS_ON_TRACK + MAX_JOBS_IN_MARKET);
+            i = MP_INFO(x, y).int_2 + MP_INFO(tx, ty).int_2;
+            MP_INFO(x, y).int_2 = (i * r) / 1000;
+            MP_INFO(tx, ty).int_2 = i - MP_INFO(x, y).int_2;
+        }
 
-      /* coal */
-      if ((flags &amp; FLAG_MB_COAL) != 0)
-	{
-	  r = (MAX_COAL_IN_MARKET * 1000)
-	    / (MAX_COAL_ON_TRACK + MAX_COAL_IN_MARKET);
-	  i = MP_INFO(x,y).int_3 + MP_INFO(tx,ty).int_3;
-	  MP_INFO(x,y).int_3 = (i * r) / 1000;
-	  MP_INFO(tx,ty).int_3 = i - MP_INFO(x,y).int_3;
-	}
+        /* coal */
+        if ((flags &amp; FLAG_MB_COAL) != 0) {
+            r = (MAX_COAL_IN_MARKET * 1000)
+                / (MAX_COAL_ON_TRACK + MAX_COAL_IN_MARKET);
+            i = MP_INFO(x, y).int_3 + MP_INFO(tx, ty).int_3;
+            MP_INFO(x, y).int_3 = (i * r) / 1000;
+            MP_INFO(tx, ty).int_3 = i - MP_INFO(x, y).int_3;
+        }
 
-      /* goods */
-      if ((flags &amp; FLAG_MB_GOODS) != 0)
-	{
-	  r = (MAX_GOODS_IN_MARKET * 1000)
-	    / (MAX_GOODS_ON_TRACK + MAX_GOODS_IN_MARKET);
-	  i = MP_INFO(x,y).int_4 + MP_INFO(tx,ty).int_4;
-	  MP_INFO(x,y).int_4 = (i * r) / 1000;
-	  MP_INFO(tx,ty).int_4 = i - MP_INFO(x,y).int_4;
-	}
+        /* goods */
+        if ((flags &amp; FLAG_MB_GOODS) != 0) {
+            r = (MAX_GOODS_IN_MARKET * 1000)
+                / (MAX_GOODS_ON_TRACK + MAX_GOODS_IN_MARKET);
+            i = MP_INFO(x, y).int_4 + MP_INFO(tx, ty).int_4;
+            MP_INFO(x, y).int_4 = (i * r) / 1000;
+            MP_INFO(tx, ty).int_4 = i - MP_INFO(x, y).int_4;
+        }
 
-      /* ore */
-      if ((flags &amp; FLAG_MB_ORE) != 0)
-	{
-	  r = (MAX_ORE_IN_MARKET * 1000)
-	    / (MAX_ORE_ON_TRACK + MAX_ORE_IN_MARKET);
-	  i = MP_INFO(x,y).int_5 + MP_INFO(tx,ty).int_5;
-	  MP_INFO(x,y).int_5 = (i * r) / 1000;
-	  MP_INFO(tx,ty).int_5 = i - MP_INFO(x,y).int_5;
-	}
+        /* ore */
+        if ((flags &amp; FLAG_MB_ORE) != 0) {
+            r = (MAX_ORE_IN_MARKET * 1000)
+                / (MAX_ORE_ON_TRACK + MAX_ORE_IN_MARKET);
+            i = MP_INFO(x, y).int_5 + MP_INFO(tx, ty).int_5;
+            MP_INFO(x, y).int_5 = (i * r) / 1000;
+            MP_INFO(tx, ty).int_5 = i - MP_INFO(x, y).int_5;
+        }
 
+        /* steel */
+        if ((flags &amp; FLAG_MB_STEEL) != 0) {
+            r = (MAX_STEEL_IN_MARKET * 1000)
+                / (MAX_STEEL_ON_TRACK + MAX_STEEL_IN_MARKET);
+            i = MP_INFO(x, y).int_6 + MP_INFO(tx, ty).int_6;
+            MP_INFO(x, y).int_6 = (i * r) / 1000;
+            MP_INFO(tx, ty).int_6 = i - MP_INFO(x, y).int_6;
+        }
 
-      /* steel */
-      if ((flags &amp; FLAG_MB_STEEL) != 0)
-	{
-	  r = (MAX_STEEL_IN_MARKET * 1000)
-	    / (MAX_STEEL_ON_TRACK + MAX_STEEL_IN_MARKET);
-	  i = MP_INFO(x,y).int_6 + MP_INFO(tx,ty).int_6;
-	  MP_INFO(x,y).int_6 = (i * r) / 1000;
-	  MP_INFO(tx,ty).int_6 = i - MP_INFO(x,y).int_6;
-	}
+        /* waste */
+        r = (MAX_WASTE_IN_MARKET * 1000)
+            / (MAX_WASTE_ON_TRACK + MAX_WASTE_IN_MARKET);
+        i = MP_INFO(x, y).int_7 + MP_INFO(tx, ty).int_7;
+        MP_INFO(x, y).int_7 = (i * r) / 1000;
+        MP_INFO(tx, ty).int_7 = i - MP_INFO(x, y).int_7;
 
-      /* waste */
-      r = (MAX_WASTE_IN_MARKET * 1000)
-	/ (MAX_WASTE_ON_TRACK + MAX_WASTE_IN_MARKET);
-      i = MP_INFO(x,y).int_7 + MP_INFO(tx,ty).int_7;
-      MP_INFO(x,y).int_7 = (i * r) / 1000;
-      MP_INFO(tx,ty).int_7 = i - MP_INFO(x,y).int_7;
-
-
-      /* if it's full of waste, burn some to make pollution. */
-      if (MP_INFO(x,y).int_7 &gt;= (99 * MAX_WASTE_IN_MARKET / 100))
-	{
-	  MP_POL(x,y) += 3000;
-	  MP_INFO(x,y).int_7 -= (7 * MAX_WASTE_IN_MARKET) / 10;
+        /* if it's full of waste, burn some to make pollution. */
+        if (MP_INFO(x, y).int_7 &gt;= (99 * MAX_WASTE_IN_MARKET / 100)) {
+            MP_POL(x, y) += 3000;
+            MP_INFO(x, y).int_7 -= (7 * MAX_WASTE_IN_MARKET) / 10;
 #if defined (commentout)
-	  /* this should fire up the pollution mini screen within a second.
-           * AL1: oh this is not implemented in NG :(
-           * This works only with oldgui
-           */
-	  mini_screen_flags = MINI_SCREEN_POL_FLAG;
+            /* this should fire up the pollution mini screen within a second.
+             * AL1: oh this is not implemented in NG :(
+             * This works only with oldgui
+             */
+            mini_screen_flags = MINI_SCREEN_POL_FLAG;
 #endif
-	}
+        }
     }
 
+    /* do rail traffic */
+    else if (MP_GROUP(tx, ty) == GROUP_RAIL) {
+        /* food */
+        if ((flags &amp; FLAG_MB_FOOD) != 0) {
+            r = (MAX_FOOD_IN_MARKET * 1000)
+                / (MAX_FOOD_ON_RAIL + MAX_FOOD_IN_MARKET);
+            i = MP_INFO(x, y).int_1 + MP_INFO(tx, ty).int_1;
+            MP_INFO(x, y).int_1 = (i * r) / 1000;
+            MP_INFO(tx, ty).int_1 = i - MP_INFO(x, y).int_1;
+        }
 
-  /* do rail traffic */
-  else if (MP_GROUP(tx,ty) == GROUP_RAIL)
-    {
-      /* food */
-      if ((flags &amp; FLAG_MB_FOOD) != 0)
-	{
-	  r = (MAX_FOOD_IN_MARKET * 1000)
-	    / (MAX_FOOD_ON_RAIL + MAX_FOOD_IN_MARKET);
-	  i = MP_INFO(x,y).int_1 + MP_INFO(tx,ty).int_1;
-	  MP_INFO(x,y).int_1 = (i * r) / 1000;
-	  MP_INFO(tx,ty).int_1 = i - MP_INFO(x,y).int_1;
-	}
+        /* jobs */
+        if ((flags &amp; FLAG_MB_JOBS) != 0) {
+            r = (MAX_JOBS_IN_MARKET * 1000)
+                / (MAX_JOBS_ON_RAIL + MAX_JOBS_IN_MARKET);
+            i = MP_INFO(x, y).int_2 + MP_INFO(tx, ty).int_2;
+            MP_INFO(x, y).int_2 = (i * r) / 1000;
+            MP_INFO(tx, ty).int_2 = i - MP_INFO(x, y).int_2;
+        }
 
-      /* jobs */
-      if ((flags &amp; FLAG_MB_JOBS) != 0)
-	{
-	  r = (MAX_JOBS_IN_MARKET * 1000)
-	    / (MAX_JOBS_ON_RAIL + MAX_JOBS_IN_MARKET);
-	  i = MP_INFO(x,y).int_2 + MP_INFO(tx,ty).int_2;
-	  MP_INFO(x,y).int_2 = (i * r) / 1000;
-	  MP_INFO(tx,ty).int_2 = i - MP_INFO(x,y).int_2;
-	}
+        /* coal */
+        if ((flags &amp; FLAG_MB_COAL) != 0) {
+            r = (MAX_COAL_IN_MARKET * 1000)
+                / (MAX_COAL_ON_RAIL + MAX_COAL_IN_MARKET);
+            i = MP_INFO(x, y).int_3 + MP_INFO(tx, ty).int_3;
+            MP_INFO(x, y).int_3 = (i * r) / 1000;
+            MP_INFO(tx, ty).int_3 = i - MP_INFO(x, y).int_3;
+        }
 
-      /* coal */
-      if ((flags &amp; FLAG_MB_COAL) != 0)
-	{
-	  r = (MAX_COAL_IN_MARKET * 1000)
-	    / (MAX_COAL_ON_RAIL + MAX_COAL_IN_MARKET);
-	  i = MP_INFO(x,y).int_3 + MP_INFO(tx,ty).int_3;
-	  MP_INFO(x,y).int_3 = (i * r) / 1000;
-	  MP_INFO(tx,ty).int_3 = i - MP_INFO(x,y).int_3;
-	}
+        /* goods */
+        if ((flags &amp; FLAG_MB_GOODS) != 0) {
+            r = (MAX_GOODS_IN_MARKET * 1000)
+                / (MAX_GOODS_ON_RAIL + MAX_GOODS_IN_MARKET);
+            i = MP_INFO(x, y).int_4 + MP_INFO(tx, ty).int_4;
+            MP_INFO(x, y).int_4 = (i * r) / 1000;
+            MP_INFO(tx, ty).int_4 = i - MP_INFO(x, y).int_4;
+        }
 
-      /* goods */
-      if ((flags &amp; FLAG_MB_GOODS) != 0)
-	{
-	  r = (MAX_GOODS_IN_MARKET * 1000)
-	    / (MAX_GOODS_ON_RAIL + MAX_GOODS_IN_MARKET);
-	  i = MP_INFO(x,y).int_4 + MP_INFO(tx,ty).int_4;
-	  MP_INFO(x,y).int_4 = (i * r) / 1000;
-	  MP_INFO(tx,ty).int_4 = i - MP_INFO(x,y).int_4;
-	}
+        /* ore */
+        if ((flags &amp; FLAG_MB_ORE) != 0) {
+            r = (MAX_ORE_IN_MARKET * 1000)
+                / (MAX_ORE_ON_RAIL + MAX_ORE_IN_MARKET);
+            i = MP_INFO(x, y).int_5 + MP_INFO(tx, ty).int_5;
+            MP_INFO(x, y).int_5 = (i * r) / 1000;
+            MP_INFO(tx, ty).int_5 = i - MP_INFO(x, y).int_5;
+        }
 
-      /* ore */
-      if ((flags &amp; FLAG_MB_ORE) != 0)
-	{
-	  r = (MAX_ORE_IN_MARKET * 1000)
-	    / (MAX_ORE_ON_RAIL + MAX_ORE_IN_MARKET);
-	  i = MP_INFO(x,y).int_5 + MP_INFO(tx,ty).int_5;
-	  MP_INFO(x,y).int_5 = (i * r) / 1000;
-	  MP_INFO(tx,ty).int_5 = i - MP_INFO(x,y).int_5;
-	}
+        /* steel */
+        if ((flags &amp; FLAG_MB_STEEL) != 0) {
+            r = (MAX_STEEL_IN_MARKET * 1000)
+                / (MAX_STEEL_ON_RAIL + MAX_STEEL_IN_MARKET);
+            i = MP_INFO(x, y).int_6 + MP_INFO(tx, ty).int_6;
+            MP_INFO(x, y).int_6 = (i * r) / 1000;
+            MP_INFO(tx, ty).int_6 = i - MP_INFO(x, y).int_6;
+        }
 
-      /* steel */
-      if ((flags &amp; FLAG_MB_STEEL) != 0)
-	{
-	  r = (MAX_STEEL_IN_MARKET * 1000)
-	    / (MAX_STEEL_ON_RAIL + MAX_STEEL_IN_MARKET);
-	  i = MP_INFO(x,y).int_6 + MP_INFO(tx,ty).int_6;
-	  MP_INFO(x,y).int_6 = (i * r) / 1000;
-	  MP_INFO(tx,ty).int_6 = i - MP_INFO(x,y).int_6;
-	}
+        /* waste */
+        r = (MAX_WASTE_IN_MARKET * 1000)
+            / (MAX_WASTE_ON_RAIL + MAX_WASTE_IN_MARKET);
+        i = MP_INFO(x, y).int_7 + MP_INFO(tx, ty).int_7;
+        MP_INFO(x, y).int_7 = (i * r) / 1000;
+        MP_INFO(tx, ty).int_7 = i - MP_INFO(x, y).int_7;
 
-      /* waste */
-      r = (MAX_WASTE_IN_MARKET * 1000)
-	/ (MAX_WASTE_ON_RAIL + MAX_WASTE_IN_MARKET);
-      i = MP_INFO(x,y).int_7 + MP_INFO(tx,ty).int_7;
-      MP_INFO(x,y).int_7 = (i * r) / 1000;
-      MP_INFO(tx,ty).int_7 = i - MP_INFO(x,y).int_7;
-
     }
 
-  /* do road traffic */
-  else if (MP_GROUP(tx,ty) == GROUP_ROAD)
-    {
-      /* food */
-      if ((flags &amp; FLAG_MB_FOOD) != 0)
-	{
-	  r = (MAX_FOOD_IN_MARKET * 1000)
-	    / (MAX_FOOD_ON_ROAD + MAX_FOOD_IN_MARKET);
-	  i = MP_INFO(x,y).int_1 + MP_INFO(tx,ty).int_1;
-	  MP_INFO(x,y).int_1 = (i * r) / 1000;
-	  MP_INFO(tx,ty).int_1 = i - MP_INFO(x,y).int_1;
-	}
+    /* do road traffic */
+    else if (MP_GROUP(tx, ty) == GROUP_ROAD) {
+        /* food */
+        if ((flags &amp; FLAG_MB_FOOD) != 0) {
+            r = (MAX_FOOD_IN_MARKET * 1000)
+                / (MAX_FOOD_ON_ROAD + MAX_FOOD_IN_MARKET);
+            i = MP_INFO(x, y).int_1 + MP_INFO(tx, ty).int_1;
+            MP_INFO(x, y).int_1 = (i * r) / 1000;
+            MP_INFO(tx, ty).int_1 = i - MP_INFO(x, y).int_1;
+        }
 
-      /* jobs */
-      if ((flags &amp; FLAG_MB_JOBS) != 0)
-	{
-	  r = (MAX_JOBS_IN_MARKET * 1000)
-	    / (MAX_JOBS_ON_ROAD + MAX_JOBS_IN_MARKET);
-	  i = MP_INFO(x,y).int_2 + MP_INFO(tx,ty).int_2;
-	  MP_INFO(x,y).int_2 = (i * r) / 1000;
-	  MP_INFO(tx,ty).int_2 = i - MP_INFO(x,y).int_2;
-	}
+        /* jobs */
+        if ((flags &amp; FLAG_MB_JOBS) != 0) {
+            r = (MAX_JOBS_IN_MARKET * 1000)
+                / (MAX_JOBS_ON_ROAD + MAX_JOBS_IN_MARKET);
+            i = MP_INFO(x, y).int_2 + MP_INFO(tx, ty).int_2;
+            MP_INFO(x, y).int_2 = (i * r) / 1000;
+            MP_INFO(tx, ty).int_2 = i - MP_INFO(x, y).int_2;
+        }
 
-      /* coal */
-      if ((flags &amp; FLAG_MB_COAL) != 0)
-	{
-	  r = (MAX_COAL_IN_MARKET * 1000)
-	    / (MAX_COAL_ON_ROAD + MAX_COAL_IN_MARKET);
-	  i = MP_INFO(x,y).int_3 + MP_INFO(tx,ty).int_3;
-	  MP_INFO(x,y).int_3 = (i * r) / 1000;
-	  MP_INFO(tx,ty).int_3 = i - MP_INFO(x,y).int_3;
-	}
+        /* coal */
+        if ((flags &amp; FLAG_MB_COAL) != 0) {
+            r = (MAX_COAL_IN_MARKET * 1000)
+                / (MAX_COAL_ON_ROAD + MAX_COAL_IN_MARKET);
+            i = MP_INFO(x, y).int_3 + MP_INFO(tx, ty).int_3;
+            MP_INFO(x, y).int_3 = (i * r) / 1000;
+            MP_INFO(tx, ty).int_3 = i - MP_INFO(x, y).int_3;
+        }
 
-      /* goods */
-      if ((flags &amp; FLAG_MB_GOODS) != 0)
-	{
-	  r = (MAX_GOODS_IN_MARKET * 1000)
-	    / (MAX_GOODS_ON_ROAD + MAX_GOODS_IN_MARKET);
-	  i = MP_INFO(x,y).int_4 + MP_INFO(tx,ty).int_4;
-	  MP_INFO(x,y).int_4 = (i * r) / 1000;
-	  MP_INFO(tx,ty).int_4 = i - MP_INFO(x,y).int_4;
-	}
+        /* goods */
+        if ((flags &amp; FLAG_MB_GOODS) != 0) {
+            r = (MAX_GOODS_IN_MARKET * 1000)
+                / (MAX_GOODS_ON_ROAD + MAX_GOODS_IN_MARKET);
+            i = MP_INFO(x, y).int_4 + MP_INFO(tx, ty).int_4;
+            MP_INFO(x, y).int_4 = (i * r) / 1000;
+            MP_INFO(tx, ty).int_4 = i - MP_INFO(x, y).int_4;
+        }
 
-      /* ore */
-      if ((flags &amp; FLAG_MB_ORE) != 0)
-	{
-	  r = (MAX_ORE_IN_MARKET * 1000)
-	    / (MAX_ORE_ON_ROAD + MAX_ORE_IN_MARKET);
-	  i = MP_INFO(x,y).int_5 + MP_INFO(tx,ty).int_5;
-	  MP_INFO(x,y).int_5 = (i * r) / 1000;
-	  MP_INFO(tx,ty).int_5 = i - MP_INFO(x,y).int_5;
-	}
+        /* ore */
+        if ((flags &amp; FLAG_MB_ORE) != 0) {
+            r = (MAX_ORE_IN_MARKET * 1000)
+                / (MAX_ORE_ON_ROAD + MAX_ORE_IN_MARKET);
+            i = MP_INFO(x, y).int_5 + MP_INFO(tx, ty).int_5;
+            MP_INFO(x, y).int_5 = (i * r) / 1000;
+            MP_INFO(tx, ty).int_5 = i - MP_INFO(x, y).int_5;
+        }
 
-      /* steel */
-      if ((flags &amp; FLAG_MB_STEEL) != 0)
-	{
-	  r = (MAX_STEEL_IN_MARKET * 1000)
-	    / (MAX_STEEL_ON_ROAD + MAX_STEEL_IN_MARKET);
-	  i = MP_INFO(x,y).int_6 + MP_INFO(tx,ty).int_6;
-	  MP_INFO(x,y).int_6 = (i * r) / 1000;
-	  MP_INFO(tx,ty).int_6 = i - MP_INFO(x,y).int_6;
-	}
+        /* steel */
+        if ((flags &amp; FLAG_MB_STEEL) != 0) {
+            r = (MAX_STEEL_IN_MARKET * 1000)
+                / (MAX_STEEL_ON_ROAD + MAX_STEEL_IN_MARKET);
+            i = MP_INFO(x, y).int_6 + MP_INFO(tx, ty).int_6;
+            MP_INFO(x, y).int_6 = (i * r) / 1000;
+            MP_INFO(tx, ty).int_6 = i - MP_INFO(x, y).int_6;
+        }
 
-      /* waste */
-      r = (MAX_WASTE_IN_MARKET * 1000)
-	/ (MAX_WASTE_ON_ROAD + MAX_WASTE_IN_MARKET);
-      i = MP_INFO(x,y).int_7 + MP_INFO(tx,ty).int_7;
-      MP_INFO(x,y).int_7 = (i * r) / 1000;
-      MP_INFO(tx,ty).int_7 = i - MP_INFO(x,y).int_7;
-    }
-  else
-    extra_jobs = 0;
+        /* waste */
+        r = (MAX_WASTE_IN_MARKET * 1000)
+            / (MAX_WASTE_ON_ROAD + MAX_WASTE_IN_MARKET);
+        i = MP_INFO(x, y).int_7 + MP_INFO(tx, ty).int_7;
+        MP_INFO(x, y).int_7 = (i * r) / 1000;
+        MP_INFO(tx, ty).int_7 = i - MP_INFO(x, y).int_7;
+    } else
+        extra_jobs = 0;
 
-  return (extra_jobs);
+    return (extra_jobs);
 }
 
-int
-get_stuff (int x, int y, int stuff, int stuff_type)
+int get_stuff(int x, int y, int stuff, int stuff_type)
 {
-  int res = 0;
-  Map_Point_Info *minfo = &amp;MP_INFO(x,y);
+    int res = 0;
+    Map_Point_Info *minfo = &amp;MP_INFO(x, y);
 
-  switch (MP_SIZE(x,y))
-    {
+    switch (MP_SIZE(x, y)) {
     case 2:
-      res = get_stuff2 (minfo, stuff, stuff_type);
-      break;
+        res = get_stuff2(minfo, stuff, stuff_type);
+        break;
     case 3:
-      res = get_stuff3 (minfo, stuff, stuff_type);
-      break;
+        res = get_stuff3(minfo, stuff, stuff_type);
+        break;
     case 4:
-      res = get_stuff4 (minfo, stuff, stuff_type);
-      break;
+        res = get_stuff4(minfo, stuff, stuff_type);
+        break;
     default:
-      do_error (&quot;Bad area size in get_stuff()&quot;);
+        do_error(&quot;Bad area size in get_stuff()&quot;);
     }
-  return (res);
+    return (res);
 }
 
-static const int
-  t2[8] =
-{
-  -1,
-  WORLD_SIDE_LEN - 1,
-  2 * WORLD_SIDE_LEN,
-  2 * WORLD_SIDE_LEN + 1,
-  WORLD_SIDE_LEN + 2,
-  2,
-  1 - WORLD_SIDE_LEN,
-  -WORLD_SIDE_LEN
+static const int t2[8] = {
+    -1,
+    WORLD_SIDE_LEN - 1,
+    2 * WORLD_SIDE_LEN,
+    2 * WORLD_SIDE_LEN + 1,
+    WORLD_SIDE_LEN + 2,
+    2,
+    1 - WORLD_SIDE_LEN,
+    -WORLD_SIDE_LEN
 };
 
 /* worth inlining -- (ThMO) */
-int
-get_stuff2 (Map_Point_Info *map, int stuff, int stuff_type)
+int get_stuff2(Map_Point_Info * map, int stuff, int stuff_type)
 {
-  static int tstart2 = 0;
-  int i, st, tst, *ip, *stack[8], **ssp;	/* stack is a pipe -- (ThMO) */
+    static int tstart2 = 0;
+    int i, st, tst, *ip, *stack[8], **ssp;      /* stack is a pipe -- (ThMO) */
 
-  /* we'll stack our found pointers so to avoid re-looping and
-   * testing again (ThMO) */
+    /* we'll stack our found pointers so to avoid re-looping and
+     * testing again (ThMO) */
 
-  tst = tstart2;
+    tst = tstart2;
 
-  /* can we find enough on the transport? */
+    /* can we find enough on the transport? */
 
-  for (ssp = stack, st = 0, i = 0; i &lt; 8; i++)
-    {
-      if (map[t2[tst]].flags &amp; FLAG_IS_TRANSPORT)
-	{
-	  ip = &amp;map[t2[tst]].int_1;
-	  ip += stuff_type;
-	  st += *ip;
-	  *ssp++ = ip;		/* push it -- (ThMO) */
-	  if (st &gt;= stuff)
-	    {
-	      ssp = stack;
-	      do
-		{
-		  ip = *ssp++;	/* pop it -- (ThMO) */
-		  *ip = (stuff -= *ip) &lt; 0 ? -stuff : 0;
-		}
-	      while (stuff &gt; 0);
-	      tstart2 = ++tst &amp; 7;
-	      return (1);
-	    }
-	}
-      if (++tst &gt;= 8)
-	tst = 0;
+    for (ssp = stack, st = 0, i = 0; i &lt; 8; i++) {
+        if (map[t2[tst]].flags &amp; FLAG_IS_TRANSPORT) {
+            ip = &amp;map[t2[tst]].int_1;
+            ip += stuff_type;
+            st += *ip;
+            *ssp++ = ip;        /* push it -- (ThMO) */
+            if (st &gt;= stuff) {
+                ssp = stack;
+                do {
+                    ip = *ssp++;        /* pop it -- (ThMO) */
+                    *ip = (stuff -= *ip) &lt; 0 ? -stuff : 0;
+                }
+                while (stuff &gt; 0);
+                tstart2 = ++tst &amp; 7;
+                return (1);
+            }
+        }
+        if (++tst &gt;= 8)
+            tst = 0;
     }
-  return (0);
+    return (0);
 }
 
-static const int
-  t3[12] =
-{
-  -1,
-  WORLD_SIDE_LEN - 1,
-  2 * WORLD_SIDE_LEN - 1,
-  3 * WORLD_SIDE_LEN,
-  3 * WORLD_SIDE_LEN + 1,
-  3 * WORLD_SIDE_LEN + 2,
-  2 * WORLD_SIDE_LEN + 3,
-  WORLD_SIDE_LEN + 3,
-  3,
-  2 - WORLD_SIDE_LEN,
-  1 - WORLD_SIDE_LEN,
-  -WORLD_SIDE_LEN
+static const int t3[12] = {
+    -1,
+    WORLD_SIDE_LEN - 1,
+    2 * WORLD_SIDE_LEN - 1,
+    3 * WORLD_SIDE_LEN,
+    3 * WORLD_SIDE_LEN + 1,
+    3 * WORLD_SIDE_LEN + 2,
+    2 * WORLD_SIDE_LEN + 3,
+    WORLD_SIDE_LEN + 3,
+    3,
+    2 - WORLD_SIDE_LEN,
+    1 - WORLD_SIDE_LEN,
+    -WORLD_SIDE_LEN
 };
 
 /* worth inlining -- (ThMO) */
-int
-get_stuff3 (Map_Point_Info *map, int stuff, int stuff_type)
+int get_stuff3(Map_Point_Info * map, int stuff, int stuff_type)
 {
-  static int tstart3 = 0;
+    static int tstart3 = 0;
 
-  int i, st, tst, *ip, *stack[12], **ssp;	/* stack is a pipe -- (ThMO) */
+    int i, st, tst, *ip, *stack[12], **ssp;     /* stack is a pipe -- (ThMO) */
 
-  /* we'll stack our found pointers so to avoid re-looping and
-   * testing again
-   * (ThMO)
-   */
+    /* we'll stack our found pointers so to avoid re-looping and
+     * testing again
+     * (ThMO)
+     */
 
-  tst = tstart3;
+    tst = tstart3;
 
-  /* can we find enough on the transport? */
+    /* can we find enough on the transport? */
 
-  for (ssp = stack, st = 0, i = 0; i &lt; 12; i++)
-    {
-      if (map[t3[tst]].flags &amp; FLAG_IS_TRANSPORT)
-	{
-	  ip = &amp;map[t3[tst]].int_1;
-	  ip += stuff_type;
-	  st += *ip;
-	  *ssp++ = ip;		/* push it -- (ThMO) */
-	  if (st &gt;= stuff)
-	    {
-	      ssp = stack;
-	      do
-		{
-		  ip = *ssp++;	/* pop it -- (ThMO) */
-		  *ip = (stuff -= *ip) &lt; 0 ? -stuff : 0;
-		}
-	      while (stuff &gt; 0);
-	      ++tst;
-	      tstart3 = tst &gt;= 12 ? 0 : tst;
-	      return (1);
-	    }
-	}
-      if (++tst &gt;= 12)
-	tst = 0;
+    for (ssp = stack, st = 0, i = 0; i &lt; 12; i++) {
+        if (map[t3[tst]].flags &amp; FLAG_IS_TRANSPORT) {
+            ip = &amp;map[t3[tst]].int_1;
+            ip += stuff_type;
+            st += *ip;
+            *ssp++ = ip;        /* push it -- (ThMO) */
+            if (st &gt;= stuff) {
+                ssp = stack;
+                do {
+                    ip = *ssp++;        /* pop it -- (ThMO) */
+                    *ip = (stuff -= *ip) &lt; 0 ? -stuff : 0;
+                }
+                while (stuff &gt; 0);
+                ++tst;
+                tstart3 = tst &gt;= 12 ? 0 : tst;
+                return (1);
+            }
+        }
+        if (++tst &gt;= 12)
+            tst = 0;
     }
-  return (0);
+    return (0);
 }
 
-static const int
-  t4[16] =
-{
-  -1,
-  WORLD_SIDE_LEN - 1,
-  2 * WORLD_SIDE_LEN - 1,
-  3 * WORLD_SIDE_LEN - 1,
-  4 * WORLD_SIDE_LEN,
-  4 * WORLD_SIDE_LEN + 1,
-  4 * WORLD_SIDE_LEN + 2,
-  4 * WORLD_SIDE_LEN + 3,
-  3 * WORLD_SIDE_LEN + 4,
-  2 * WORLD_SIDE_LEN + 4,
-  WORLD_SIDE_LEN + 4,
-  4,
-  3 - WORLD_SIDE_LEN,
-  2 - WORLD_SIDE_LEN,
-  1 - WORLD_SIDE_LEN,
-  -WORLD_SIDE_LEN
+static const int t4[16] = {
+    -1,
+    WORLD_SIDE_LEN - 1,
+    2 * WORLD_SIDE_LEN - 1,
+    3 * WORLD_SIDE_LEN - 1,
+    4 * WORLD_SIDE_LEN,
+    4 * WORLD_SIDE_LEN + 1,
+    4 * WORLD_SIDE_LEN + 2,
+    4 * WORLD_SIDE_LEN + 3,
+    3 * WORLD_SIDE_LEN + 4,
+    2 * WORLD_SIDE_LEN + 4,
+    WORLD_SIDE_LEN + 4,
+    4,
+    3 - WORLD_SIDE_LEN,
+    2 - WORLD_SIDE_LEN,
+    1 - WORLD_SIDE_LEN,
+    -WORLD_SIDE_LEN
 };
 
 /* worth inlining -- (ThMO) */
-int
-get_stuff4 (Map_Point_Info *map, int stuff, int stuff_type)
+int get_stuff4(Map_Point_Info * map, int stuff, int stuff_type)
 {
-  static int
-    tstart4 = 0;
+    static int tstart4 = 0;
 
-  int i, st, tst, *ip, *stack[16], **ssp;	/* stack is a pipe -- (ThMO) */
+    int i, st, tst, *ip, *stack[16], **ssp;     /* stack is a pipe -- (ThMO) */
 
-  /* we'll stack our found pointers so to avoid re-looping and
-   * testing again
-   * (ThMO)
-   */
+    /* we'll stack our found pointers so to avoid re-looping and
+     * testing again
+     * (ThMO)
+     */
 
-  tst = tstart4;
+    tst = tstart4;
 
-  /* can we find enough on the transport? */
+    /* can we find enough on the transport? */
 
-  for (ssp = stack, st = 0, i = 0; i &lt; 16; i++)
-    {
-      if (map[t4[tst]].flags &amp; FLAG_IS_TRANSPORT)
-	{
-	  ip = &amp;map[t4[tst]].int_1;
-	  ip += stuff_type;
-	  st += *ip;
-	  *ssp++ = ip;		/* push it -- (ThMO) */
-	  if (st &gt;= stuff)
-	    {
-	      ssp = stack;
-	      do
-		{
-		  ip = *ssp++;	/* pop it -- (ThMO) */
-		  *ip = (stuff -= *ip) &lt; 0 ? -stuff : 0;
-		}
-	      while (stuff &gt; 0);
-	      tstart4 = ++tst &amp; 15;
-	      return (1);
-	    }
-	}
-      if (++tst &gt;= 16)
-	tst = 0;
+    for (ssp = stack, st = 0, i = 0; i &lt; 16; i++) {
+        if (map[t4[tst]].flags &amp; FLAG_IS_TRANSPORT) {
+            ip = &amp;map[t4[tst]].int_1;
+            ip += stuff_type;
+            st += *ip;
+            *ssp++ = ip;        /* push it -- (ThMO) */
+            if (st &gt;= stuff) {
+                ssp = stack;
+                do {
+                    ip = *ssp++;        /* pop it -- (ThMO) */
+                    *ip = (stuff -= *ip) &lt; 0 ? -stuff : 0;
+                }
+                while (stuff &gt; 0);
+                tstart4 = ++tst &amp; 15;
+                return (1);
+            }
+        }
+        if (++tst &gt;= 16)
+            tst = 0;
     }
-  return (0);
+    return (0);
 }
 
-int
-put_stuff (int x, int y, int stuff, int stuff_type)
+int put_stuff(int x, int y, int stuff, int stuff_type)
 {
     int res = 0;
-    short *type = &amp;MP_TYPE(x,y);
-    Map_Point_Info *minfo = &amp;MP_INFO(x,y);
-    switch (MP_SIZE(x,y))
-    {
+    short *type = &amp;MP_TYPE(x, y);
+    Map_Point_Info *minfo = &amp;MP_INFO(x, y);
+    switch (MP_SIZE(x, y)) {
     case 2:
-	res = put_stuff2 (minfo, type, stuff, stuff_type);
-	break;
+        res = put_stuff2(minfo, type, stuff, stuff_type);
+        break;
     case 3:
-	res = put_stuff3 (minfo, type, stuff, stuff_type);
-	break;
+        res = put_stuff3(minfo, type, stuff, stuff_type);
+        break;
     case 4:
-	res = put_stuff4 (minfo, type, stuff, stuff_type);
-	break;
+        res = put_stuff4(minfo, type, stuff, stuff_type);
+        break;
     default:
-	do_error (&quot;Bad area size in put_stuff()&quot;);
+        do_error(&quot;Bad area size in put_stuff()&quot;);
     }
     return res;
 }
 
-
-int tmax[3][7] =
-{
-  {MAX_FOOD_ON_TRACK, MAX_JOBS_ON_TRACK
-   ,MAX_COAL_ON_TRACK, MAX_GOODS_ON_TRACK, MAX_ORE_ON_TRACK
-   ,MAX_STEEL_ON_TRACK, MAX_WASTE_ON_TRACK},
-  {MAX_FOOD_ON_ROAD, MAX_JOBS_ON_ROAD
-   ,MAX_COAL_ON_ROAD, MAX_GOODS_ON_ROAD, MAX_ORE_ON_ROAD
-   ,MAX_STEEL_ON_ROAD, MAX_WASTE_ON_ROAD},
-  {MAX_FOOD_ON_RAIL, MAX_JOBS_ON_RAIL
-   ,MAX_COAL_ON_RAIL, MAX_GOODS_ON_RAIL, MAX_ORE_ON_RAIL
-   ,MAX_STEEL_ON_RAIL, MAX_WASTE_ON_RAIL}
+int tmax[3][7] = {
+    {MAX_FOOD_ON_TRACK, MAX_JOBS_ON_TRACK, MAX_COAL_ON_TRACK, MAX_GOODS_ON_TRACK, MAX_ORE_ON_TRACK, MAX_STEEL_ON_TRACK,
+     MAX_WASTE_ON_TRACK},
+    {MAX_FOOD_ON_ROAD, MAX_JOBS_ON_ROAD, MAX_COAL_ON_ROAD, MAX_GOODS_ON_ROAD, MAX_ORE_ON_ROAD, MAX_STEEL_ON_ROAD,
+     MAX_WASTE_ON_ROAD},
+    {MAX_FOOD_ON_RAIL, MAX_JOBS_ON_RAIL, MAX_COAL_ON_RAIL, MAX_GOODS_ON_RAIL, MAX_ORE_ON_RAIL, MAX_STEEL_ON_RAIL,
+     MAX_WASTE_ON_RAIL}
 };
 
-struct stack
-  {
+struct stack {
     int *ip, max_val;
-  };
+};
 
 /* worth inlining -- (ThMO) */
-int
-put_stuff2 (Map_Point_Info *minfo, short *type, int stuff, int stuff_type)
+int put_stuff2(Map_Point_Info * minfo, short *type, int stuff, int stuff_type)
 {
-  static int tstart2 = 0;
-  int i, st, tst, *ip, tp = 0;
-  struct stack stack[8], *ssp;	/* stack is really a pipe -- (ThMO) */
+    static int tstart2 = 0;
+    int i, st, tst, *ip, tp = 0;
+    struct stack stack[8], *ssp;        /* stack is really a pipe -- (ThMO) */
 
-  /* we'll stack our found pointers so to avoid re-looping and
-   * testing again (ThMO) */
+    /* we'll stack our found pointers so to avoid re-looping and
+     * testing again (ThMO) */
 
-  tst = tstart2;
+    tst = tstart2;
 
-  /* can we put enough on the transport? */
+    /* can we put enough on the transport? */
 
-  for (ssp = stack, st = 0, i = 0; i &lt; 8; i++) {
-    int map_index = t2[tst];
-    if (minfo[map_index].flags &amp; FLAG_IS_TRANSPORT) {
-      switch (get_group_of_type(type[map_index]))
-	{
-	case GROUP_TRACK:
-	  tp = tmax[0][stuff_type];
-	  break;
-	case GROUP_ROAD:
-	  tp = tmax[1][stuff_type];
-	  break;
-	case GROUP_RAIL:
-	  tp = tmax[2][stuff_type];
-	  break;
-	default:
-	  do_error (&quot;Bad transport type in put_stuff2&quot;);
-	}
-      ip = &amp;minfo[map_index].int_1;
-      ssp-&gt;ip = ip += stuff_type;	/* push it -- (ThMO) */
-      ssp++-&gt;max_val = tp;
-      st += tp - *ip;
-      if (st &gt;= stuff) {
-	ssp = stack;
-	do {
-	  tp = ssp-&gt;max_val - *ssp-&gt;ip;		/* pop it -- (ThMO) */
-	  if ((stuff -= tp) &lt; 0)
-	    *ssp-&gt;ip += tp + stuff;	/* == orig. stuff -- (ThMO) */
-	  else
-	    *ssp-&gt;ip = ssp-&gt;max_val;
-	  ++ssp;
-	} while (stuff &gt; 0);
-	tstart2 = ++tst &amp; 7;
-	return (1);
-      }
+    for (ssp = stack, st = 0, i = 0; i &lt; 8; i++) {
+        int map_index = t2[tst];
+        if (minfo[map_index].flags &amp; FLAG_IS_TRANSPORT) {
+            switch (get_group_of_type(type[map_index])) {
+            case GROUP_TRACK:
+                tp = tmax[0][stuff_type];
+                break;
+            case GROUP_ROAD:
+                tp = tmax[1][stuff_type];
+                break;
+            case GROUP_RAIL:
+                tp = tmax[2][stuff_type];
+                break;
+            default:
+                do_error(&quot;Bad transport type in put_stuff2&quot;);
+            }
+            ip = &amp;minfo[map_index].int_1;
+            ssp-&gt;ip = ip += stuff_type; /* push it -- (ThMO) */
+            ssp++-&gt;max_val = tp;
+            st += tp - *ip;
+            if (st &gt;= stuff) {
+                ssp = stack;
+                do {
+                    tp = ssp-&gt;max_val - *ssp-&gt;ip;       /* pop it -- (ThMO) */
+                    if ((stuff -= tp) &lt; 0)
+                        *ssp-&gt;ip += tp + stuff; /* == orig. stuff -- (ThMO) */
+                    else
+                        *ssp-&gt;ip = ssp-&gt;max_val;
+                    ++ssp;
+                } while (stuff &gt; 0);
+                tstart2 = ++tst &amp; 7;
+                return (1);
+            }
+        }
+        if (++tst &gt;= 8)
+            tst = 0;
     }
-    if (++tst &gt;= 8)
-      tst = 0;
-  }
-  return (0);
+    return (0);
 }
 
 /* worth inlining -- (ThMO) */
-int
-put_stuff3 (Map_Point_Info *minfo, short *type, int stuff, int stuff_type)
+int put_stuff3(Map_Point_Info * minfo, short *type, int stuff, int stuff_type)
 {
-  static int tstart3 = 0;
-  int i, st, tst, *ip, tp = 0;
-  struct stack stack[12], *ssp;	/* stack is really a pipe -- (ThMO)
-				   we'll stack our found pointers so 
-				   to avoid re-looping and
-				   testing again (ThMO) */
+    static int tstart3 = 0;
+    int i, st, tst, *ip, tp = 0;
+    struct stack stack[12], *ssp;       /* stack is really a pipe -- (ThMO)
+                                           we'll stack our found pointers so 
+                                           to avoid re-looping and
+                                           testing again (ThMO) */
 
-  tst = tstart3;
+    tst = tstart3;
 
-  /* can we put enough on the transport? */
+    /* can we put enough on the transport? */
 
-  for (ssp = stack, st = 0, i = 0; i &lt; 12; i++) {
-    int map_index = t3[tst];
-    if (minfo[map_index].flags &amp; FLAG_IS_TRANSPORT) {
-      switch (get_group_of_type(type[map_index]))
-	{
-	case GROUP_TRACK:
-	  tp = tmax[0][stuff_type];
-	  break;
-	case GROUP_ROAD:
-	  tp = tmax[1][stuff_type];
-	  break;
-	case GROUP_RAIL:
-	  tp = tmax[2][stuff_type];
-	  break;
-	default:
-	  do_error (&quot;Bad transport type in put_stuff3&quot;);
-	}
-      ip = &amp;minfo[map_index].int_1;
-      ssp-&gt;ip = ip += stuff_type;	/* push it -- (ThMO) */
-      ssp++-&gt;max_val = tp;
-      st += tp - *ip;
-      if (st &gt;= stuff) {
-	ssp = stack;
-	do {
-	  tp = ssp-&gt;max_val - *ssp-&gt;ip;		/* pop it -- (ThMO) */
-	  if ((stuff -= tp) &lt; 0)
-	    *ssp-&gt;ip += tp + stuff;	/* == orig. stuff -- (ThMO) */
-	  else
-	    *ssp-&gt;ip = ssp-&gt;max_val;
-	  ++ssp;
-	} while (stuff &gt; 0);
-	++tst;
-	tstart3 = tst &gt;= 12 ? 0 : tst;
-	return (1);
-      }
+    for (ssp = stack, st = 0, i = 0; i &lt; 12; i++) {
+        int map_index = t3[tst];
+        if (minfo[map_index].flags &amp; FLAG_IS_TRANSPORT) {
+            switch (get_group_of_type(type[map_index])) {
+            case GROUP_TRACK:
+                tp = tmax[0][stuff_type];
+                break;
+            case GROUP_ROAD:
+                tp = tmax[1][stuff_type];
+                break;
+            case GROUP_RAIL:
+                tp = tmax[2][stuff_type];
+                break;
+            default:
+                do_error(&quot;Bad transport type in put_stuff3&quot;);
+            }
+            ip = &amp;minfo[map_index].int_1;
+            ssp-&gt;ip = ip += stuff_type; /* push it -- (ThMO) */
+            ssp++-&gt;max_val = tp;
+            st += tp - *ip;
+            if (st &gt;= stuff) {
+                ssp = stack;
+                do {
+                    tp = ssp-&gt;max_val - *ssp-&gt;ip;       /* pop it -- (ThMO) */
+                    if ((stuff -= tp) &lt; 0)
+                        *ssp-&gt;ip += tp + stuff; /* == orig. stuff -- (ThMO) */
+                    else
+                        *ssp-&gt;ip = ssp-&gt;max_val;
+                    ++ssp;
+                } while (stuff &gt; 0);
+                ++tst;
+                tstart3 = tst &gt;= 12 ? 0 : tst;
+                return (1);
+            }
+        }
+        if (++tst &gt;= 12)
+            tst = 0;
     }
-    if (++tst &gt;= 12)
-      tst = 0;
-  }
-  return (0);
+    return (0);
 }
 
 /* worth inlining -- (ThMO) */
-int
-put_stuff4 (Map_Point_Info *minfo, short *type, int stuff, int stuff_type)
+int put_stuff4(Map_Point_Info * minfo, short *type, int stuff, int stuff_type)
 {
-  static int tstart4 = 0;
-  int i, st, tst, *ip, tp = 0;
-  struct stack stack[16], *ssp;	/* stack is really a pipe -- (ThMO)
-				 */
-  /* we'll stack our found pointers so to avoid re-looping and
-   * testing again (ThMO) */
+    static int tstart4 = 0;
+    int i, st, tst, *ip, tp = 0;
+    struct stack stack[16], *ssp;       /* stack is really a pipe -- (ThMO)
+                                         */
+    /* we'll stack our found pointers so to avoid re-looping and
+     * testing again (ThMO) */
 
-  tst = tstart4;
+    tst = tstart4;
 
-  /* can we put enough on the transport? */
+    /* can we put enough on the transport? */
 
-  for (ssp = stack, st = 0, i = 0; i &lt; 16; i++) {
-    int map_index = t4[tst];
-    if (minfo[map_index].flags &amp; FLAG_IS_TRANSPORT) {
-      switch (get_group_of_type(type[map_index]))
-	{
-	case GROUP_TRACK:
-	  tp = tmax[0][stuff_type];
-	  break;
-	case GROUP_ROAD:
-	  tp = tmax[1][stuff_type];
-	  break;
-	case GROUP_RAIL:
-	  tp = tmax[2][stuff_type];
-	  break;
-	default:
-	  do_error (&quot;Bad transport type in put_stuff4&quot;);
-	}
-      ip = &amp;minfo[map_index].int_1;
-      ssp-&gt;ip = ip += stuff_type;	/* push it -- (ThMO) */
-      ssp++-&gt;max_val = tp;
-      st += tp - *ip;
-      if (st &gt;= stuff) {
-	ssp = stack;
-	do {
-	  tp = ssp-&gt;max_val - *ssp-&gt;ip;		/* pop it -- (ThMO) */
-	  if ((stuff -= tp) &lt; 0)
-	    *ssp-&gt;ip += tp + stuff;	/* == orig. stuff -- (ThMO) */
-	  else
-	    *ssp-&gt;ip = ssp-&gt;max_val;
-	  ++ssp;
-	} while (stuff &gt; 0);
-	tstart4 = ++tst &amp; 15;
-	return (1);
-      }
+    for (ssp = stack, st = 0, i = 0; i &lt; 16; i++) {
+        int map_index = t4[tst];
+        if (minfo[map_index].flags &amp; FLAG_IS_TRANSPORT) {
+            switch (get_group_of_type(type[map_index])) {
+            case GROUP_TRACK:
+                tp = tmax[0][stuff_type];
+                break;
+            case GROUP_ROAD:
+                tp = tmax[1][stuff_type];
+                break;
+            case GROUP_RAIL:
+                tp = tmax[2][stuff_type];
+                break;
+            default:
+                do_error(&quot;Bad transport type in put_stuff4&quot;);
+            }
+            ip = &amp;minfo[map_index].int_1;
+            ssp-&gt;ip = ip += stuff_type; /* push it -- (ThMO) */
+            ssp++-&gt;max_val = tp;
+            st += tp - *ip;
+            if (st &gt;= stuff) {
+                ssp = stack;
+                do {
+                    tp = ssp-&gt;max_val - *ssp-&gt;ip;       /* pop it -- (ThMO) */
+                    if ((stuff -= tp) &lt; 0)
+                        *ssp-&gt;ip += tp + stuff; /* == orig. stuff -- (ThMO) */
+                    else
+                        *ssp-&gt;ip = ssp-&gt;max_val;
+                    ++ssp;
+                } while (stuff &gt; 0);
+                tstart4 = ++tst &amp; 15;
+                return (1);
+            }
+        }
+        if (++tst &gt;= 16)
+            tst = 0;
     }
-    if (++tst &gt;= 16)
-      tst = 0;
-  }
-  return (0);
+    return (0);
 }
 
-void
-mps_market (int x, int y)
+void mps_market(int x, int y)
 {
-  int i = 0;
+    int i = 0;
 
-  mps_store_title(i++,_(&quot;Market&quot;));
+    mps_store_title(i++, _(&quot;Market&quot;));
 
-  i++;
+    i++;
 
-  mps_store_sfp(i++,_(&quot;Food&quot;), 
-		MP_INFO(x,y).int_1 * 100.0 / MAX_FOOD_IN_MARKET);
-  mps_store_sfp(i++,_(&quot;Jobs&quot;), 
-		MP_INFO(x,y).int_2 * 100.0 / MAX_JOBS_IN_MARKET);
-  mps_store_sfp(i++,_(&quot;Coal&quot;), 
-		MP_INFO(x,y).int_3 * 100.0 / MAX_COAL_IN_MARKET);
-  mps_store_sfp(i++,_(&quot;Goods&quot;), 
-		MP_INFO(x,y).int_4 * 100.0 / MAX_GOODS_IN_MARKET);
-  mps_store_sfp(i++,_(&quot;Ore&quot;), 
-		MP_INFO(x,y).int_5 * 100.0 / MAX_ORE_IN_MARKET);
-  mps_store_sfp(i++,_(&quot;Steel&quot;), 
-		MP_INFO(x,y).int_6 * 100.0 / MAX_STEEL_IN_MARKET);
-  mps_store_sfp(i++,_(&quot;Waste&quot;), 
-		MP_INFO(x,y).int_7 * 100.0 / MAX_WASTE_IN_MARKET);
+    mps_store_sfp(i++, _(&quot;Food&quot;), MP_INFO(x, y).int_1 * 100.0 / MAX_FOOD_IN_MARKET);
+    mps_store_sfp(i++, _(&quot;Jobs&quot;), MP_INFO(x, y).int_2 * 100.0 / MAX_JOBS_IN_MARKET);
+    mps_store_sfp(i++, _(&quot;Coal&quot;), MP_INFO(x, y).int_3 * 100.0 / MAX_COAL_IN_MARKET);
+    mps_store_sfp(i++, _(&quot;Goods&quot;), MP_INFO(x, y).int_4 * 100.0 / MAX_GOODS_IN_MARKET);
+    mps_store_sfp(i++, _(&quot;Ore&quot;), MP_INFO(x, y).int_5 * 100.0 / MAX_ORE_IN_MARKET);
+    mps_store_sfp(i++, _(&quot;Steel&quot;), MP_INFO(x, y).int_6 * 100.0 / MAX_STEEL_IN_MARKET);
+    mps_store_sfp(i++, _(&quot;Waste&quot;), MP_INFO(x, y).int_7 * 100.0 / MAX_WASTE_IN_MARKET);
 
 }
-
-

Modified: trunk/src/lincity/modules/mill.cpp
===================================================================
--- trunk/src/lincity/modules/mill.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/mill.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -8,108 +8,90 @@
 #include &quot;modules.h&quot;
 #include &quot;mill.h&quot;
 
-
-void
-do_mill (int x, int y)
+void do_mill(int x, int y)
 {
-  /*
-     // int_1 contains the goods at the mill
-     // int_2 contains the food store
-     // int_3 contains the coal store
-     // int_4 contains the animation trigger time
-     // int_5 is the % count so far this month
-     // int_6 is the % capacity last month
-   */
-  /* get food */
-  int block_anim = 0;
-  if (MP_INFO(x,y).int_2 &lt; MAX_FOOD_AT_MILL)
-    if (get_food (x, y, MILL_GET_FOOD) != 0)
-      MP_INFO(x,y).int_2 += MILL_GET_FOOD;
-  /* get coal */
-  if (MP_INFO(x,y).int_3 &lt; MAX_COAL_AT_MILL)
-    {
-      if (get_coal (x, y, MILL_GET_COAL) != 0)
-	MP_INFO(x,y).int_3 += MILL_GET_COAL;
-      else if (get_power (x, y, MILL_GET_COAL
-			  * MILL_POWER_PER_COAL, 0) != 0)
-	MP_INFO(x,y).int_3 += MILL_GET_COAL;
+    /*
+       // int_1 contains the goods at the mill
+       // int_2 contains the food store
+       // int_3 contains the coal store
+       // int_4 contains the animation trigger time
+       // int_5 is the % count so far this month
+       // int_6 is the % capacity last month
+     */
+    /* get food */
+    int block_anim = 0;
+    if (MP_INFO(x, y).int_2 &lt; MAX_FOOD_AT_MILL)
+        if (get_food(x, y, MILL_GET_FOOD) != 0)
+            MP_INFO(x, y).int_2 += MILL_GET_FOOD;
+    /* get coal */
+    if (MP_INFO(x, y).int_3 &lt; MAX_COAL_AT_MILL) {
+        if (get_coal(x, y, MILL_GET_COAL) != 0)
+            MP_INFO(x, y).int_3 += MILL_GET_COAL;
+        else if (get_power(x, y, MILL_GET_COAL * MILL_POWER_PER_COAL, 0) != 0)
+            MP_INFO(x, y).int_3 += MILL_GET_COAL;
     }
-  if (MP_INFO(x,y).int_1 &lt; MAX_GOODS_AT_MILL)
-    {
-      if (MP_INFO(x,y).int_2 &gt; FOOD_USED_BY_MILL
-	  &amp;&amp; MP_INFO(x,y).int_3 &gt; COAL_USED_BY_MILL)
-	{
-	  if (get_jobs (x, y, MILL_JOBS) != 0)
-	    {
-	      MP_INFO(x,y).int_2 -= FOOD_USED_BY_MILL;
-	      MP_INFO(x,y).int_3 -= COAL_USED_BY_MILL;
-	      MP_INFO(x,y).int_1 += GOODS_MADE_BY_MILL;
-	      MP_INFO(x,y).int_5++;
-	    }
-	  else
-	    {
-	      MP_TYPE(x,y) = CST_MILL_0;
-	      block_anim = 1;
-	    }
-	}
-      else
-	block_anim = 1;
+    if (MP_INFO(x, y).int_1 &lt; MAX_GOODS_AT_MILL) {
+        if (MP_INFO(x, y).int_2 &gt; FOOD_USED_BY_MILL &amp;&amp; MP_INFO(x, y).int_3 &gt; COAL_USED_BY_MILL) {
+            if (get_jobs(x, y, MILL_JOBS) != 0) {
+                MP_INFO(x, y).int_2 -= FOOD_USED_BY_MILL;
+                MP_INFO(x, y).int_3 -= COAL_USED_BY_MILL;
+                MP_INFO(x, y).int_1 += GOODS_MADE_BY_MILL;
+                MP_INFO(x, y).int_5++;
+            } else {
+                MP_TYPE(x, y) = CST_MILL_0;
+                block_anim = 1;
+            }
+        } else
+            block_anim = 1;
     }
 
-  if (MP_INFO(x,y).int_1 &gt; GOODS_MADE_BY_MILL)
-    if (put_goods (x, y, GOODS_MADE_BY_MILL - 1) !=0)
-      MP_INFO(x,y).int_1 -= (GOODS_MADE_BY_MILL - 1); 
+    if (MP_INFO(x, y).int_1 &gt; GOODS_MADE_BY_MILL)
+        if (put_goods(x, y, GOODS_MADE_BY_MILL - 1) != 0)
+            MP_INFO(x, y).int_1 -= (GOODS_MADE_BY_MILL - 1);
 
-  if (total_time % 100 == 0)
-    {
-      MP_INFO(x,y).int_6 = MP_INFO(x,y).int_5;
-      MP_INFO(x,y).int_5 = 0;
+    if (total_time % 100 == 0) {
+        MP_INFO(x, y).int_6 = MP_INFO(x, y).int_5;
+        MP_INFO(x, y).int_5 = 0;
     }
-  if (real_time &gt;= MP_INFO(x,y).int_4 &amp;&amp; block_anim == 0)
-    {
-      MP_INFO(x,y).int_4 = real_time + MILL_ANIM_SPEED;
-      switch (MP_TYPE(x,y))
-	{
-	case (CST_MILL_0):
-	  MP_TYPE(x,y) = CST_MILL_1;
-	  break;
-	case (CST_MILL_1):
-	  MP_TYPE(x,y) = CST_MILL_2;
-	  break;
-	case (CST_MILL_2):
-	  MP_TYPE(x,y) = CST_MILL_3;
-	  break;
-	case (CST_MILL_3):
-	  MP_TYPE(x,y) = CST_MILL_4;
-	  break;
-	case (CST_MILL_4):
-	  MP_TYPE(x,y) = CST_MILL_5;
-	  break;
-	case (CST_MILL_5):
-	  MP_TYPE(x,y) = CST_MILL_6;
-	  break;
-	case (CST_MILL_6):
-	  MP_TYPE(x,y) = CST_MILL_1;
-	  MP_POL(x,y)++;
-	  break;
-	}
+    if (real_time &gt;= MP_INFO(x, y).int_4 &amp;&amp; block_anim == 0) {
+        MP_INFO(x, y).int_4 = real_time + MILL_ANIM_SPEED;
+        switch (MP_TYPE(x, y)) {
+        case (CST_MILL_0):
+            MP_TYPE(x, y) = CST_MILL_1;
+            break;
+        case (CST_MILL_1):
+            MP_TYPE(x, y) = CST_MILL_2;
+            break;
+        case (CST_MILL_2):
+            MP_TYPE(x, y) = CST_MILL_3;
+            break;
+        case (CST_MILL_3):
+            MP_TYPE(x, y) = CST_MILL_4;
+            break;
+        case (CST_MILL_4):
+            MP_TYPE(x, y) = CST_MILL_5;
+            break;
+        case (CST_MILL_5):
+            MP_TYPE(x, y) = CST_MILL_6;
+            break;
+        case (CST_MILL_6):
+            MP_TYPE(x, y) = CST_MILL_1;
+            MP_POL(x, y)++;
+            break;
+        }
     }
 }
 
-void
-mps_mill (int x, int y)
+void mps_mill(int x, int y)
 {
-  int i = 0;
-  mps_store_title(i++,_(&quot;Textile Mill&quot;));
-  i++;
-  mps_store_sfp(i++,_(&quot;Capacity&quot;), MP_INFO(x,y).int_6);
-  i++;
-  mps_store_title(i++,_(&quot;Inventory&quot;));
-  mps_store_sfp(i++,_(&quot;Goods&quot;),
-		MP_INFO(x,y).int_1 * 100.0 / MAX_GOODS_AT_MILL);
-  mps_store_sfp(i++,_(&quot;Food&quot;),
-		MP_INFO(x,y).int_2 * 100.0 / MAX_FOOD_AT_MILL);
-  mps_store_sfp(i++,_(&quot;Coal&quot;),
-		MP_INFO(x,y).int_3 * 100.0 / MAX_COAL_AT_MILL);
+    int i = 0;
+    mps_store_title(i++, _(&quot;Textile Mill&quot;));
+    i++;
+    mps_store_sfp(i++, _(&quot;Capacity&quot;), MP_INFO(x, y).int_6);
+    i++;
+    mps_store_title(i++, _(&quot;Inventory&quot;));
+    mps_store_sfp(i++, _(&quot;Goods&quot;), MP_INFO(x, y).int_1 * 100.0 / MAX_GOODS_AT_MILL);
+    mps_store_sfp(i++, _(&quot;Food&quot;), MP_INFO(x, y).int_2 * 100.0 / MAX_FOOD_AT_MILL);
+    mps_store_sfp(i++, _(&quot;Coal&quot;), MP_INFO(x, y).int_3 * 100.0 / MAX_COAL_AT_MILL);
 
 }

Modified: trunk/src/lincity/modules/mill.h
===================================================================
--- trunk/src/lincity/modules/mill.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/mill.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -9,6 +9,6 @@
 #define __mill_h__
 
 void do_mill(int x, int y);
-void mps_mill (int x, int y);
+void mps_mill(int x, int y);
 
 #endif /* __mill_h__ */

Modified: trunk/src/lincity/modules/monument.cpp
===================================================================
--- trunk/src/lincity/modules/monument.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/monument.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -8,65 +8,58 @@
 #include &quot;modules.h&quot;
 #include &quot;monument.h&quot;
 
-void
-do_monument (int x, int y)
+void do_monument(int x, int y)
 {
-  /*
-     // int_1 holds the jobs used
-     // int_2 holds the tech points made
-     // int_3 holds the tail off count
-   */
-  if (MP_INFO(x,y).int_1 &lt; BUILD_MONUMENT_JOBS)
-    if (get_jobs (x, y, MONUMENT_GET_JOBS) != 0)
-      MP_INFO(x,y).int_1 += MONUMENT_GET_JOBS;
+    /*
+       // int_1 holds the jobs used
+       // int_2 holds the tech points made
+       // int_3 holds the tail off count
+     */
+    if (MP_INFO(x, y).int_1 &lt; BUILD_MONUMENT_JOBS)
+        if (get_jobs(x, y, MONUMENT_GET_JOBS) != 0)
+            MP_INFO(x, y).int_1 += MONUMENT_GET_JOBS;
 
-  /* now choose a graphic */
-  if (MP_INFO(x,y).int_1 &gt;= BUILD_MONUMENT_JOBS)
-    {
-      MP_TYPE(x,y) = CST_MONUMENT_5;
-      /* inc tech level only if fully built and tech less 
-         than MONUMENT_TECH_EXPIRE */
-      if (tech_level &lt; (MONUMENT_TECH_EXPIRE * 1000)
-	  &amp;&amp; (total_time % MONUMENT_DAYS_PER_TECH) == 1)
-	{
-	  if (MP_INFO(x,y).int_3++ &gt; (tech_level / 10000) - 2)
-	    {
-	      tech_level++;
-	      MP_INFO(x,y).int_2++;
-	      MP_INFO(x,y).int_3 = 0;
-	    }
-	}
-    }
-  else if (MP_INFO(x,y).int_1 &gt;= ((BUILD_MONUMENT_JOBS * 4) / 5))
-    MP_TYPE(x,y) = CST_MONUMENT_4;
-  else if (MP_INFO(x,y).int_1 &gt;= ((BUILD_MONUMENT_JOBS * 3) / 5))
-    MP_TYPE(x,y) = CST_MONUMENT_3;
-  else if (MP_INFO(x,y).int_1 &gt;= ((BUILD_MONUMENT_JOBS * 2) / 5))
-    MP_TYPE(x,y) = CST_MONUMENT_2;
-  else if (MP_INFO(x,y).int_1 &gt;= (BUILD_MONUMENT_JOBS / 20))
-    MP_TYPE(x,y) = CST_MONUMENT_1;
-  else
-    MP_TYPE(x,y) = CST_MONUMENT_0;
+    /* now choose a graphic */
+    if (MP_INFO(x, y).int_1 &gt;= BUILD_MONUMENT_JOBS) {
+        MP_TYPE(x, y) = CST_MONUMENT_5;
+        /* inc tech level only if fully built and tech less 
+           than MONUMENT_TECH_EXPIRE */
+        if (tech_level &lt; (MONUMENT_TECH_EXPIRE * 1000)
+            &amp;&amp; (total_time % MONUMENT_DAYS_PER_TECH) == 1) {
+            if (MP_INFO(x, y).int_3++ &gt; (tech_level / 10000) - 2) {
+                tech_level++;
+                MP_INFO(x, y).int_2++;
+                MP_INFO(x, y).int_3 = 0;
+            }
+        }
+    } else if (MP_INFO(x, y).int_1 &gt;= ((BUILD_MONUMENT_JOBS * 4) / 5))
+        MP_TYPE(x, y) = CST_MONUMENT_4;
+    else if (MP_INFO(x, y).int_1 &gt;= ((BUILD_MONUMENT_JOBS * 3) / 5))
+        MP_TYPE(x, y) = CST_MONUMENT_3;
+    else if (MP_INFO(x, y).int_1 &gt;= ((BUILD_MONUMENT_JOBS * 2) / 5))
+        MP_TYPE(x, y) = CST_MONUMENT_2;
+    else if (MP_INFO(x, y).int_1 &gt;= (BUILD_MONUMENT_JOBS / 20))
+        MP_TYPE(x, y) = CST_MONUMENT_1;
+    else
+        MP_TYPE(x, y) = CST_MONUMENT_0;
 }
 
-void
-mps_monument (int x, int y)
+void mps_monument(int x, int y)
 {
-  int i = 0;
+    int i = 0;
 
-  mps_store_title(i++,_(&quot;Monument&quot;));
-  i++;
-  i++;
+    mps_store_title(i++, _(&quot;Monument&quot;));
+    i++;
+    i++;
 
-  /* Display tech contribution only after monument is complete */
-  if ((MP_INFO(x,y).int_1 * 100 / BUILD_MONUMENT_JOBS) &gt;= 100) {
-      mps_store_title(i++,_(&quot;Wisdom Bestowed&quot;));
-      i++;
-      mps_store_f(i++, MP_INFO(x,y).int_2 * 100.0 / MAX_TECH_LEVEL);
-  } else {
-      mps_store_title(i++,_(&quot;% Complete&quot;));
-      i++;
-      mps_store_fp(i++, MP_INFO(x,y).int_1 * 100.0 /
-		   BUILD_MONUMENT_JOBS);
-  }
+    /* Display tech contribution only after monument is complete */
+    if ((MP_INFO(x, y).int_1 * 100 / BUILD_MONUMENT_JOBS) &gt;= 100) {
+        mps_store_title(i++, _(&quot;Wisdom Bestowed&quot;));
+        i++;
+        mps_store_f(i++, MP_INFO(x, y).int_2 * 100.0 / MAX_TECH_LEVEL);
+    } else {
+        mps_store_title(i++, _(&quot;% Complete&quot;));
+        i++;
+        mps_store_fp(i++, MP_INFO(x, y).int_1 * 100.0 / BUILD_MONUMENT_JOBS);
+    }
 }

Modified: trunk/src/lincity/modules/monument.h
===================================================================
--- trunk/src/lincity/modules/monument.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/monument.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -9,6 +9,6 @@
 #define __monument_h__
 
 void do_monument(int x, int y);
-void mps_monument (int x, int y);
+void mps_monument(int x, int y);
 
 #endif /* __monument_h__ */

Modified: trunk/src/lincity/modules/oremine.cpp
===================================================================
--- trunk/src/lincity/modules/oremine.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/oremine.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -9,185 +9,145 @@
 #include &quot;gui_interface/screen_interface.h&quot;
 #include &quot;oremine.h&quot;
 
-
-
-void
-do_oremine (int x, int y)
+void do_oremine(int x, int y)
 {
-  /*
-     // int_1 is the ore at in stock
-     // int_2 is the ore reserve under the ground or at the surface really.
-   */
-  int xx, yy, xs, ys, xe, ye, cr;
-  if (MP_INFO(x,y).int_1 &lt; DIG_MORE_ORE_TRIGGER - 5000)
-    {
-      xs = x;
-      ys = y;
-      xe = x + 4;
-      ye = y + 4;
-      cr = 0;
-      for (yy = ys; yy &lt; ye; yy++)
-	for (xx = xs; xx &lt; xe; xx++)
-	  cr += MP_INFO(xx,yy).ore_reserve;
-      MP_INFO(x,y).int_2 = cr;
-      if (cr &gt; 0)
-	if (get_jobs (x, y, JOBS_DIG_ORE) != 0)
-	  for (yy = ys; yy &lt; ye; yy++)
-	    for (xx = xs; xx &lt; xe; xx++)
-	      if (MP_INFO(xx,yy).ore_reserve &gt; 0)
-		{
-		  MP_INFO(xx,yy).ore_reserve--;
-		  MP_INFO(x,y).int_1 += 5000;
-		  ore_made += 5000;
-		  sust_dig_ore_coal_tip_flag = 0;
-		  /* maybe want an ore tax? */
-		  yy = ye;
-		  xx = xe;	/* break out */
-		}
+    /*
+       // int_1 is the ore at in stock
+       // int_2 is the ore reserve under the ground or at the surface really.
+     */
+    int xx, yy, xs, ys, xe, ye, cr;
+    if (MP_INFO(x, y).int_1 &lt; DIG_MORE_ORE_TRIGGER - 5000) {
+        xs = x;
+        ys = y;
+        xe = x + 4;
+        ye = y + 4;
+        cr = 0;
+        for (yy = ys; yy &lt; ye; yy++)
+            for (xx = xs; xx &lt; xe; xx++)
+                cr += MP_INFO(xx, yy).ore_reserve;
+        MP_INFO(x, y).int_2 = cr;
+        if (cr &gt; 0)
+            if (get_jobs(x, y, JOBS_DIG_ORE) != 0)
+                for (yy = ys; yy &lt; ye; yy++)
+                    for (xx = xs; xx &lt; xe; xx++)
+                        if (MP_INFO(xx, yy).ore_reserve &gt; 0) {
+                            MP_INFO(xx, yy).ore_reserve--;
+                            MP_INFO(x, y).int_1 += 5000;
+                            ore_made += 5000;
+                            sust_dig_ore_coal_tip_flag = 0;
+                            /* maybe want an ore tax? */
+                            yy = ye;
+                            xx = xe;    /* break out */
+                        }
     }
 
-  if ((MP_INFO(x - 1,y).flags &amp; FLAG_IS_TRANSPORT) != 0)
-    {
-      if (MP_GROUP(x-1,y) == GROUP_RAIL
-	  &amp;&amp; MP_INFO(x - 1,y).int_5 &lt; MAX_ORE_ON_RAIL
-	  &amp;&amp; MP_INFO(x,y).int_1 &gt;= (MAX_ORE_ON_RAIL
-				      - MP_INFO(x - 1,y).int_5))
-	{
-	  if (get_jobs (x, y, JOBS_LOAD_ORE) != 0)
-	    {
-	      MP_INFO(x,y).int_1
-		-= (MAX_ORE_ON_RAIL - MP_INFO(x - 1,y).int_5);
-	      MP_INFO(x - 1,y).int_5 = MAX_ORE_ON_RAIL;
-	    }
-	}
-      else if (MP_GROUP(x-1,y) == GROUP_ROAD
-	       &amp;&amp; MP_INFO(x - 1,y).int_5 &lt; MAX_ORE_ON_ROAD
-	       &amp;&amp; MP_INFO(x,y).int_1 &gt;= (MAX_ORE_ON_ROAD
-					   - MP_INFO(x - 1,y).int_5))
-	{
-	  if (get_jobs (x, y, JOBS_LOAD_ORE) != 0)
-	    {
-	      MP_INFO(x,y).int_1
-		-= (MAX_ORE_ON_ROAD - MP_INFO(x - 1,y).int_5);
-	      MP_INFO(x - 1,y).int_5 = MAX_ORE_ON_ROAD;
-	    }
-	}
-      else if (MP_GROUP(x - 1,y) == GROUP_TRACK
-	       &amp;&amp; MP_INFO(x - 1,y).int_5 &lt; MAX_ORE_ON_TRACK
-	       &amp;&amp; MP_INFO(x,y).int_1 &gt;= (MAX_ORE_ON_TRACK
-					   - MP_INFO(x - 1,y).int_5))
-	{
-	  if (get_jobs (x, y, JOBS_LOAD_ORE) != 0)
-	    {
-	      MP_INFO(x,y).int_1
-		-= (MAX_ORE_ON_TRACK - MP_INFO(x - 1,y).int_5);
-	      MP_INFO(x - 1,y).int_5 = MAX_ORE_ON_TRACK;
-	    }
-	}
+    if ((MP_INFO(x - 1, y).flags &amp; FLAG_IS_TRANSPORT) != 0) {
+        if (MP_GROUP(x - 1, y) == GROUP_RAIL
+            &amp;&amp; MP_INFO(x - 1, y).int_5 &lt; MAX_ORE_ON_RAIL
+            &amp;&amp; MP_INFO(x, y).int_1 &gt;= (MAX_ORE_ON_RAIL - MP_INFO(x - 1, y).int_5)) {
+            if (get_jobs(x, y, JOBS_LOAD_ORE) != 0) {
+                MP_INFO(x, y).int_1 -= (MAX_ORE_ON_RAIL - MP_INFO(x - 1, y).int_5);
+                MP_INFO(x - 1, y).int_5 = MAX_ORE_ON_RAIL;
+            }
+        } else if (MP_GROUP(x - 1, y) == GROUP_ROAD
+                   &amp;&amp; MP_INFO(x - 1, y).int_5 &lt; MAX_ORE_ON_ROAD
+                   &amp;&amp; MP_INFO(x, y).int_1 &gt;= (MAX_ORE_ON_ROAD - MP_INFO(x - 1, y).int_5)) {
+            if (get_jobs(x, y, JOBS_LOAD_ORE) != 0) {
+                MP_INFO(x, y).int_1 -= (MAX_ORE_ON_ROAD - MP_INFO(x - 1, y).int_5);
+                MP_INFO(x - 1, y).int_5 = MAX_ORE_ON_ROAD;
+            }
+        } else if (MP_GROUP(x - 1, y) == GROUP_TRACK
+                   &amp;&amp; MP_INFO(x - 1, y).int_5 &lt; MAX_ORE_ON_TRACK
+                   &amp;&amp; MP_INFO(x, y).int_1 &gt;= (MAX_ORE_ON_TRACK - MP_INFO(x - 1, y).int_5)) {
+            if (get_jobs(x, y, JOBS_LOAD_ORE) != 0) {
+                MP_INFO(x, y).int_1 -= (MAX_ORE_ON_TRACK - MP_INFO(x - 1, y).int_5);
+                MP_INFO(x - 1, y).int_5 = MAX_ORE_ON_TRACK;
+            }
+        }
     }
 
-  if ((MP_INFO(x,y - 1).flags &amp; FLAG_IS_TRANSPORT) != 0)
-    {
-      if (MP_GROUP(x,y-1) == GROUP_RAIL
-	  &amp;&amp; MP_INFO(x,y - 1).int_5 &lt; MAX_ORE_ON_RAIL
-	  &amp;&amp; MP_INFO(x,y).int_1 &gt;= (MAX_ORE_ON_RAIL
-				      - MP_INFO(x,y - 1).int_5))
-	{
-	  if (get_jobs (x, y, JOBS_LOAD_ORE) != 0)
-	    {
-	      MP_INFO(x,y).int_1
-		-= (MAX_ORE_ON_RAIL - MP_INFO(x,y - 1).int_5);
-	      MP_INFO(x,y - 1).int_5 = MAX_ORE_ON_RAIL;
-	    }
-	}
-      else if (MP_GROUP(x,y-1) == GROUP_ROAD
-	       &amp;&amp; MP_INFO(x,y - 1).int_5 &lt; MAX_ORE_ON_ROAD
-	       &amp;&amp; MP_INFO(x,y).int_1 &gt;= (MAX_ORE_ON_ROAD
-					   - MP_INFO(x,y - 1).int_5))
-	{
-	  if (get_jobs (x, y, JOBS_LOAD_ORE) != 0)
-	    {
-	      MP_INFO(x,y).int_1
-		-= (MAX_ORE_ON_ROAD - MP_INFO(x,y - 1).int_5);
-	      MP_INFO(x,y - 1).int_5 = MAX_ORE_ON_ROAD;
-	    }
-	}
-      else if (MP_GROUP(x,y-1) == GROUP_TRACK
-	       &amp;&amp; MP_INFO(x,y - 1).int_5 &lt; MAX_ORE_ON_TRACK
-	       &amp;&amp; MP_INFO(x,y).int_1 &gt;= (MAX_ORE_ON_TRACK
-					   - MP_INFO(x,y - 1).int_5))
-	{
-	  if (get_jobs (x, y, JOBS_LOAD_ORE) != 0)
-	    {
-	      MP_INFO(x,y).int_1
-		-= (MAX_ORE_ON_TRACK - MP_INFO(x,y - 1).int_5);
-	      MP_INFO(x,y - 1).int_5 = MAX_ORE_ON_TRACK;
-	    }
-	}
+    if ((MP_INFO(x, y - 1).flags &amp; FLAG_IS_TRANSPORT) != 0) {
+        if (MP_GROUP(x, y - 1) == GROUP_RAIL
+            &amp;&amp; MP_INFO(x, y - 1).int_5 &lt; MAX_ORE_ON_RAIL
+            &amp;&amp; MP_INFO(x, y).int_1 &gt;= (MAX_ORE_ON_RAIL - MP_INFO(x, y - 1).int_5)) {
+            if (get_jobs(x, y, JOBS_LOAD_ORE) != 0) {
+                MP_INFO(x, y).int_1 -= (MAX_ORE_ON_RAIL - MP_INFO(x, y - 1).int_5);
+                MP_INFO(x, y - 1).int_5 = MAX_ORE_ON_RAIL;
+            }
+        } else if (MP_GROUP(x, y - 1) == GROUP_ROAD
+                   &amp;&amp; MP_INFO(x, y - 1).int_5 &lt; MAX_ORE_ON_ROAD
+                   &amp;&amp; MP_INFO(x, y).int_1 &gt;= (MAX_ORE_ON_ROAD - MP_INFO(x, y - 1).int_5)) {
+            if (get_jobs(x, y, JOBS_LOAD_ORE) != 0) {
+                MP_INFO(x, y).int_1 -= (MAX_ORE_ON_ROAD - MP_INFO(x, y - 1).int_5);
+                MP_INFO(x, y - 1).int_5 = MAX_ORE_ON_ROAD;
+            }
+        } else if (MP_GROUP(x, y - 1) == GROUP_TRACK
+                   &amp;&amp; MP_INFO(x, y - 1).int_5 &lt; MAX_ORE_ON_TRACK
+                   &amp;&amp; MP_INFO(x, y).int_1 &gt;= (MAX_ORE_ON_TRACK - MP_INFO(x, y - 1).int_5)) {
+            if (get_jobs(x, y, JOBS_LOAD_ORE) != 0) {
+                MP_INFO(x, y).int_1 -= (MAX_ORE_ON_TRACK - MP_INFO(x, y - 1).int_5);
+                MP_INFO(x, y - 1).int_5 = MAX_ORE_ON_TRACK;
+            }
+        }
     }
 
-
-  /* choose a graphic */
-  if ((total_time &amp; 0x7f) == 0) {
-      xx = 7 * (MP_INFO(x,y).int_2 + (3 * ORE_RESERVE / 2))
-	/ (16 * ORE_RESERVE);
-      switch (xx) {
+    /* choose a graphic */
+    if ((total_time &amp; 0x7f) == 0) {
+        xx = 7 * (MP_INFO(x, y).int_2 + (3 * ORE_RESERVE / 2))
+            / (16 * ORE_RESERVE);
+        switch (xx) {
         case (0):
-	  MP_TYPE(x,y) = CST_OREMINE_8;
-	  break;
-	case (1):
-	  MP_TYPE(x,y) = CST_OREMINE_7;
-	  break;
-	case (2):
-	  MP_TYPE(x,y) = CST_OREMINE_6;
-	  break;
-	case (3):
-	  MP_TYPE(x,y) = CST_OREMINE_5;
-	  break;
-	case (4):
-	  MP_TYPE(x,y) = CST_OREMINE_4;
-	  break;
-	case (5):
-	  MP_TYPE(x,y) = CST_OREMINE_3;
-	  break;
-	case (6):
-	  MP_TYPE(x,y) = CST_OREMINE_2;
-	  break;
-	case (7):
-	  MP_TYPE(x,y) = CST_OREMINE_1;
-	  break;
-	}
-	if (MP_INFO(x,y).int_2 &lt;= 0) {
+            MP_TYPE(x, y) = CST_OREMINE_8;
+            break;
+        case (1):
+            MP_TYPE(x, y) = CST_OREMINE_7;
+            break;
+        case (2):
+            MP_TYPE(x, y) = CST_OREMINE_6;
+            break;
+        case (3):
+            MP_TYPE(x, y) = CST_OREMINE_5;
+            break;
+        case (4):
+            MP_TYPE(x, y) = CST_OREMINE_4;
+            break;
+        case (5):
+            MP_TYPE(x, y) = CST_OREMINE_3;
+            break;
+        case (6):
+            MP_TYPE(x, y) = CST_OREMINE_2;
+            break;
+        case (7):
+            MP_TYPE(x, y) = CST_OREMINE_1;
+            break;
+        }
+        if (MP_INFO(x, y).int_2 &lt;= 0) {
 #if defined (commentout)
             /* AL1. It seems to be overwritten just below! */
-	    do_bulldoze_area (CST_GREEN, x, y);
-	    place_item(x,y,CST_TIP_0);
+            do_bulldoze_area(CST_GREEN, x, y);
+            place_item(x, y, CST_TIP_0);
 #endif
-	    int i,j;
-	    for (j = 0; j &lt; 4; j++) {
-		for (i = 0; i &lt; 4; i++) {
-		    do_bulldoze_area (CST_WATER, x+i, y+j);
-		}
-	    }
-	    connect_rivers ();
-	    refresh_main_screen ();
-	}
-  }
+            int i, j;
+            for (j = 0; j &lt; 4; j++) {
+                for (i = 0; i &lt; 4; i++) {
+                    do_bulldoze_area(CST_WATER, x + i, y + j);
+                }
+            }
+            connect_rivers();
+            refresh_main_screen();
+        }
+    }
 }
 
-void
-mps_oremine (int x, int y)
+void mps_oremine(int x, int y)
 {
-  int i = 0;
+    int i = 0;
 
-  mps_store_title(i++,_(&quot;Ore Mine&quot;));
-  i++;
+    mps_store_title(i++, _(&quot;Ore Mine&quot;));
+    i++;
 
-  mps_store_sfp(i++,_(&quot;Stock&quot;), 
-		MP_INFO(x,y).int_1 * 100.0 / DIG_MORE_ORE_TRIGGER);
-  i++;
+    mps_store_sfp(i++, _(&quot;Stock&quot;), MP_INFO(x, y).int_1 * 100.0 / DIG_MORE_ORE_TRIGGER);
+    i++;
 
-  mps_store_sfp(i++,_(&quot;Reserve&quot;),
-		MP_INFO(x,y).int_2 * 100.0 / (ORE_RESERVE * 16));
+    mps_store_sfp(i++, _(&quot;Reserve&quot;), MP_INFO(x, y).int_2 * 100.0 / (ORE_RESERVE * 16));
 }
-

Modified: trunk/src/lincity/modules/oremine.h
===================================================================
--- trunk/src/lincity/modules/oremine.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/oremine.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -9,6 +9,6 @@
 #define __oremine_h__
 
 void do_oremine(int x, int y);
-void mps_oremine (int x, int y);
+void mps_oremine(int x, int y);
 
 #endif /* __oremine_h__ */

Modified: trunk/src/lincity/modules/organic_farm.cpp
===================================================================
--- trunk/src/lincity/modules/organic_farm.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/organic_farm.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -12,202 +12,194 @@
 
 #include &lt;stdlib.h&gt;
 
-void
-do_organic_farm (int x, int y)
+void do_organic_farm(int x, int y)
 {
-  /* // MP_INFO(x,y)
-     // int_1 is the tech level of the farm when built
-     // int_2 is a flag so we don't create a farm with nearly ripe crops.
-      *      unused in NG1.1	
-     // int_3 is the food sold count so far this year.
-     // int_4 is the food made last year.
-     // int_5 is the random crop rotation key.
-     // int_6 is the random month stagger, so they don't all flash at once
-     // int_7 is the jobs stored at the farm 
-     // 	up to NG-1.1.0 int_7 was the tech-level dependent output of a
-     // 	 powered farm with full workforce. 
-     // 	= duplicate with int_1.  see below tech_bonus.
-      * 
-      * MP_INFO(x+1,y) stores additional info
-      *    int_1 reserved (=x)
-      *    int_2 reserved (=y)
-      *    int_3 max possible production (assuming 100% water and power)
-      *    int_4 number of 1x1 tiles with underground water inside the farm
-      *    int_5 current production
-  */
-  int i;
-  int has_power = false;
-  int tech_bonus = (int)(((double) MP_INFO(x,y).int_1
-			      * ORGANIC_FARM_FOOD_OUTPUT) / MAX_TECH_LEVEL);
-  MP_INFO(x+1,y).int_3 = ORGANIC_FARM_FOOD_OUTPUT + tech_bonus;
-  /* Animation */
-  if (MP_INFO(x,y).int_5 == 0) {
-      /* this should be done when we create the area! */
-      MP_INFO(x,y).int_5 = (rand () % 4) + 1;
-      MP_INFO(x,y).int_6 = rand () % 300; /* AL1 will be sooner or later redefined as %100. see below */
-  }
+    /* // MP_INFO(x,y)
+       // int_1 is the tech level of the farm when built
+       // int_2 is a flag so we don't create a farm with nearly ripe crops.
+       *      unused in NG1.1     
+       // int_3 is the food sold count so far this year.
+       // int_4 is the food made last year.
+       // int_5 is the random crop rotation key.
+       // int_6 is the random month stagger, so they don't all flash at once
+       // int_7 is the jobs stored at the farm 
+       //         up to NG-1.1.0 int_7 was the tech-level dependent output of a
+       //          powered farm with full workforce. 
+       //         = duplicate with int_1.  see below tech_bonus.
+       * 
+       * MP_INFO(x+1,y) stores additional info
+       *    int_1 reserved (=x)
+       *    int_2 reserved (=y)
+       *    int_3 max possible production (assuming 100% water and power)
+       *    int_4 number of 1x1 tiles with underground water inside the farm
+       *    int_5 current production
+     */
+    int i;
+    int has_power = false;
+    int tech_bonus = (int)(((double)MP_INFO(x, y).int_1 * ORGANIC_FARM_FOOD_OUTPUT) / MAX_TECH_LEVEL);
+    MP_INFO(x + 1, y).int_3 = ORGANIC_FARM_FOOD_OUTPUT + tech_bonus;
+    /* Animation */
+    if (MP_INFO(x, y).int_5 == 0) {
+        /* this should be done when we create the area! */
+        MP_INFO(x, y).int_5 = (rand() % 4) + 1;
+        MP_INFO(x, y).int_6 = rand() % 300;     /* AL1 will be sooner or later redefined as %100. see below */
+    }
 
-  /* check jobs */
-  if (MP_INFO(x,y).int_7 &lt; FARM_JOBS_USED) {
-  	if (get_jobs (x, y, FARM_JOBS_USED) != 0)
-		MP_INFO(x,y).int_7 += FARM_JOBS_USED;
-	/* adding if (get_jobs ... /2) would allow to have some jobs stored at farm,
-	 * so would smooth the behavior and make farms more resistant to job penury.
-	 * Currently keep previous behavior.
-	 */
-  	else if (get_jobs (x, y, FARM_JOBS_USED / 4) != 0)
-		MP_INFO(x,y).int_7 += FARM_JOBS_USED / 4;
-  	else if (get_jobs (x, y, 1) != 0)
-		MP_INFO(x,y).int_7 += 1;
-  }
+    /* check jobs */
+    if (MP_INFO(x, y).int_7 &lt; FARM_JOBS_USED) {
+        if (get_jobs(x, y, FARM_JOBS_USED) != 0)
+            MP_INFO(x, y).int_7 += FARM_JOBS_USED;
+        /* adding if (get_jobs ... /2) would allow to have some jobs stored at farm,
+         * so would smooth the behavior and make farms more resistant to job penury.
+         * Currently keep previous behavior.
+         */
+        else if (get_jobs(x, y, FARM_JOBS_USED / 4) != 0)
+            MP_INFO(x, y).int_7 += FARM_JOBS_USED / 4;
+        else if (get_jobs(x, y, 1) != 0)
+            MP_INFO(x, y).int_7 += 1;
+    }
 
-  /* check power */
-  MP_INFO(x,y).flags &amp;= (0xffffffff - FLAG_POWERED);
-  if (MP_INFO(x,y).int_7 &gt;= 1) {
-  	/* There are jobs to do some production, so check for power */
-	if (get_power (x, y, ORG_FARM_POWER_REC, 0) != 0) {
-		MP_INFO(x,y).flags |= FLAG_POWERED;
-		has_power = true;
-	}
-  }
+    /* check power */
+    MP_INFO(x, y).flags &amp;= (0xffffffff - FLAG_POWERED);
+    if (MP_INFO(x, y).int_7 &gt;= 1) {
+        /* There are jobs to do some production, so check for power */
+        if (get_power(x, y, ORG_FARM_POWER_REC, 0) != 0) {
+            MP_INFO(x, y).flags |= FLAG_POWERED;
+            has_power = true;
+        }
+    }
 
-  /* Produce some food */
-  int prod = 0;
-  if (MP_INFO(x,y).int_7 &gt;= FARM_JOBS_USED) {
-      if (has_power) {
-	      	 prod = ORGANIC_FARM_FOOD_OUTPUT + tech_bonus;
-      } else {
-	      	 prod = ORGANIC_FARM_FOOD_OUTPUT / 4;
-      }
-  } else if (MP_INFO(x,y).int_7 &gt;= FARM_JOBS_USED / 4) {
-      if (has_power) {
-	      	 prod = ORGANIC_FARM_FOOD_OUTPUT + tech_bonus / 4;
-      } else {
-	      	 prod = ORGANIC_FARM_FOOD_OUTPUT / (4 * 4);
-      }
-  } else if (MP_INFO(x,y).int_7 &gt;= 1) {
-      /* got 1 job */
-      if (has_power) {
-	     	prod = ORGANIC_FARM_FOOD_OUTPUT + tech_bonus / 8;
-      } else {
-	        /* AL1 &quot;small ouch&quot;:
-	         * without power output with 1 job is bigger than output with 3 !
-	         * 3 = FARMS_JOBS_USED / 4 
-	         * ORGANIC_FARM_FOOD_OUTPUT = 550 currently (ng_1.1)
-	         */
-	         prod = 30 + ORGANIC_FARM_FOOD_OUTPUT / (4 * 8);
-      }
-  } else {
-            /* AL1 : the farm gives very small amount of food without job. 
-             *  ? Probably needed for start ?
-             *  ? Useful to prevent starvation when no jobs ? 
-             *  The various buildings are &quot;done&quot; in random order,
-             *  so it should be ok without this.
+    /* Produce some food */
+    int prod = 0;
+    if (MP_INFO(x, y).int_7 &gt;= FARM_JOBS_USED) {
+        if (has_power) {
+            prod = ORGANIC_FARM_FOOD_OUTPUT + tech_bonus;
+        } else {
+            prod = ORGANIC_FARM_FOOD_OUTPUT / 4;
+        }
+    } else if (MP_INFO(x, y).int_7 &gt;= FARM_JOBS_USED / 4) {
+        if (has_power) {
+            prod = ORGANIC_FARM_FOOD_OUTPUT + tech_bonus / 4;
+        } else {
+            prod = ORGANIC_FARM_FOOD_OUTPUT / (4 * 4);
+        }
+    } else if (MP_INFO(x, y).int_7 &gt;= 1) {
+        /* got 1 job */
+        if (has_power) {
+            prod = ORGANIC_FARM_FOOD_OUTPUT + tech_bonus / 8;
+        } else {
+            /* AL1 &quot;small ouch&quot;:
+             * without power output with 1 job is bigger than output with 3 !
+             * 3 = FARMS_JOBS_USED / 4 
+             * ORGANIC_FARM_FOOD_OUTPUT = 550 currently (ng_1.1)
              */
-             put_food (x, y, 30);
-             /* note that this does not generate revenu int_3) */
-  }
-  /* Check underground water, and reduce production accordingly */
-  if (use_waterwell) {
-      int w = 0;
-      int n = 0;
-      for (int i = 0; i &lt; MP_SIZE(x,y); i++) {
-          for (int j = 0; j &lt; MP_SIZE(x,y); j++) {
-              n++;
-              if (HAS_UGWATER(x+i,y+j))
-                  w++;
-          }
-      }
-      prod = (prod * w)/n;
-      MP_INFO(x + 1, y).int_4 = w;
-  }
-  MP_INFO(x + 1, y).int_5 = prod;
-                 	 
-  if (prod != 0) {
-     if (put_food (x, y, prod) != 0) {
-	    	MP_INFO(x,y).int_3++;
-		    MP_INFO(x,y).int_7 -= 1;
-     }
-  }
+            prod = 30 + ORGANIC_FARM_FOOD_OUTPUT / (4 * 8);
+        }
+    } else {
+        /* AL1 : the farm gives very small amount of food without job. 
+         *  ? Probably needed for start ?
+         *  ? Useful to prevent starvation when no jobs ? 
+         *  The various buildings are &quot;done&quot; in random order,
+         *  so it should be ok without this.
+         */
+        put_food(x, y, 30);
+        /* note that this does not generate revenu int_3) */
+    }
+    /* Check underground water, and reduce production accordingly */
+    if (use_waterwell) {
+        int w = 0;
+        int n = 0;
+        for (int i = 0; i &lt; MP_SIZE(x, y); i++) {
+            for (int j = 0; j &lt; MP_SIZE(x, y); j++) {
+                n++;
+                if (HAS_UGWATER(x + i, y + j))
+                    w++;
+            }
+        }
+        prod = (prod * w) / n;
+        MP_INFO(x + 1, y).int_4 = w;
+    }
+    MP_INFO(x + 1, y).int_5 = prod;
 
-  if ((total_time &amp; 0x7f) == 0)
-    if ((MP_INFO(x,y).flags &amp; FLAG_POWERED) != 0)
-      get_waste (x, y, 0x80 * ORG_FARM_WASTE_GET);
+    if (prod != 0) {
+        if (put_food(x, y, prod) != 0) {
+            MP_INFO(x, y).int_3++;
+            MP_INFO(x, y).int_7 -= 1;
+        }
+    }
 
-  if ((total_time % 1200) == 0) {
-      MP_INFO(x,y).int_4 = MP_INFO(x,y).int_3;
-      MP_INFO(x,y).int_3 = 0;
-  }
+    if ((total_time &amp; 0x7f) == 0)
+        if ((MP_INFO(x, y).flags &amp; FLAG_POWERED) != 0)
+            get_waste(x, y, 0x80 * ORG_FARM_WASTE_GET);
 
-  i = (total_time + MP_INFO(x,y).int_5 * 1200 + MP_INFO(x,y).int_6) % 4800;
+    if ((total_time % 1200) == 0) {
+        MP_INFO(x, y).int_4 = MP_INFO(x, y).int_3;
+        MP_INFO(x, y).int_3 = 0;
+    }
 
-  if (i % 300 == 0)
-    {
-      i /= 300;
-      if ( /* MP_INFO(x,y).int_2!=0 &amp;&amp;  */ MP_INFO(x,y).int_4
-	  &gt; MIN_FOOD_SOLD_FOR_ANIM)
-	{
-	  if (i % 4 == 0)
-	    {
-	      MP_INFO(x,y).int_6 = rand () % 100; /* AL1: initially defined as %300 */
-	    }
-	  switch (i)
-	    {
-	    case (0):
-	      MP_TYPE(x,y) = CST_FARM_O3;
-	      break;
-	    case (1):
-	      MP_TYPE(x,y) = CST_FARM_O3;
-	      break;
-	    case (2):
-	      MP_TYPE(x,y) = CST_FARM_O3;
-	      break;
-	    case (3):
-	      MP_TYPE(x,y) = CST_FARM_O3;
-	      break;
-	    case (4):
-	      MP_TYPE(x,y) = CST_FARM_O7;
-	      break;
-	    case (5):
-	      MP_TYPE(x,y) = CST_FARM_O7;
-	      break;
-	    case (6):
-	      MP_TYPE(x,y) = CST_FARM_O7;
-	      break;
-	    case (7):
-	      MP_TYPE(x,y) = CST_FARM_O7;
-	      break;
-	    case (8):
-	      MP_TYPE(x,y) = CST_FARM_O11;
-	      break;
-	    case (9):
-	      MP_TYPE(x,y) = CST_FARM_O11;
-	      break;
-	    case (10):
-	      MP_TYPE(x,y) = CST_FARM_O11;
-	      break;
-	    case (11):
-	      MP_TYPE(x,y) = CST_FARM_O11;
-	      break;
-	    case (12):
-	      MP_TYPE(x,y) = CST_FARM_O15;
-	      break;
-	    case (13):
-	      MP_TYPE(x,y) = CST_FARM_O15;
-	      break;
-	    case (14):
-	      MP_TYPE(x,y) = CST_FARM_O15;
-	      break;
-	    case (15):
-	      MP_TYPE(x,y) = CST_FARM_O15;
-	      break;
+    i = (total_time + MP_INFO(x, y).int_5 * 1200 + MP_INFO(x, y).int_6) % 4800;
 
-	    }
-	}
-      else
-	{
-	  MP_TYPE(x,y) = CST_FARM_O0;
-	}
+    if (i % 300 == 0) {
+        i /= 300;
+        if ( /* MP_INFO(x,y).int_2!=0 &amp;&amp;  */ MP_INFO(x, y).int_4
+            &gt; MIN_FOOD_SOLD_FOR_ANIM) {
+            if (i % 4 == 0) {
+                MP_INFO(x, y).int_6 = rand() % 100;     /* AL1: initially defined as %300 */
+            }
+            switch (i) {
+            case (0):
+                MP_TYPE(x, y) = CST_FARM_O3;
+                break;
+            case (1):
+                MP_TYPE(x, y) = CST_FARM_O3;
+                break;
+            case (2):
+                MP_TYPE(x, y) = CST_FARM_O3;
+                break;
+            case (3):
+                MP_TYPE(x, y) = CST_FARM_O3;
+                break;
+            case (4):
+                MP_TYPE(x, y) = CST_FARM_O7;
+                break;
+            case (5):
+                MP_TYPE(x, y) = CST_FARM_O7;
+                break;
+            case (6):
+                MP_TYPE(x, y) = CST_FARM_O7;
+                break;
+            case (7):
+                MP_TYPE(x, y) = CST_FARM_O7;
+                break;
+            case (8):
+                MP_TYPE(x, y) = CST_FARM_O11;
+                break;
+            case (9):
+                MP_TYPE(x, y) = CST_FARM_O11;
+                break;
+            case (10):
+                MP_TYPE(x, y) = CST_FARM_O11;
+                break;
+            case (11):
+                MP_TYPE(x, y) = CST_FARM_O11;
+                break;
+            case (12):
+                MP_TYPE(x, y) = CST_FARM_O15;
+                break;
+            case (13):
+                MP_TYPE(x, y) = CST_FARM_O15;
+                break;
+            case (14):
+                MP_TYPE(x, y) = CST_FARM_O15;
+                break;
+            case (15):
+                MP_TYPE(x, y) = CST_FARM_O15;
+                break;
+
+            }
+        } else {
+            MP_TYPE(x, y) = CST_FARM_O0;
+        }
     }
 }
 
@@ -217,61 +209,56 @@
 #endif
 #define MPS_INFO_CHARS 30
 
-void
-mps_organic_farm (int x, int y)
+void mps_organic_farm(int x, int y)
 {
-  int i = 0;
-  const char *p;
-  char text[MPS_INFO_CHARS+1];
+    int i = 0;
+    const char *p;
+    char text[MPS_INFO_CHARS + 1];
 
   /** removed depency on mps_info */
-  mps_store_title(i++,_(&quot;Organic Farm&quot;));
-  i++;
+    mps_store_title(i++, _(&quot;Organic Farm&quot;));
+    i++;
 
-  if ((MP_INFO(x,y).flags &amp; FLAG_POWERED) != 0)
-    p = _(&quot;YES&quot;);
-  else
-    p = _(&quot;NO &quot;);
-  
-  snprintf(text, MPS_INFO_CHARS, &quot;%s %s&quot;, _(&quot;Power&quot;), p);
-  mps_store_title(i++,text);
+    if ((MP_INFO(x, y).flags &amp; FLAG_POWERED) != 0)
+        p = _(&quot;YES&quot;);
+    else
+        p = _(&quot;NO &quot;);
 
-  snprintf(text, MPS_INFO_CHARS, &quot;%s  %5.1f%%&quot;, _(&quot;Tech&quot;), 
-	   MP_INFO(x,y).int_1 * 100.0 / MAX_TECH_LEVEL);
-  mps_store_title(i++,text);
+    snprintf(text, MPS_INFO_CHARS, &quot;%s %s&quot;, _(&quot;Power&quot;), p);
+    mps_store_title(i++, text);
 
-  snprintf(text, MPS_INFO_CHARS, &quot;%s  %5.1f%%&quot;, _(&quot;Prod&quot;),
-	   MP_INFO(x,y).int_4 * 100.0 / 1200.0);
-  mps_store_title(i++,text);
+    snprintf(text, MPS_INFO_CHARS, &quot;%s  %5.1f%%&quot;, _(&quot;Tech&quot;), MP_INFO(x, y).int_1 * 100.0 / MAX_TECH_LEVEL);
+    mps_store_title(i++, text);
 
-  if (use_waterwell) {
-      i++;
-      mps_store_title(i++,_(&quot;Debug info&quot;));
-      mps_store_sd(i++,_(&quot; max with power &amp; water&quot;), MP_INFO(x + 1, y).int_3);
-      mps_store_sd(i++,_(&quot; number of tile with water&quot;), MP_INFO(x + 1, y).int_4);
-      mps_store_sd(i++,_(&quot; current production&quot;), MP_INFO(x + 1, y).int_5);
-  }
+    snprintf(text, MPS_INFO_CHARS, &quot;%s  %5.1f%%&quot;, _(&quot;Prod&quot;), MP_INFO(x, y).int_4 * 100.0 / 1200.0);
+    mps_store_title(i++, text);
 
-  /*
-  char * p;
+    if (use_waterwell) {
+        i++;
+        mps_store_title(i++, _(&quot;Debug info&quot;));
+        mps_store_sd(i++, _(&quot; max with power &amp; water&quot;), MP_INFO(x + 1, y).int_3);
+        mps_store_sd(i++, _(&quot; number of tile with water&quot;), MP_INFO(x + 1, y).int_4);
+        mps_store_sd(i++, _(&quot; current production&quot;), MP_INFO(x + 1, y).int_5);
+    }
 
-  snprintf(mps_info[i++], MPS_INFO_CHARS, _(&quot;Organic Farm&quot;));
-  i++;
+    /*
+       char * p;
 
-  if ((MP_INFO(x,y).flags &amp; FLAG_POWERED) != 0)
-    p = _(&quot;YES&quot;);
-  else
-    p = _(&quot;NO &quot;);
+       snprintf(mps_info[i++], MPS_INFO_CHARS, _(&quot;Organic Farm&quot;));
+       i++;
 
-  snprintf(mps_info[i++], MPS_INFO_CHARS, &quot;%s %s&quot;, _(&quot;Power&quot;), p);
+       if ((MP_INFO(x,y).flags &amp; FLAG_POWERED) != 0)
+       p = _(&quot;YES&quot;);
+       else
+       p = _(&quot;NO &quot;);
 
-  snprintf(mps_info[i++], MPS_INFO_CHARS, &quot;%s  %5.1f%%&quot;, _(&quot;Tech&quot;), 
-	   MP_INFO(x,y).int_1 * 100.0 / MAX_TECH_LEVEL);
+       snprintf(mps_info[i++], MPS_INFO_CHARS, &quot;%s %s&quot;, _(&quot;Power&quot;), p);
 
-  snprintf(mps_info[i++], MPS_INFO_CHARS, &quot;%s  %5.1f%%&quot;, _(&quot;Prod&quot;),
-	   MP_INFO(x,y).int_4 * 100.0 / 1200.0);
+       snprintf(mps_info[i++], MPS_INFO_CHARS, &quot;%s  %5.1f%%&quot;, _(&quot;Tech&quot;), 
+       MP_INFO(x,y).int_1 * 100.0 / MAX_TECH_LEVEL);
 
-  */
-}
+       snprintf(mps_info[i++], MPS_INFO_CHARS, &quot;%s  %5.1f%%&quot;, _(&quot;Prod&quot;),
+       MP_INFO(x,y).int_4 * 100.0 / 1200.0);
 
-
+     */
+}

Modified: trunk/src/lincity/modules/organic_farm.h
===================================================================
--- trunk/src/lincity/modules/organic_farm.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/organic_farm.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -7,7 +7,7 @@
 #ifndef __organic_farm_h__
 #define __organic_farm_h__
 
-void do_organic_farm (int x, int y);
+void do_organic_farm(int x, int y);
 void mps_organic_farm(int x, int y);
 
 #endif /* __organic_farm_h__ */

Modified: trunk/src/lincity/modules/parkland.cpp
===================================================================
--- trunk/src/lincity/modules/parkland.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/parkland.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -8,9 +8,8 @@
 #include &quot;modules.h&quot;
 #include &quot;parkland.h&quot;
 
-void
-do_parkland (int x, int y)
+void do_parkland(int x, int y)
 {
-  if (MP_POL(x,y) &gt; 10 &amp;&amp; (total_time &amp; 1) == 0)
-    MP_POL(x,y) -= 1;
+    if (MP_POL(x, y) &gt; 10 &amp;&amp; (total_time &amp; 1) == 0)
+        MP_POL(x, y) -= 1;
 }

Modified: trunk/src/lincity/modules/port.cpp
===================================================================
--- trunk/src/lincity/modules/port.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/port.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -8,362 +8,301 @@
 #include &quot;modules.h&quot;
 #include &quot;port.h&quot;
 
-static int
-buy_food (int xt, int yt)
+static int buy_food(int xt, int yt)
 {
-  int i = 0;
-  if (MP_GROUP(xt,yt) == GROUP_TRACK)
-    {
-      if (MP_INFO(xt,yt).int_1 &lt; MAX_FOOD_ON_TRACK)
-	i = MAX_FOOD_ON_TRACK - MP_INFO(xt,yt).int_1;
+    int i = 0;
+    if (MP_GROUP(xt, yt) == GROUP_TRACK) {
+        if (MP_INFO(xt, yt).int_1 &lt; MAX_FOOD_ON_TRACK)
+            i = MAX_FOOD_ON_TRACK - MP_INFO(xt, yt).int_1;
+    } else if (MP_GROUP(xt, yt) == GROUP_ROAD) {
+        if (MP_INFO(xt, yt).int_1 &lt; MAX_FOOD_ON_ROAD)
+            i = MAX_FOOD_ON_ROAD - MP_INFO(xt, yt).int_1;
+    } else if (MP_GROUP(xt, yt) == GROUP_RAIL) {
+        if (MP_INFO(xt, yt).int_1 &lt; MAX_FOOD_ON_RAIL)
+            i = MAX_FOOD_ON_RAIL - MP_INFO(xt, yt).int_1;
     }
-  else if (MP_GROUP(xt,yt) == GROUP_ROAD)
-    {
-      if (MP_INFO(xt,yt).int_1 &lt; MAX_FOOD_ON_ROAD)
-	i = MAX_FOOD_ON_ROAD - MP_INFO(xt,yt).int_1;
-    }
-  else if (MP_GROUP(xt,yt) == GROUP_RAIL)
-    {
-      if (MP_INFO(xt,yt).int_1 &lt; MAX_FOOD_ON_RAIL)
-	i = MAX_FOOD_ON_RAIL - MP_INFO(xt,yt).int_1;
-    }
-  i = (i * PORT_IMPORT_RATE) / 1000;
-  MP_INFO(xt,yt).int_1 += i;
-  return (i * PORT_FOOD_RATE);
+    i = (i * PORT_IMPORT_RATE) / 1000;
+    MP_INFO(xt, yt).int_1 += i;
+    return (i * PORT_FOOD_RATE);
 }
 
-static int
-buy_coal (int xt, int yt)
+static int buy_coal(int xt, int yt)
 {
-  int i = 0;
-  if (MP_GROUP(xt,yt) == GROUP_TRACK)
-    {
-      if (MP_INFO(xt,yt).int_3 &lt; MAX_COAL_ON_TRACK)
-	i = MAX_COAL_ON_TRACK - MP_INFO(xt,yt).int_3;
+    int i = 0;
+    if (MP_GROUP(xt, yt) == GROUP_TRACK) {
+        if (MP_INFO(xt, yt).int_3 &lt; MAX_COAL_ON_TRACK)
+            i = MAX_COAL_ON_TRACK - MP_INFO(xt, yt).int_3;
+    } else if (MP_GROUP(xt, yt) == GROUP_ROAD) {
+        if (MP_INFO(xt, yt).int_3 &lt; MAX_COAL_ON_ROAD)
+            i = MAX_COAL_ON_ROAD - MP_INFO(xt, yt).int_3;
+    } else if (MP_GROUP(xt, yt) == GROUP_RAIL) {
+        if (MP_INFO(xt, yt).int_3 &lt; MAX_COAL_ON_RAIL)
+            i = MAX_COAL_ON_RAIL - MP_INFO(xt, yt).int_3;
     }
-  else if (MP_GROUP(xt,yt) == GROUP_ROAD)
-    {
-      if (MP_INFO(xt,yt).int_3 &lt; MAX_COAL_ON_ROAD)
-	i = MAX_COAL_ON_ROAD - MP_INFO(xt,yt).int_3;
-    }
-  else if (MP_GROUP(xt,yt) == GROUP_RAIL)
-    {
-      if (MP_INFO(xt,yt).int_3 &lt; MAX_COAL_ON_RAIL)
-	i = MAX_COAL_ON_RAIL - MP_INFO(xt,yt).int_3;
-    }
-  i = (i * PORT_IMPORT_RATE) / 1000;
-  MP_INFO(xt,yt).int_3 += i;
-  return (i * PORT_COAL_RATE);
+    i = (i * PORT_IMPORT_RATE) / 1000;
+    MP_INFO(xt, yt).int_3 += i;
+    return (i * PORT_COAL_RATE);
 }
 
-static int
-buy_ore (int xt, int yt)
+static int buy_ore(int xt, int yt)
 {
-  int i = 0;
-  if (MP_GROUP(xt,yt) == GROUP_TRACK)
-    {
-      if (MP_INFO(xt,yt).int_5 &lt; MAX_ORE_ON_TRACK)
-	i = MAX_ORE_ON_TRACK - MP_INFO(xt,yt).int_5;
+    int i = 0;
+    if (MP_GROUP(xt, yt) == GROUP_TRACK) {
+        if (MP_INFO(xt, yt).int_5 &lt; MAX_ORE_ON_TRACK)
+            i = MAX_ORE_ON_TRACK - MP_INFO(xt, yt).int_5;
+    } else if (MP_GROUP(xt, yt) == GROUP_ROAD) {
+        if (MP_INFO(xt, yt).int_5 &lt; MAX_ORE_ON_ROAD)
+            i = MAX_ORE_ON_ROAD - MP_INFO(xt, yt).int_5;
+    } else if (MP_GROUP(xt, yt) == GROUP_RAIL) {
+        if (MP_INFO(xt, yt).int_5 &lt; MAX_ORE_ON_RAIL)
+            i = MAX_ORE_ON_RAIL - MP_INFO(xt, yt).int_5;
     }
-  else if (MP_GROUP(xt,yt) == GROUP_ROAD)
-    {
-      if (MP_INFO(xt,yt).int_5 &lt; MAX_ORE_ON_ROAD)
-	i = MAX_ORE_ON_ROAD - MP_INFO(xt,yt).int_5;
-    }
-  else if (MP_GROUP(xt,yt) == GROUP_RAIL)
-    {
-      if (MP_INFO(xt,yt).int_5 &lt; MAX_ORE_ON_RAIL)
-	i = MAX_ORE_ON_RAIL - MP_INFO(xt,yt).int_5;
-    }
-  i = (i * PORT_IMPORT_RATE) / 1000;
-  MP_INFO(xt,yt).int_5 += i;
-  return (i * PORT_ORE_RATE);
+    i = (i * PORT_IMPORT_RATE) / 1000;
+    MP_INFO(xt, yt).int_5 += i;
+    return (i * PORT_ORE_RATE);
 }
 
-static int
-buy_goods (int xt, int yt)
+static int buy_goods(int xt, int yt)
 {
-  int i = 0;
-  if (MP_GROUP(xt,yt) == GROUP_TRACK)
-    {
-      if (MP_INFO(xt,yt).int_4 &lt; MAX_GOODS_ON_TRACK)
-	i = MAX_GOODS_ON_TRACK - MP_INFO(xt,yt).int_4;
+    int i = 0;
+    if (MP_GROUP(xt, yt) == GROUP_TRACK) {
+        if (MP_INFO(xt, yt).int_4 &lt; MAX_GOODS_ON_TRACK)
+            i = MAX_GOODS_ON_TRACK - MP_INFO(xt, yt).int_4;
+    } else if (MP_GROUP(xt, yt) == GROUP_ROAD) {
+        if (MP_INFO(xt, yt).int_4 &lt; MAX_GOODS_ON_ROAD)
+            i = MAX_GOODS_ON_ROAD - MP_INFO(xt, yt).int_4;
+    } else if (MP_GROUP(xt, yt) == GROUP_RAIL) {
+        if (MP_INFO(xt, yt).int_4 &lt; MAX_GOODS_ON_RAIL)
+            i = MAX_GOODS_ON_RAIL - MP_INFO(xt, yt).int_4;
     }
-  else if (MP_GROUP(xt,yt) == GROUP_ROAD)
-    {
-      if (MP_INFO(xt,yt).int_4 &lt; MAX_GOODS_ON_ROAD)
-	i = MAX_GOODS_ON_ROAD - MP_INFO(xt,yt).int_4;
-    }
-  else if (MP_GROUP(xt,yt) == GROUP_RAIL)
-    {
-      if (MP_INFO(xt,yt).int_4 &lt; MAX_GOODS_ON_RAIL)
-	i = MAX_GOODS_ON_RAIL - MP_INFO(xt,yt).int_4;
-    }
-  i = (i * PORT_IMPORT_RATE) / 1000;
-  MP_INFO(xt,yt).int_4 += i;
-  return (i * PORT_GOODS_RATE);
+    i = (i * PORT_IMPORT_RATE) / 1000;
+    MP_INFO(xt, yt).int_4 += i;
+    return (i * PORT_GOODS_RATE);
 }
 
-
-static int
-buy_steel (int xt, int yt)
+static int buy_steel(int xt, int yt)
 {
-  int i = 0;
-  if (MP_GROUP(xt,yt) == GROUP_TRACK)
-    {
-      if (MP_INFO(xt,yt).int_6 &lt; MAX_STEEL_ON_TRACK)
-	i = MAX_STEEL_ON_TRACK - MP_INFO(xt,yt).int_6;
+    int i = 0;
+    if (MP_GROUP(xt, yt) == GROUP_TRACK) {
+        if (MP_INFO(xt, yt).int_6 &lt; MAX_STEEL_ON_TRACK)
+            i = MAX_STEEL_ON_TRACK - MP_INFO(xt, yt).int_6;
+    } else if (MP_GROUP(xt, yt) == GROUP_ROAD) {
+        if (MP_INFO(xt, yt).int_6 &lt; MAX_STEEL_ON_ROAD)
+            i = MAX_STEEL_ON_ROAD - MP_INFO(xt, yt).int_6;
+    } else if (MP_GROUP(xt, yt) == GROUP_RAIL) {
+        if (MP_INFO(xt, yt).int_6 &lt; MAX_STEEL_ON_RAIL)
+            i = MAX_STEEL_ON_RAIL - MP_INFO(xt, yt).int_6;
     }
-  else if (MP_GROUP(xt,yt) == GROUP_ROAD)
-    {
-      if (MP_INFO(xt,yt).int_6 &lt; MAX_STEEL_ON_ROAD)
-	i = MAX_STEEL_ON_ROAD - MP_INFO(xt,yt).int_6;
-    }
-  else if (MP_GROUP(xt,yt) == GROUP_RAIL)
-    {
-      if (MP_INFO(xt,yt).int_6 &lt; MAX_STEEL_ON_RAIL)
-	i = MAX_STEEL_ON_RAIL - MP_INFO(xt,yt).int_6;
-    }
-  i = (i * PORT_IMPORT_RATE) / 1000;
-  MP_INFO(xt,yt).int_6 += i;
-  return (i * PORT_STEEL_RATE);
+    i = (i * PORT_IMPORT_RATE) / 1000;
+    MP_INFO(xt, yt).int_6 += i;
+    return (i * PORT_STEEL_RATE);
 }
 
-static int
-sell_food (int xt, int yt)
+static int sell_food(int xt, int yt)
 {
-  int i = 0;
-  i = (MP_INFO(xt,yt).int_1 * PORT_EXPORT_RATE) / 1000;
-  MP_INFO(xt,yt).int_1 -= i;
-  return (i * PORT_FOOD_RATE);
+    int i = 0;
+    i = (MP_INFO(xt, yt).int_1 * PORT_EXPORT_RATE) / 1000;
+    MP_INFO(xt, yt).int_1 -= i;
+    return (i * PORT_FOOD_RATE);
 }
 
-static int
-sell_coal (int xt, int yt)
+static int sell_coal(int xt, int yt)
 {
-  int i = 0;
-  i = (MP_INFO(xt,yt).int_3 * PORT_EXPORT_RATE) / 1000;
-  MP_INFO(xt,yt).int_3 -= i;
-  return (i * PORT_COAL_RATE);
+    int i = 0;
+    i = (MP_INFO(xt, yt).int_3 * PORT_EXPORT_RATE) / 1000;
+    MP_INFO(xt, yt).int_3 -= i;
+    return (i * PORT_COAL_RATE);
 }
 
-static int
-sell_ore (int xt, int yt)
+static int sell_ore(int xt, int yt)
 {
-  int i = 0;
-  i = (MP_INFO(xt,yt).int_5 * PORT_EXPORT_RATE) / 1000;
-  MP_INFO(xt,yt).int_5 -= i;
-  return (i * PORT_ORE_RATE);
+    int i = 0;
+    i = (MP_INFO(xt, yt).int_5 * PORT_EXPORT_RATE) / 1000;
+    MP_INFO(xt, yt).int_5 -= i;
+    return (i * PORT_ORE_RATE);
 }
 
-static int
-sell_goods (int xt, int yt)
+static int sell_goods(int xt, int yt)
 {
-  int i = 0;
-  i = (MP_INFO(xt,yt).int_4 * PORT_EXPORT_RATE) / 1000;
-  MP_INFO(xt,yt).int_4 -= i;
-  return (i * PORT_GOODS_RATE);
+    int i = 0;
+    i = (MP_INFO(xt, yt).int_4 * PORT_EXPORT_RATE) / 1000;
+    MP_INFO(xt, yt).int_4 -= i;
+    return (i * PORT_GOODS_RATE);
 }
 
-static int
-sell_steel (int xt, int yt)
+static int sell_steel(int xt, int yt)
 {
-  int i = 0;
-  i = (MP_INFO(xt,yt).int_6 * PORT_EXPORT_RATE) / 1000;
-  MP_INFO(xt,yt).int_6 -= i;
-  return (i * PORT_STEEL_RATE);
+    int i = 0;
+    i = (MP_INFO(xt, yt).int_6 * PORT_EXPORT_RATE) / 1000;
+    MP_INFO(xt, yt).int_6 -= i;
+    return (i * PORT_STEEL_RATE);
 }
 
 /* Trade with a transport.
  * Port is at x/y, transport at u/v. */
-static void
-trade_connection( const int x, const int y, const int u, const int v, int* ic_ptr, int* et_ptr )
+static void trade_connection(const int x, const int y, const int u, const int v, int *ic_ptr, int *et_ptr)
 {
-  if (u &gt;= 0 &amp;&amp; v&gt;=0 &amp;&amp; (MP_INFO( u, v).flags
-              &amp; FLAG_IS_TRANSPORT) != 0)
-  {
-      //printf(&quot;Port %i/%i trading with transport %i/%i\n&quot;, x,y,u,v);
-      int i, flags;
-      int ic = 0;
-      int et = 0;
-      flags = MP_INFO(x,y).flags;
-      if ((flags &amp; FLAG_MB_FOOD) != 0)
-      {
-          i = buy_food ( u, v);
-          ic += i;
-          MP_INFO(x + 1,y).int_3 += i;
-      }
-      if ((flags &amp; FLAG_MS_FOOD) != 0)
-      {
-          i = sell_food ( u, v);
-          et += i;
-          MP_INFO(x + 2,y).int_3 += i;
-      }
-      if ((flags &amp; FLAG_MB_COAL) != 0)
-      {
-          i = buy_coal ( u, v);
-          ic += i;
-          MP_INFO(x + 1,y).int_4 += i;
-      }
-      if ((flags &amp; FLAG_MS_COAL) != 0)
-      {
-          i = sell_coal ( u, v);
-          et += i;
-          MP_INFO(x + 2,y).int_4 += i;
-      }
-      if ((flags &amp; FLAG_MB_ORE) != 0)
-      {
-          i = buy_ore ( u, v);
-          ic += i;
-          MP_INFO(x + 1,y).int_5 += i;
-      }
-      if ((flags &amp; FLAG_MS_ORE) != 0)
-      {
-          i = sell_ore ( u, v);
-          et += i;
-          MP_INFO(x + 2,y).int_5 += i;
-      }
-      if ((flags &amp; FLAG_MB_GOODS) != 0)
-      {
-          i = buy_goods ( u, v);
-          ic += i;
-          MP_INFO(x + 1,y).int_6 += i;
-      }
-      if ((flags &amp; FLAG_MS_GOODS) != 0)
-      {
-          i = sell_goods ( u, v);
-          et += i;
-          MP_INFO(x + 2,y).int_6 += i;
-      }
-      if ((flags &amp; FLAG_MB_STEEL) != 0)
-      {
-          i = buy_steel ( u, v);
-          ic += i;
-          MP_INFO(x + 1,y).int_7 += i;
-      }
-      if ((flags &amp; FLAG_MS_STEEL) != 0)
-      {
-          i = sell_steel ( u, v);
-          et += i;
-          MP_INFO(x + 2,y).int_7 += i;
-      }
-      *ic_ptr += ic;
-      *et_ptr += et;
-  }
+    if (u &gt;= 0 &amp;&amp; v &gt;= 0 &amp;&amp; (MP_INFO(u, v).flags &amp; FLAG_IS_TRANSPORT) != 0) {
+        //printf(&quot;Port %i/%i trading with transport %i/%i\n&quot;, x,y,u,v);
+        int i, flags;
+        int ic = 0;
+        int et = 0;
+        flags = MP_INFO(x, y).flags;
+        if ((flags &amp; FLAG_MB_FOOD) != 0) {
+            i = buy_food(u, v);
+            ic += i;
+            MP_INFO(x + 1, y).int_3 += i;
+        }
+        if ((flags &amp; FLAG_MS_FOOD) != 0) {
+            i = sell_food(u, v);
+            et += i;
+            MP_INFO(x + 2, y).int_3 += i;
+        }
+        if ((flags &amp; FLAG_MB_COAL) != 0) {
+            i = buy_coal(u, v);
+            ic += i;
+            MP_INFO(x + 1, y).int_4 += i;
+        }
+        if ((flags &amp; FLAG_MS_COAL) != 0) {
+            i = sell_coal(u, v);
+            et += i;
+            MP_INFO(x + 2, y).int_4 += i;
+        }
+        if ((flags &amp; FLAG_MB_ORE) != 0) {
+            i = buy_ore(u, v);
+            ic += i;
+            MP_INFO(x + 1, y).int_5 += i;
+        }
+        if ((flags &amp; FLAG_MS_ORE) != 0) {
+            i = sell_ore(u, v);
+            et += i;
+            MP_INFO(x + 2, y).int_5 += i;
+        }
+        if ((flags &amp; FLAG_MB_GOODS) != 0) {
+            i = buy_goods(u, v);
+            ic += i;
+            MP_INFO(x + 1, y).int_6 += i;
+        }
+        if ((flags &amp; FLAG_MS_GOODS) != 0) {
+            i = sell_goods(u, v);
+            et += i;
+            MP_INFO(x + 2, y).int_6 += i;
+        }
+        if ((flags &amp; FLAG_MB_STEEL) != 0) {
+            i = buy_steel(u, v);
+            ic += i;
+            MP_INFO(x + 1, y).int_7 += i;
+        }
+        if ((flags &amp; FLAG_MS_STEEL) != 0) {
+            i = sell_steel(u, v);
+            et += i;
+            MP_INFO(x + 2, y).int_7 += i;
+        }
+        *ic_ptr += ic;
+        *et_ptr += et;
+    }
 }
 
-void
-do_port (int x, int y)
+void do_port(int x, int y)
 {
-  /*
-     // int_1 is the money made so far this month
-     // int_2 is the money made last month
-     // int_3 holds the 'pence/pennies/bits' to add next time round.
-     // int_4 is the import costs so far this month
-     // int_5 is the import costs for last month
-     // Use int_3 to int_7 of (x+1,y) to hold the individual buy values
-     //                       (x,y+1) is last month's
-     // Use int_3 to int_7 of (x+2,y) to hold the individual sell values
-     //                       (x,y+2) is last month's
-   */
-  int i, et = 0, ic = 0, *b1, *b2, *s1, *s2, a;
+    /*
+       // int_1 is the money made so far this month
+       // int_2 is the money made last month
+       // int_3 holds the 'pence/pennies/bits' to add next time round.
+       // int_4 is the import costs so far this month
+       // int_5 is the import costs for last month
+       // Use int_3 to int_7 of (x+1,y) to hold the individual buy values
+       //                       (x,y+1) is last month's
+       // Use int_3 to int_7 of (x+2,y) to hold the individual sell values
+       //                       (x,y+2) is last month's
+     */
+    int i, et = 0, ic = 0, *b1, *b2, *s1, *s2, a;
 
-      
- /* left connection first */
-  for( a = 0; a &lt; 4 ; a++ ) //try anywhere on the west side.
-    if ( x &gt;= 0 &amp;&amp; y&gt;=0 &amp;&amp; (MP_INFO( x-1, y+a ).flags
-              &amp; FLAG_IS_TRANSPORT) != 0){
-        trade_connection( x, y, x-1, y+a, &amp;ic, &amp;et );
-        break;
+    /* left connection first */
+    for (a = 0; a &lt; 4; a++)     //try anywhere on the west side.
+        if (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; (MP_INFO(x - 1, y + a).flags &amp; FLAG_IS_TRANSPORT) != 0) {
+            trade_connection(x, y, x - 1, y + a, &amp;ic, &amp;et);
+            break;
+        }
+    /* upper gate next */
+    bool deal = false;
+    for (a = 0; a &lt; 3; a++)     //try north
+        if (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; (MP_INFO(x + a, y - 1).flags &amp; FLAG_IS_TRANSPORT) != 0) {
+            trade_connection(x, y, x + a, y - 1, &amp;ic, &amp;et);
+            deal = false;
+            break;
+        }
+    if (!deal)
+        for (a = 0; a &lt; 3; a++) //try south
+            if (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; (MP_INFO(x + a, y + 4).flags &amp; FLAG_IS_TRANSPORT) != 0) {
+                trade_connection(x, y, x + a, y + 4, &amp;ic, &amp;et);
+                break;
+            }
+
+    MP_INFO(x, y).int_1 += et;
+    MP_INFO(x, y).int_4 += ic;
+    if (total_time % 100 == 0) {
+        MP_INFO(x, y).int_2 = MP_INFO(x, y).int_1;
+        MP_INFO(x, y).int_1 = 0;
+        MP_INFO(x, y).int_5 = MP_INFO(x, y).int_4;
+        MP_INFO(x, y).int_4 = 0;
+        b1 = &amp;(MP_INFO(x + 1, y).int_3);
+        s1 = &amp;(MP_INFO(x + 2, y).int_3);
+        b2 = &amp;(MP_INFO(x, y + 1).int_3);
+        s2 = &amp;(MP_INFO(x, y + 2).int_3);
+        /* GCS FIX -- This obfuscation is unnecessary. */
+        for (i = 0; i &lt; 5; i++) {
+            *(b2++) = *b1;
+            *(s2++) = *s1;
+            *(b1++) = 0;
+            *(s1++) = 0;
+        }
     }
- /* upper gate next */
-  bool deal = false;
-  for( a = 0; a &lt; 3 ; a++ ) //try north
-    if ( x &gt;= 0 &amp;&amp; y&gt;=0 &amp;&amp; (MP_INFO( x+a, y-1 ).flags
-              &amp; FLAG_IS_TRANSPORT) != 0){
-        trade_connection( x, y, x+a, y-1, &amp;ic, &amp;et );
-        deal = false;
-        break;
+    if (et &gt; 0) {
+        sust_port_flag = 0;
+        tech_level++;
     }
-  if( !deal )
-  for( a = 0; a &lt; 3 ; a++ ) //try south
-    if ( x &gt;= 0 &amp;&amp; y&gt;=0 &amp;&amp; (MP_INFO( x+a, y+4 ).flags
-              &amp; FLAG_IS_TRANSPORT) != 0){
-        trade_connection( x, y, x+a, y+4, &amp;ic, &amp;et );
-        break;
+    if (ic &gt; 0) {
+        sust_port_flag = 0;
+        tech_level++;
     }
-  
-  MP_INFO(x,y).int_1 += et;
-  MP_INFO(x,y).int_4 += ic;
-  if (total_time % 100 == 0)
-    {
-      MP_INFO(x,y).int_2 = MP_INFO(x,y).int_1;
-      MP_INFO(x,y).int_1 = 0;
-      MP_INFO(x,y).int_5 = MP_INFO(x,y).int_4;
-      MP_INFO(x,y).int_4 = 0;
-      b1 = &amp;(MP_INFO(x + 1,y).int_3);
-      s1 = &amp;(MP_INFO(x + 2,y).int_3);
-      b2 = &amp;(MP_INFO(x,y + 1).int_3);
-      s2 = &amp;(MP_INFO(x,y + 2).int_3);
-      /* GCS FIX -- This obfuscation is unnecessary. */
-      for (i = 0; i &lt; 5; i++)
-	{
-	  *(b2++) = *b1;
-	  *(s2++) = *s1;
-	  *(b1++) = 0;
-	  *(s1++) = 0;
-	}
-    }
-  if (et &gt; 0)
-    {
-      sust_port_flag = 0;
-      tech_level++;
-    }
-  if (ic &gt; 0)
-    {
-      sust_port_flag = 0;
-      tech_level++;
-    }
-  et += MP_INFO(x,y).int_3;	/* int_3 holds the 'pence' */
+    et += MP_INFO(x, y).int_3;  /* int_3 holds the 'pence' */
 
-  export_tax += et / 100;
-  MP_INFO(x,y).int_3 = et % 100;
-  import_cost += ic;
+    export_tax += et / 100;
+    MP_INFO(x, y).int_3 = et % 100;
+    import_cost += ic;
 }
 
-void
-mps_port (int x, int y)
+void mps_port(int x, int y)
 {
     int i = 0;
     char buy[12], sell[12];
 
-    mps_store_title(i++,_(&quot;Port&quot;));
+    mps_store_title(i++, _(&quot;Port&quot;));
     i++;
 
-    num_to_ansi(buy, sizeof(buy), MP_INFO(x,y+1).int_3 / 100);
-    num_to_ansi(sell, sizeof(sell), MP_INFO(x,y+2).int_3 / 100);
-    mps_store_sss(i++,_(&quot;Food&quot;),buy,sell);
+    num_to_ansi(buy, sizeof(buy), MP_INFO(x, y + 1).int_3 / 100);
+    num_to_ansi(sell, sizeof(sell), MP_INFO(x, y + 2).int_3 / 100);
+    mps_store_sss(i++, _(&quot;Food&quot;), buy, sell);
 
-    num_to_ansi(buy, sizeof(buy), MP_INFO(x,y+1).int_4 / 100);
-    num_to_ansi(sell, sizeof(sell), MP_INFO(x,y+2).int_4 / 100);
-    mps_store_sss(i++,_(&quot;Coal&quot;),buy,sell);
+    num_to_ansi(buy, sizeof(buy), MP_INFO(x, y + 1).int_4 / 100);
+    num_to_ansi(sell, sizeof(sell), MP_INFO(x, y + 2).int_4 / 100);
+    mps_store_sss(i++, _(&quot;Coal&quot;), buy, sell);
 
-    num_to_ansi(buy, sizeof(buy), MP_INFO(x,y+1).int_5 / 100);
-    num_to_ansi(sell, sizeof(sell), MP_INFO(x,y+2).int_5 / 100);
-    mps_store_sss(i++,_(&quot;Ore&quot;),buy,sell);
+    num_to_ansi(buy, sizeof(buy), MP_INFO(x, y + 1).int_5 / 100);
+    num_to_ansi(sell, sizeof(sell), MP_INFO(x, y + 2).int_5 / 100);
+    mps_store_sss(i++, _(&quot;Ore&quot;), buy, sell);
 
-    num_to_ansi(buy, sizeof(buy), MP_INFO(x,y+1).int_6 / 100);
-    num_to_ansi(sell, sizeof(sell), MP_INFO(x,y+2).int_6 / 100);
-    mps_store_sss(i++,_(&quot;Goods&quot;),buy,sell);
+    num_to_ansi(buy, sizeof(buy), MP_INFO(x, y + 1).int_6 / 100);
+    num_to_ansi(sell, sizeof(sell), MP_INFO(x, y + 2).int_6 / 100);
+    mps_store_sss(i++, _(&quot;Goods&quot;), buy, sell);
 
-    num_to_ansi(buy, sizeof(buy), MP_INFO(x,y+1).int_7 / 100);
-    num_to_ansi(sell, sizeof(sell), MP_INFO(x,y+2).int_7 / 100);
-    mps_store_sss(i++,_(&quot;Steel&quot;),buy,sell);
+    num_to_ansi(buy, sizeof(buy), MP_INFO(x, y + 1).int_7 / 100);
+    num_to_ansi(sell, sizeof(sell), MP_INFO(x, y + 2).int_7 / 100);
+    mps_store_sss(i++, _(&quot;Steel&quot;), buy, sell);
 
-    num_to_ansi(buy, sizeof(buy), MP_INFO(x,y).int_5 / 100);
-    num_to_ansi(sell, sizeof(sell), MP_INFO(x,y).int_2 / 100);
-    mps_store_sss(i++,_(&quot;Total&quot;),buy,sell);
+    num_to_ansi(buy, sizeof(buy), MP_INFO(x, y).int_5 / 100);
+    num_to_ansi(sell, sizeof(sell), MP_INFO(x, y).int_2 / 100);
+    mps_store_sss(i++, _(&quot;Total&quot;), buy, sell);
 
 }
-
-

Modified: trunk/src/lincity/modules/port.h
===================================================================
--- trunk/src/lincity/modules/port.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/port.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -9,6 +9,6 @@
 #define __port_h__
 
 void do_port(int x, int y);
-void mps_port (int x, int y);
+void mps_port(int x, int y);
 
 #endif /* __port_h__ */

Modified: trunk/src/lincity/modules/pottery.cpp
===================================================================
--- trunk/src/lincity/modules/pottery.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/pottery.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -8,125 +8,106 @@
 #include &quot;modules.h&quot;
 #include &quot;pottery.h&quot;
 
-
-void
-do_pottery (int x, int y)
+void do_pottery(int x, int y)
 {
-  /*
-    // int_1 contains the goods at the pottery
-    // int_2 contains the ore at the pottery
-    // int_3 contains the coal at the pottery
-    // int_4 is the animation trigger time
-    // int_5 is the % made so far this month or the close time if negative
-    // int_6 is the % capacity last month
-    // int_7 contains the jobs stored at the pottery
-  */
-  if (MP_INFO(x,y).int_5 &lt; 0)
-    {
-      MP_INFO(x,y).int_5++;
-      return;
+    /*
+       // int_1 contains the goods at the pottery
+       // int_2 contains the ore at the pottery
+       // int_3 contains the coal at the pottery
+       // int_4 is the animation trigger time
+       // int_5 is the % made so far this month or the close time if negative
+       // int_6 is the % capacity last month
+       // int_7 contains the jobs stored at the pottery
+     */
+    if (MP_INFO(x, y).int_5 &lt; 0) {
+        MP_INFO(x, y).int_5++;
+        return;
     }
-  if (MP_INFO(x,y).int_1 &lt; (MAX_GOODS_AT_POTTERY - POTTERY_MADE_GOODS))
-    {
-      if (MP_INFO(x,y).int_2
-	  &lt; (MAX_ORE_AT_POTTERY - POTTERY_GET_ORE))
-	if (get_ore (x, y, POTTERY_GET_ORE) != 0)
-	  MP_INFO(x,y).int_2 += POTTERY_GET_ORE;
-      if (MP_INFO(x,y).int_3
-	  &lt; (MAX_COAL_AT_POTTERY - POTTERY_GET_COAL))
-	if (get_coal (x, y, POTTERY_GET_COAL) != 0)
-	  MP_INFO(x,y).int_3 += POTTERY_GET_COAL;
-      if (MP_INFO(x,y).int_7
-	  &lt; (MAX_JOBS_AT_POTTERY - POTTERY_GET_JOBS))
-	if (get_jobs (x, y, POTTERY_GET_JOBS) != 0)
-	  MP_INFO(x,y).int_7 += POTTERY_GET_JOBS;
+    if (MP_INFO(x, y).int_1 &lt; (MAX_GOODS_AT_POTTERY - POTTERY_MADE_GOODS)) {
+        if (MP_INFO(x, y).int_2 &lt; (MAX_ORE_AT_POTTERY - POTTERY_GET_ORE))
+            if (get_ore(x, y, POTTERY_GET_ORE) != 0)
+                MP_INFO(x, y).int_2 += POTTERY_GET_ORE;
+        if (MP_INFO(x, y).int_3 &lt; (MAX_COAL_AT_POTTERY - POTTERY_GET_COAL))
+            if (get_coal(x, y, POTTERY_GET_COAL) != 0)
+                MP_INFO(x, y).int_3 += POTTERY_GET_COAL;
+        if (MP_INFO(x, y).int_7 &lt; (MAX_JOBS_AT_POTTERY - POTTERY_GET_JOBS))
+            if (get_jobs(x, y, POTTERY_GET_JOBS) != 0)
+                MP_INFO(x, y).int_7 += POTTERY_GET_JOBS;
 
-      if (MP_INFO(x,y).int_2 &gt; POTTERY_ORE_MAKE_GOODS
-	  &amp;&amp; MP_INFO(x,y).int_3 &gt; POTTERY_COAL_MAKE_GOODS
-	  &amp;&amp; MP_INFO(x,y).int_7 &gt; POTTERY_JOBS)
-	{
-	  MP_INFO(x,y).int_1 += POTTERY_MADE_GOODS;
-	  MP_INFO(x,y).int_2 -= POTTERY_ORE_MAKE_GOODS;
-	  MP_INFO(x,y).int_3 -= POTTERY_COAL_MAKE_GOODS;
-	  MP_INFO(x,y).int_7 -= POTTERY_JOBS;
-	  MP_INFO(x,y).int_5++;
-	}
-      else
-	{
-	  MP_TYPE(x,y) = CST_POTTERY_1;
-	  MP_INFO(x,y).int_6 = 0;
-	  MP_INFO(x,y).int_5 = -POTTERY_CLOSE_TIME;
-	  return;
-	}
+        if (MP_INFO(x, y).int_2 &gt; POTTERY_ORE_MAKE_GOODS
+            &amp;&amp; MP_INFO(x, y).int_3 &gt; POTTERY_COAL_MAKE_GOODS &amp;&amp; MP_INFO(x, y).int_7 &gt; POTTERY_JOBS) {
+            MP_INFO(x, y).int_1 += POTTERY_MADE_GOODS;
+            MP_INFO(x, y).int_2 -= POTTERY_ORE_MAKE_GOODS;
+            MP_INFO(x, y).int_3 -= POTTERY_COAL_MAKE_GOODS;
+            MP_INFO(x, y).int_7 -= POTTERY_JOBS;
+            MP_INFO(x, y).int_5++;
+        } else {
+            MP_TYPE(x, y) = CST_POTTERY_1;
+            MP_INFO(x, y).int_6 = 0;
+            MP_INFO(x, y).int_5 = -POTTERY_CLOSE_TIME;
+            return;
+        }
     }
-  if (MP_INFO(x,y).int_1 &gt; 0)
-    if (put_goods (x, y, MP_INFO(x,y).int_1) != 0)
-      MP_INFO(x,y).int_1 = 0;
+    if (MP_INFO(x, y).int_1 &gt; 0)
+        if (put_goods(x, y, MP_INFO(x, y).int_1) != 0)
+            MP_INFO(x, y).int_1 = 0;
 
-  if (total_time % 100 == 0)
-    {
-      MP_INFO(x,y).int_6 = MP_INFO(x,y).int_5;
-      MP_INFO(x,y).int_5 = 0;
+    if (total_time % 100 == 0) {
+        MP_INFO(x, y).int_6 = MP_INFO(x, y).int_5;
+        MP_INFO(x, y).int_5 = 0;
     }
-  if (real_time &gt;= MP_INFO(x,y).int_4 /* &amp;&amp; block_anim==0 */ )
-    {
-      MP_INFO(x,y).int_4 = real_time + POTTERY_ANIM_SPEED;
-      switch (MP_TYPE(x,y))
-	{
-	case (CST_POTTERY_0):
-	  MP_TYPE(x,y) = CST_POTTERY_1;
-	  break;
-	case (CST_POTTERY_1):
-	  MP_TYPE(x,y) = CST_POTTERY_2;
-	  break;
-	case (CST_POTTERY_2):
-	  MP_TYPE(x,y) = CST_POTTERY_3;
-	  break;
-	case (CST_POTTERY_3):
-	  MP_TYPE(x,y) = CST_POTTERY_4;
-	  break;
-	case (CST_POTTERY_4):
-	  MP_TYPE(x,y) = CST_POTTERY_5;
-	  break;
-	case (CST_POTTERY_5):
-	  MP_TYPE(x,y) = CST_POTTERY_6;
-	  break;
-	case (CST_POTTERY_6):
-	  MP_TYPE(x,y) = CST_POTTERY_7;
-	  break;
-	case (CST_POTTERY_7):
-	  MP_TYPE(x,y) = CST_POTTERY_8;
-	  break;
-	case (CST_POTTERY_8):
-	  MP_TYPE(x,y) = CST_POTTERY_9;
-	  break;
-	case (CST_POTTERY_9):
-	  MP_TYPE(x,y) = CST_POTTERY_10;
-	  break;
-	case (CST_POTTERY_10):
-	  MP_TYPE(x,y) = CST_POTTERY_1;
-	  MP_POL(x,y)++;
-	  break;
-	}
+    if (real_time &gt;= MP_INFO(x, y).int_4 /* &amp;&amp; block_anim==0 */ ) {
+        MP_INFO(x, y).int_4 = real_time + POTTERY_ANIM_SPEED;
+        switch (MP_TYPE(x, y)) {
+        case (CST_POTTERY_0):
+            MP_TYPE(x, y) = CST_POTTERY_1;
+            break;
+        case (CST_POTTERY_1):
+            MP_TYPE(x, y) = CST_POTTERY_2;
+            break;
+        case (CST_POTTERY_2):
+            MP_TYPE(x, y) = CST_POTTERY_3;
+            break;
+        case (CST_POTTERY_3):
+            MP_TYPE(x, y) = CST_POTTERY_4;
+            break;
+        case (CST_POTTERY_4):
+            MP_TYPE(x, y) = CST_POTTERY_5;
+            break;
+        case (CST_POTTERY_5):
+            MP_TYPE(x, y) = CST_POTTERY_6;
+            break;
+        case (CST_POTTERY_6):
+            MP_TYPE(x, y) = CST_POTTERY_7;
+            break;
+        case (CST_POTTERY_7):
+            MP_TYPE(x, y) = CST_POTTERY_8;
+            break;
+        case (CST_POTTERY_8):
+            MP_TYPE(x, y) = CST_POTTERY_9;
+            break;
+        case (CST_POTTERY_9):
+            MP_TYPE(x, y) = CST_POTTERY_10;
+            break;
+        case (CST_POTTERY_10):
+            MP_TYPE(x, y) = CST_POTTERY_1;
+            MP_POL(x, y)++;
+            break;
+        }
     }
 }
 
-void
-mps_pottery (int x, int y)
+void mps_pottery(int x, int y)
 {
-  int i = 0;
+    int i = 0;
 
-  mps_store_title(i++,_(&quot;Pottery&quot;));
-  i++;
-  mps_store_sfp(i++,_(&quot;Capacity&quot;), MP_INFO(x,y).int_6 * 1.0);
-  i++;
-  mps_store_title(i++,_(&quot;Inventory&quot;));
-  mps_store_sfp(i++,_(&quot;Jobs&quot;),
-		MP_INFO(x,y).int_7 * 100.0 / MAX_JOBS_AT_POTTERY);
-  mps_store_sfp(i++,_(&quot;Goods&quot;),
-		MP_INFO(x,y).int_1 * 100.0 / MAX_GOODS_AT_POTTERY);
-  mps_store_sfp(i++,_(&quot;Ore&quot;),
-		MP_INFO(x,y).int_2 * 100.0 / MAX_ORE_AT_POTTERY);
-  mps_store_sfp(i++,_(&quot;Coal&quot;),
-		MP_INFO(x,y).int_3 * 100.0 / MAX_COAL_AT_POTTERY);
+    mps_store_title(i++, _(&quot;Pottery&quot;));
+    i++;
+    mps_store_sfp(i++, _(&quot;Capacity&quot;), MP_INFO(x, y).int_6 * 1.0);
+    i++;
+    mps_store_title(i++, _(&quot;Inventory&quot;));
+    mps_store_sfp(i++, _(&quot;Jobs&quot;), MP_INFO(x, y).int_7 * 100.0 / MAX_JOBS_AT_POTTERY);
+    mps_store_sfp(i++, _(&quot;Goods&quot;), MP_INFO(x, y).int_1 * 100.0 / MAX_GOODS_AT_POTTERY);
+    mps_store_sfp(i++, _(&quot;Ore&quot;), MP_INFO(x, y).int_2 * 100.0 / MAX_ORE_AT_POTTERY);
+    mps_store_sfp(i++, _(&quot;Coal&quot;), MP_INFO(x, y).int_3 * 100.0 / MAX_COAL_AT_POTTERY);
 }

Modified: trunk/src/lincity/modules/pottery.h
===================================================================
--- trunk/src/lincity/modules/pottery.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/pottery.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -9,6 +9,6 @@
 #define __pottery_h__
 
 void do_pottery(int x, int y);
-void mps_pottery (int x, int y);
+void mps_pottery(int x, int y);
 
 #endif /* __pottery_h__ */

Modified: trunk/src/lincity/modules/power_line.cpp
===================================================================
--- trunk/src/lincity/modules/power_line.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/power_line.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -9,46 +9,42 @@
 #include &quot;../power.h&quot;
 #include &quot;power_line.h&quot;
 
-
 /*** Power Lines ***/
 /*
   int_5 is animation schedule
   int_6 is the grid it is on
   int_7 is a grid timestamp
 */
-void
-do_power_line (int x, int y)
+void do_power_line(int x, int y)
 {
-    if (grid[MP_INFO(x,y).int_6]-&gt;powered == -1)
-	return;
+    if (grid[MP_INFO(x, y).int_6]-&gt;powered == -1)
+        return;
 
-    switch(MP_INFO(x,y).int_5) 
-    {
-    case 0: 
-	MP_INFO(x,y).int_5 = POWER_MODULUS;
-	break;
+    switch (MP_INFO(x, y).int_5) {
+    case 0:
+        MP_INFO(x, y).int_5 = POWER_MODULUS;
+        break;
     case 1:
-	if (!(MP_TYPE(x,y) &lt;= 11 &amp;&amp; MP_TYPE(x,y) &gt;= 1))
-	    break;
-	MP_TYPE(x,y) += 11;
-	break;
+        if (!(MP_TYPE(x, y) &lt;= 11 &amp;&amp; MP_TYPE(x, y) &gt;= 1))
+            break;
+        MP_TYPE(x, y) += 11;
+        break;
     case 2:
-	if (!(MP_TYPE(x,y) &gt;= 11 &amp;&amp; MP_TYPE(x,y) &lt;= 22))
-	    break;
-	MP_TYPE(x,y) -= 11;
-	break;
+        if (!(MP_TYPE(x, y) &gt;= 11 &amp;&amp; MP_TYPE(x, y) &lt;= 22))
+            break;
+        MP_TYPE(x, y) -= 11;
+        break;
     }
 
-    MP_INFO(x,y).int_5--;
+    MP_INFO(x, y).int_5--;
 }
 
-void
-mps_power_line (int x, int y)
+void mps_power_line(int x, int y)
 {
-  int i = 0;
+    int i = 0;
 
-  mps_store_title(i++,_(&quot;Power Line&quot;));
-  i++;
+    mps_store_title(i++, _(&quot;Power Line&quot;));
+    i++;
 
-  mps_store_sd(i++,_(&quot;Grid ID&quot;),MP_INFO(x,y).int_6);
+    mps_store_sd(i++, _(&quot;Grid ID&quot;), MP_INFO(x, y).int_6);
 }

Modified: trunk/src/lincity/modules/power_line.h
===================================================================
--- trunk/src/lincity/modules/power_line.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/power_line.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -9,6 +9,6 @@
 #define __power_line_h__
 
 void do_power_line(int x, int y);
-void mps_power_line (int x, int y);
+void mps_power_line(int x, int y);
 
 #endif /* __power_line_h__ */

Modified: trunk/src/lincity/modules/rail.cpp
===================================================================
--- trunk/src/lincity/modules/rail.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/rail.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -21,48 +21,38 @@
    int_7 contains the amount of waste
   --------------------------------------------------------------------- */
 
-void
-do_rail (int x, int y)
+void do_rail(int x, int y)
 {
     static int wb_count = 0;
-    int *pol = &amp;MP_POL(x,y);
-    Map_Point_Info *minfo = &amp;MP_INFO(x,y);
+    int *pol = &amp;MP_POL(x, y);
+    Map_Point_Info *minfo = &amp;MP_INFO(x, y);
     transport_cost += 3;
     if (total_time % DAYS_PER_RAIL_POLLUTION == 0)
-	*pol += RAIL_POLLUTION;
+        *pol += RAIL_POLLUTION;
     if ((total_time &amp; RAIL_GOODS_USED_MASK) == 0 &amp;&amp; minfo-&gt;int_4 &gt; 0) {
-	--minfo-&gt;int_4;
-	++minfo-&gt;int_7;
+        --minfo-&gt;int_4;
+        ++minfo-&gt;int_7;
     }
     if ((total_time &amp; RAIL_STEEL_USED_MASK) == 0 &amp;&amp; minfo-&gt;int_6 &gt; 0) {
-	--minfo-&gt;int_6;
-	++minfo-&gt;int_7;
+        --minfo-&gt;int_6;
+        ++minfo-&gt;int_7;
     }
-    general_transport (minfo, pol, MAX_WASTE_ON_RAIL, &amp;wb_count);
+    general_transport(minfo, pol, MAX_WASTE_ON_RAIL, &amp;wb_count);
 }
 
-
-void
-mps_rail (int x, int y)
+void mps_rail(int x, int y)
 {
-  int i = 0;
+    int i = 0;
 
-  mps_store_title(i++,_(&quot;Rail&quot;));
-  i++;
+    mps_store_title(i++, _(&quot;Rail&quot;));
+    i++;
 
-  mps_store_sfp(i++,_(&quot;Food&quot;), 
-		MP_INFO(x,y).int_1 * 100.0 / MAX_FOOD_ON_RAIL);
-  mps_store_sfp(i++,_(&quot;Jobs&quot;), 
-		MP_INFO(x,y).int_2 * 100.0 / MAX_JOBS_ON_RAIL);
-  mps_store_sfp(i++,_(&quot;Coal&quot;), 
-		MP_INFO(x,y).int_3 * 100.0 / MAX_COAL_ON_RAIL);
-  mps_store_sfp(i++,_(&quot;Goods&quot;), 
-		MP_INFO(x,y).int_4 * 100.0 / MAX_GOODS_ON_RAIL);
-  mps_store_sfp(i++,_(&quot;Ore&quot;), 
-		MP_INFO(x,y).int_5 * 100.0 / MAX_ORE_ON_RAIL);
-  mps_store_sfp(i++,_(&quot;Steel&quot;), 
-		MP_INFO(x,y).int_6 * 100.0 / MAX_STEEL_ON_RAIL);
-  mps_store_sfp(i++,_(&quot;Waste&quot;), 
-		MP_INFO(x,y).int_7 * 100.0 / MAX_WASTE_ON_RAIL);
+    mps_store_sfp(i++, _(&quot;Food&quot;), MP_INFO(x, y).int_1 * 100.0 / MAX_FOOD_ON_RAIL);
+    mps_store_sfp(i++, _(&quot;Jobs&quot;), MP_INFO(x, y).int_2 * 100.0 / MAX_JOBS_ON_RAIL);
+    mps_store_sfp(i++, _(&quot;Coal&quot;), MP_INFO(x, y).int_3 * 100.0 / MAX_COAL_ON_RAIL);
+    mps_store_sfp(i++, _(&quot;Goods&quot;), MP_INFO(x, y).int_4 * 100.0 / MAX_GOODS_ON_RAIL);
+    mps_store_sfp(i++, _(&quot;Ore&quot;), MP_INFO(x, y).int_5 * 100.0 / MAX_ORE_ON_RAIL);
+    mps_store_sfp(i++, _(&quot;Steel&quot;), MP_INFO(x, y).int_6 * 100.0 / MAX_STEEL_ON_RAIL);
+    mps_store_sfp(i++, _(&quot;Waste&quot;), MP_INFO(x, y).int_7 * 100.0 / MAX_WASTE_ON_RAIL);
 
 }

Modified: trunk/src/lincity/modules/recycle.cpp
===================================================================
--- trunk/src/lincity/modules/recycle.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/recycle.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -8,180 +8,145 @@
 #include &quot;modules.h&quot;
 #include &quot;recycle.h&quot;
 
-void
-do_recycle (int x, int y)
+void do_recycle(int x, int y)
 {
-  int i;
-  /*
-     // int_1 is the ore made and waiting to go out
-     // int_2 is the used goods in store
-     // int_3 is the used steel in store       NOT USED at this time
-     // int_4 is the tech level when built
-     // int_5 is the recycling done so far this month
-     // int_6 is the percent of max recycling last month
-     // int_7 is the waste in store
-     // cost
-   */
-  recycle_cost += RECYCLE_RUNNING_COST;
+    int i;
+    /*
+       // int_1 is the ore made and waiting to go out
+       // int_2 is the used goods in store
+       // int_3 is the used steel in store       NOT USED at this time
+       // int_4 is the tech level when built
+       // int_5 is the recycling done so far this month
+       // int_6 is the percent of max recycling last month
+       // int_7 is the waste in store
+       // cost
+     */
+    recycle_cost += RECYCLE_RUNNING_COST;
 
-  /*
-     // let these go through, even if we're full of waste. It's a waste of time
-     // checking.
-   */
-  if (x &gt; 0 &amp;&amp; (MP_INFO(x - 1,y).flags &amp; FLAG_IS_TRANSPORT) != 0)
-    {
-      i = MP_INFO(x - 1,y).int_7;
-      if (i &gt; MAX_WASTE_AT_RECYCLE - MP_INFO(x,y).int_2)
-	i = MAX_WASTE_AT_RECYCLE - MP_INFO(x,y).int_2;
-      MP_INFO(x,y).int_2 += i;
-      MP_INFO(x - 1,y).int_7 -= i;
+    /*
+       // let these go through, even if we're full of waste. It's a waste of time
+       // checking.
+     */
+    if (x &gt; 0 &amp;&amp; (MP_INFO(x - 1, y).flags &amp; FLAG_IS_TRANSPORT) != 0) {
+        i = MP_INFO(x - 1, y).int_7;
+        if (i &gt; MAX_WASTE_AT_RECYCLE - MP_INFO(x, y).int_2)
+            i = MAX_WASTE_AT_RECYCLE - MP_INFO(x, y).int_2;
+        MP_INFO(x, y).int_2 += i;
+        MP_INFO(x - 1, y).int_7 -= i;
     }
-  if (y &gt; 0 &amp;&amp; (MP_INFO(x,y - 1).flags &amp; FLAG_IS_TRANSPORT) != 0)
-    {
-      i = MP_INFO(x,y - 1).int_7;
-      if (i &gt; MAX_WASTE_AT_RECYCLE - MP_INFO(x,y).int_2)
-	i = MAX_WASTE_AT_RECYCLE - MP_INFO(x,y).int_2;
-      MP_INFO(x,y).int_2 += i;
-      MP_INFO(x,y - 1).int_7 -= i;
+    if (y &gt; 0 &amp;&amp; (MP_INFO(x, y - 1).flags &amp; FLAG_IS_TRANSPORT) != 0) {
+        i = MP_INFO(x, y - 1).int_7;
+        if (i &gt; MAX_WASTE_AT_RECYCLE - MP_INFO(x, y).int_2)
+            i = MAX_WASTE_AT_RECYCLE - MP_INFO(x, y).int_2;
+        MP_INFO(x, y).int_2 += i;
+        MP_INFO(x, y - 1).int_7 -= i;
     }
 
-  /* get some startup power if not powered yet */
-  if ((MP_INFO(x,y).flags &amp; FLAG_POWERED) == 0)
-    if (get_power (x, y, GOODS_RECYCLED, 1) != 0)
-      MP_INFO(x,y).flags |= FLAG_POWERED;
+    /* get some startup power if not powered yet */
+    if ((MP_INFO(x, y).flags &amp; FLAG_POWERED) == 0)
+        if (get_power(x, y, GOODS_RECYCLED, 1) != 0)
+            MP_INFO(x, y).flags |= FLAG_POWERED;
 
-  /* no steel recycling yet - no point, it's only used to make goods.
-     // recycle to ore.
-   */
-  if (MP_INFO(x,y).int_1 &lt; MAX_ORE_AT_RECYCLE
-      &amp;&amp; MP_INFO(x,y).int_2 &gt; GOODS_RECYCLED
-      &amp;&amp; (MP_INFO(x,y).flags &amp; FLAG_POWERED) != 0)
-    if (get_jobs (x, y, RECYCLE_GOODS_JOBS) != 0)
-      {
-	if (get_power (x, y, GOODS_RECYCLED / 2, 1) == 0)
-	  MP_INFO(x,y).flags
-	    &amp;= (0xffffffff - FLAG_POWERED);
-	else
-	  MP_INFO(x,y).flags |= FLAG_POWERED;
-	MP_INFO(x,y).int_2 -= GOODS_RECYCLED;
-	i = (GOODS_RECYCLED * (10 + ((50 * MP_INFO(x,y).int_4)
-				     / MAX_TECH_LEVEL))) / 100;
-	if (i &gt; (GOODS_RECYCLED * 8) / 10)
-	  i = (GOODS_RECYCLED * 8) / 10;
-	MP_INFO(x,y).int_1 += i;
-	ore_made += i;
-	MP_INFO(x,y).int_5++;
-      }
-  if (total_time % 100 == 0)
-    {
-      MP_INFO(x,y).int_6 = MP_INFO(x,y).int_5;
-      MP_INFO(x,y).int_5 = 0;
+    /* no steel recycling yet - no point, it's only used to make goods.
+       // recycle to ore.
+     */
+    if (MP_INFO(x, y).int_1 &lt; MAX_ORE_AT_RECYCLE
+        &amp;&amp; MP_INFO(x, y).int_2 &gt; GOODS_RECYCLED &amp;&amp; (MP_INFO(x, y).flags &amp; FLAG_POWERED) != 0)
+        if (get_jobs(x, y, RECYCLE_GOODS_JOBS) != 0) {
+            if (get_power(x, y, GOODS_RECYCLED / 2, 1) == 0)
+                MP_INFO(x, y).flags &amp;= (0xffffffff - FLAG_POWERED);
+            else
+                MP_INFO(x, y).flags |= FLAG_POWERED;
+            MP_INFO(x, y).int_2 -= GOODS_RECYCLED;
+            i = (GOODS_RECYCLED * (10 + ((50 * MP_INFO(x, y).int_4)
+                                         / MAX_TECH_LEVEL))) / 100;
+            if (i &gt; (GOODS_RECYCLED * 8) / 10)
+                i = (GOODS_RECYCLED * 8) / 10;
+            MP_INFO(x, y).int_1 += i;
+            ore_made += i;
+            MP_INFO(x, y).int_5++;
+        }
+    if (total_time % 100 == 0) {
+        MP_INFO(x, y).int_6 = MP_INFO(x, y).int_5;
+        MP_INFO(x, y).int_5 = 0;
     }
-  /* now bung the ore out */
-  /* put it on the railway */
-  if (x &gt; 0 &amp;&amp; MP_GROUP(x-1,y) == GROUP_RAIL
-      &amp;&amp; MP_INFO(x - 1,y).int_5 &lt; MAX_ORE_ON_RAIL
-      &amp;&amp; MP_INFO(x,y).int_1 &gt;= (MAX_ORE_ON_RAIL
-				  - MP_INFO(x - 1,y).int_5))
-    {
-      if (get_jobs (x, y, JOBS_LOAD_ORE) != 0)
-	{
-	  MP_INFO(x,y).int_1
-	    -= (MAX_ORE_ON_RAIL - MP_INFO(x - 1,y).int_5);
-	  MP_INFO(x - 1,y).int_5 = MAX_ORE_ON_RAIL;
-	}
+    /* now bung the ore out */
+    /* put it on the railway */
+    if (x &gt; 0 &amp;&amp; MP_GROUP(x - 1, y) == GROUP_RAIL
+        &amp;&amp; MP_INFO(x - 1, y).int_5 &lt; MAX_ORE_ON_RAIL
+        &amp;&amp; MP_INFO(x, y).int_1 &gt;= (MAX_ORE_ON_RAIL - MP_INFO(x - 1, y).int_5)) {
+        if (get_jobs(x, y, JOBS_LOAD_ORE) != 0) {
+            MP_INFO(x, y).int_1 -= (MAX_ORE_ON_RAIL - MP_INFO(x - 1, y).int_5);
+            MP_INFO(x - 1, y).int_5 = MAX_ORE_ON_RAIL;
+        }
     }
-  if (y &gt; 0 &amp;&amp; MP_GROUP(x,y-1) == GROUP_RAIL
-      &amp;&amp; MP_INFO(x,y - 1).int_5 &lt; MAX_ORE_ON_RAIL
-      &amp;&amp; MP_INFO(x,y).int_1 &gt;= (MAX_ORE_ON_RAIL
-				  - MP_INFO(x,y - 1).int_5))
-    {
-      if (get_jobs (x, y, JOBS_LOAD_ORE) != 0)
-	{
-	  MP_INFO(x,y).int_1
-	    -= (MAX_ORE_ON_RAIL - MP_INFO(x,y - 1).int_5);
-	  MP_INFO(x,y - 1).int_5 = MAX_ORE_ON_RAIL;
-	}
+    if (y &gt; 0 &amp;&amp; MP_GROUP(x, y - 1) == GROUP_RAIL
+        &amp;&amp; MP_INFO(x, y - 1).int_5 &lt; MAX_ORE_ON_RAIL
+        &amp;&amp; MP_INFO(x, y).int_1 &gt;= (MAX_ORE_ON_RAIL - MP_INFO(x, y - 1).int_5)) {
+        if (get_jobs(x, y, JOBS_LOAD_ORE) != 0) {
+            MP_INFO(x, y).int_1 -= (MAX_ORE_ON_RAIL - MP_INFO(x, y - 1).int_5);
+            MP_INFO(x, y - 1).int_5 = MAX_ORE_ON_RAIL;
+        }
     }
-  /* put it on the road */
-  if (x &gt; 0 &amp;&amp; MP_GROUP(x-1,y) == GROUP_ROAD
-      &amp;&amp; MP_INFO(x - 1,y).int_5 &lt; MAX_ORE_ON_ROAD
-      &amp;&amp; MP_INFO(x,y).int_1 &gt;= (MAX_ORE_ON_ROAD
-				  - MP_INFO(x - 1,y).int_5))
-    {
-      if (get_jobs (x, y, JOBS_LOAD_ORE) != 0)
-	{
-	  MP_INFO(x,y).int_1
-	    -= (MAX_ORE_ON_ROAD - MP_INFO(x - 1,y).int_5);
-	  MP_INFO(x - 1,y).int_5 = MAX_ORE_ON_ROAD;
-	}
+    /* put it on the road */
+    if (x &gt; 0 &amp;&amp; MP_GROUP(x - 1, y) == GROUP_ROAD
+        &amp;&amp; MP_INFO(x - 1, y).int_5 &lt; MAX_ORE_ON_ROAD
+        &amp;&amp; MP_INFO(x, y).int_1 &gt;= (MAX_ORE_ON_ROAD - MP_INFO(x - 1, y).int_5)) {
+        if (get_jobs(x, y, JOBS_LOAD_ORE) != 0) {
+            MP_INFO(x, y).int_1 -= (MAX_ORE_ON_ROAD - MP_INFO(x - 1, y).int_5);
+            MP_INFO(x - 1, y).int_5 = MAX_ORE_ON_ROAD;
+        }
     }
-  if (y &gt; 0 &amp;&amp; MP_GROUP(x,y-1) == GROUP_ROAD
-      &amp;&amp; MP_INFO(x,y - 1).int_5 &lt; MAX_ORE_ON_ROAD
-      &amp;&amp; MP_INFO(x,y).int_1 &gt;= (MAX_ORE_ON_ROAD
-				  - MP_INFO(x,y - 1).int_5))
-    {
-      if (get_jobs (x, y, JOBS_LOAD_ORE) != 0)
-	{
-	  MP_INFO(x,y).int_1
-	    -= (MAX_ORE_ON_ROAD - MP_INFO(x,y - 1).int_5);
-	  MP_INFO(x,y - 1).int_5 = MAX_ORE_ON_ROAD;
-	}
+    if (y &gt; 0 &amp;&amp; MP_GROUP(x, y - 1) == GROUP_ROAD
+        &amp;&amp; MP_INFO(x, y - 1).int_5 &lt; MAX_ORE_ON_ROAD
+        &amp;&amp; MP_INFO(x, y).int_1 &gt;= (MAX_ORE_ON_ROAD - MP_INFO(x, y - 1).int_5)) {
+        if (get_jobs(x, y, JOBS_LOAD_ORE) != 0) {
+            MP_INFO(x, y).int_1 -= (MAX_ORE_ON_ROAD - MP_INFO(x, y - 1).int_5);
+            MP_INFO(x, y - 1).int_5 = MAX_ORE_ON_ROAD;
+        }
     }
-  /* put it on the tracks */
-  if (x &gt; 0 &amp;&amp; MP_GROUP(x-1,y) == GROUP_TRACK
-      &amp;&amp; MP_INFO(x - 1,y).int_5 &lt; MAX_ORE_ON_TRACK
-      &amp;&amp; MP_INFO(x,y).int_1 &gt;= (MAX_ORE_ON_TRACK
-				  - MP_INFO(x - 1,y).int_5))
-    {
-      if (get_jobs (x, y, JOBS_LOAD_ORE) != 0)
-	{
-	  MP_INFO(x,y).int_1
-	    -= (MAX_ORE_ON_TRACK - MP_INFO(x - 1,y).int_5);
-	  MP_INFO(x - 1,y).int_5 = MAX_ORE_ON_TRACK;
-	}
+    /* put it on the tracks */
+    if (x &gt; 0 &amp;&amp; MP_GROUP(x - 1, y) == GROUP_TRACK
+        &amp;&amp; MP_INFO(x - 1, y).int_5 &lt; MAX_ORE_ON_TRACK
+        &amp;&amp; MP_INFO(x, y).int_1 &gt;= (MAX_ORE_ON_TRACK - MP_INFO(x - 1, y).int_5)) {
+        if (get_jobs(x, y, JOBS_LOAD_ORE) != 0) {
+            MP_INFO(x, y).int_1 -= (MAX_ORE_ON_TRACK - MP_INFO(x - 1, y).int_5);
+            MP_INFO(x - 1, y).int_5 = MAX_ORE_ON_TRACK;
+        }
     }
-  if (y &gt; 0 &amp;&amp; MP_GROUP(x,y-1) == GROUP_TRACK
-      &amp;&amp; MP_INFO(x,y - 1).int_5 &lt; MAX_ORE_ON_TRACK
-      &amp;&amp; MP_INFO(x,y).int_1 &gt;= (MAX_ORE_ON_TRACK
-				  - MP_INFO(x,y - 1).int_5))
-    {
-      if (get_jobs (x, y, JOBS_LOAD_ORE) != 0)
-	{
-	  MP_INFO(x,y).int_1
-	    -= (MAX_ORE_ON_TRACK - MP_INFO(x,y - 1).int_5);
-	  MP_INFO(x,y - 1).int_5 = MAX_ORE_ON_TRACK;
-	}
+    if (y &gt; 0 &amp;&amp; MP_GROUP(x, y - 1) == GROUP_TRACK
+        &amp;&amp; MP_INFO(x, y - 1).int_5 &lt; MAX_ORE_ON_TRACK
+        &amp;&amp; MP_INFO(x, y).int_1 &gt;= (MAX_ORE_ON_TRACK - MP_INFO(x, y - 1).int_5)) {
+        if (get_jobs(x, y, JOBS_LOAD_ORE) != 0) {
+            MP_INFO(x, y).int_1 -= (MAX_ORE_ON_TRACK - MP_INFO(x, y - 1).int_5);
+            MP_INFO(x, y - 1).int_5 = MAX_ORE_ON_TRACK;
+        }
     }
-  /* if we've still got &gt;90% ore and waste in stock, burn some waste cleanly. 
-   */
-  if (MP_INFO(x,y).int_1 &gt; (MAX_ORE_AT_RECYCLE * 9 / 10)
-      &amp;&amp; MP_INFO(x,y).int_2 &gt; (MAX_WASTE_AT_RECYCLE * 9 / 10))
-    MP_INFO(x,y).int_2 -= BURN_WASTE_AT_RECYCLE;
+    /* if we've still got &gt;90% ore and waste in stock, burn some waste cleanly. 
+     */
+    if (MP_INFO(x, y).int_1 &gt; (MAX_ORE_AT_RECYCLE * 9 / 10)
+        &amp;&amp; MP_INFO(x, y).int_2 &gt; (MAX_WASTE_AT_RECYCLE * 9 / 10))
+        MP_INFO(x, y).int_2 -= BURN_WASTE_AT_RECYCLE;
 }
 
-void
-mps_recycle (int x, int y)
+void mps_recycle(int x, int y)
 {
-  int i = 0;
-  const char * p;
+    int i = 0;
+    const char *p;
 
-  mps_store_title(i++,_(&quot;Recycling&quot;));
-  mps_store_title(i++,_(&quot;Center&quot;));
-  i++;
+    mps_store_title(i++, _(&quot;Recycling&quot;));
+    mps_store_title(i++, _(&quot;Center&quot;));
+    i++;
 
-  mps_store_sfp(i++,_(&quot;Capacity&quot;), MP_INFO(x,y).int_6);
+    mps_store_sfp(i++, _(&quot;Capacity&quot;), MP_INFO(x, y).int_6);
 
-  p = ((MP_INFO(x,y).flags &amp; FLAG_POWERED) != 0) ? _(&quot;YES&quot;) : _(&quot;NO&quot;);
-  mps_store_ss(i++,_(&quot;Power&quot;),p);
+    p = ((MP_INFO(x, y).flags &amp; FLAG_POWERED) != 0) ? _(&quot;YES&quot;) : _(&quot;NO&quot;);
+    mps_store_ss(i++, _(&quot;Power&quot;), p);
 
-  mps_store_sfp(i++,_(&quot;Tech&quot;),
-		MP_INFO(x,y).int_4 * 100.0 / MAX_TECH_LEVEL);
-  i++;
-  mps_store_title(i++,_(&quot;Inventory&quot;));
-  mps_store_sfp(i++,_(&quot;Ore&quot;),
-		MP_INFO(x,y).int_1 * 100.0 / MAX_ORE_AT_RECYCLE);
-  mps_store_sfp(i++,_(&quot;Waste&quot;),
-		MP_INFO(x,y).int_2 * 100.0 / MAX_WASTE_AT_RECYCLE);
+    mps_store_sfp(i++, _(&quot;Tech&quot;), MP_INFO(x, y).int_4 * 100.0 / MAX_TECH_LEVEL);
+    i++;
+    mps_store_title(i++, _(&quot;Inventory&quot;));
+    mps_store_sfp(i++, _(&quot;Ore&quot;), MP_INFO(x, y).int_1 * 100.0 / MAX_ORE_AT_RECYCLE);
+    mps_store_sfp(i++, _(&quot;Waste&quot;), MP_INFO(x, y).int_2 * 100.0 / MAX_WASTE_AT_RECYCLE);
 
 }

Modified: trunk/src/lincity/modules/recycle.h
===================================================================
--- trunk/src/lincity/modules/recycle.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/recycle.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -9,6 +9,6 @@
 #define __recycle_h__
 
 void do_recycle(int x, int y);
-void mps_recycle (int x, int y);
+void mps_recycle(int x, int y);
 
 #endif /* __recycle_h__ */

Modified: trunk/src/lincity/modules/residence.cpp
===================================================================
--- trunk/src/lincity/modules/residence.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/residence.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -10,308 +10,273 @@
 #include &quot;waterwell.h&quot;
 #include &lt;stdlib.h&gt;
 
-void
-do_residence (int x, int y)
+void do_residence(int x, int y)
 {
     /*
-      // int_1 is a job swingometer to choose +/- JOB_SWING% of normal
-      // int_2 is the date of the last starve
-      // int 3 is the real time for the next icon update
-      // int_4 is the birth rate modifier.
-      // int_5 is the death rate modifier.
-      // int_6 unused
-      // int_7 unused Could be FLAG_HAD_POWER which is specific to residences, and will free 1 flag.
-      //                btw, FLAG_POWERED and FLAG_GOT_POWER means the same thing. =&gt; free 1 more flag.
-      //
-      */
-    int p;                           /* population */
-    int bad = 35, good = 30;         /* (un)desirability of living here */
+       // int_1 is a job swingometer to choose +/- JOB_SWING% of normal
+       // int_2 is the date of the last starve
+       // int 3 is the real time for the next icon update
+       // int_4 is the birth rate modifier.
+       // int_5 is the death rate modifier.
+       // int_6 unused
+       // int_7 unused Could be FLAG_HAD_POWER which is specific to residences, and will free 1 flag.
+       //                btw, FLAG_POWERED and FLAG_GOT_POWER means the same thing. =&gt; free 1 more flag.
+       //
+     */
+    int p;                      /* population */
+    int bad = 35, good = 30;    /* (un)desirability of living here */
     int r, po, swing;
-    int hc = 0;                      /* have health cover ? */
-    int brm = 0, drm = 0;            /* birth/death rate modifier */
+    int hc = 0;                 /* have health cover ? */
+    int brm = 0, drm = 0;       /* birth/death rate modifier */
     int cc = 0;
-    int birth_flag=0;
+    int birth_flag = 0;
 
-    p = MP_INFO(x,y).population;
-    if ((MP_INFO(x,y).flags &amp; FLAG_HEALTH_COVER) != 0)
-    {
-	brm += RESIDENCE_BRM_HEALTH;
-	good += 15;
-	hc = 1;
+    p = MP_INFO(x, y).population;
+    if ((MP_INFO(x, y).flags &amp; FLAG_HEALTH_COVER) != 0) {
+        brm += RESIDENCE_BRM_HEALTH;
+        good += 15;
+        hc = 1;
     }
-    if ((MP_INFO(x,y).flags &amp; FLAG_FIRE_COVER) == 0)
-	bad += 5;
+    if ((MP_INFO(x, y).flags &amp; FLAG_FIRE_COVER) == 0)
+        bad += 5;
     else
-	good += 15;
-    if ((MP_INFO(x,y).flags &amp; FLAG_CRICKET_COVER) != 0)
-    {
-	good += 20;
-	cc = CRICKET_JOB_SWING;
+        good += 15;
+    if ((MP_INFO(x, y).flags &amp; FLAG_CRICKET_COVER) != 0) {
+        good += 20;
+        cc = CRICKET_JOB_SWING;
     }
     /* normal deaths + pollution deaths */
-    po = ((MP_POL(x,y) / 50) + 1);
-    if ((RESIDENCE_BASE_DR - MP_INFO(x,y).int_5 - po) &gt; 1)
-	r = rand () % (RESIDENCE_BASE_DR - MP_INFO(x,y).int_5 - po);
+    po = ((MP_POL(x, y) / 50) + 1);
+    if ((RESIDENCE_BASE_DR - MP_INFO(x, y).int_5 - po) &gt; 1)
+        r = rand() % (RESIDENCE_BASE_DR - MP_INFO(x, y).int_5 - po);
     else
-	r = 2;
-    if (p &gt; 0 &amp;&amp; (r &lt; po))
-    {
-	if (r == 0 || hc == 0)
-	    p--;
-	else if (hc != 0 &amp;&amp; po &gt; 10 &amp;&amp; rand () % 4 == 0)
-	{
-	    p--;
-	    unnat_deaths++;
-	    total_pollution_deaths++;
-	    pollution_deaths_history += 1.0;
-	    bad += 100;
-	}
-	if (r &gt; 0 &amp;&amp; hc == 0)
-	{
-	    unnat_deaths++;
-	    total_pollution_deaths++;
-	    pollution_deaths_history += 1.0;
-	    bad += 100;
-	}
+        r = 2;
+    if (p &gt; 0 &amp;&amp; (r &lt; po)) {
+        if (r == 0 || hc == 0)
+            p--;
+        else if (hc != 0 &amp;&amp; po &gt; 10 &amp;&amp; rand() % 4 == 0) {
+            p--;
+            unnat_deaths++;
+            total_pollution_deaths++;
+            pollution_deaths_history += 1.0;
+            bad += 100;
+        }
+        if (r &gt; 0 &amp;&amp; hc == 0) {
+            unnat_deaths++;
+            total_pollution_deaths++;
+            pollution_deaths_history += 1.0;
+            bad += 100;
+        }
     }
     /* normal births - must have food, water and jobs... and people */
-    if (use_waterwell) 
+    if (use_waterwell)
         birth_flag = FLAG_FED + FLAG_WATERWELL_COVER + FLAG_EMPLOYED;
     else
         birth_flag = FLAG_FED + FLAG_EMPLOYED;
 
-    if (((MP_INFO(x,y).flags &amp; birth_flag) == birth_flag)
-	&amp;&amp; (rand () % (RESIDENCE_BASE_BR + MP_INFO(x,y).int_4) == 1) 
-	&amp;&amp; (p &gt; 0))
-    {
+    if (((MP_INFO(x, y).flags &amp; birth_flag) == birth_flag)
+        &amp;&amp; (rand() % (RESIDENCE_BASE_BR + MP_INFO(x, y).int_4) == 1)
+        &amp;&amp; (p &gt; 0)) {
 #ifdef DEBUG_WATERWELL
-    	fprintf(stderr,&quot; birth ok, we are fed. use_waterwell= %i\n&quot;,use_waterwell);
+        fprintf(stderr, &quot; birth ok, we are fed. use_waterwell= %i\n&quot;, use_waterwell);
 #endif
-	p++;
-	total_births++;
-	good += 50;
+        p++;
+        total_births++;
+        good += 50;
     }
     /* are people starving or lacking water ? */
-    if ( ((MP_INFO(x,y).flags &amp; FLAG_FED) == 0)
-		| (use_waterwell &amp; (MP_INFO(x,y).flags &amp; FLAG_WATERWELL_COVER) == 0) 
-		&amp;&amp; p &gt; 0)
-    {
+    if (((MP_INFO(x, y).flags &amp; FLAG_FED) == 0)
+        | (use_waterwell &amp; (MP_INFO(x, y).flags &amp; FLAG_WATERWELL_COVER) == 0)
+        &amp;&amp; p &gt; 0) {
 #ifdef DEBUG_WATERWELL
-    	fprintf(stderr,&quot; hey, we are dying: lack of food or water!, use_waterwell=%i\n&quot;,use_waterwell);
+        fprintf(stderr, &quot; hey, we are dying: lack of food or water!, use_waterwell=%i\n&quot;, use_waterwell);
 #endif
-	if (rand () % DAYS_PER_STARVE == 1)
-	{
-	    p--;
-	    unnat_deaths++;
-	    total_starve_deaths++;
-	    starve_deaths_history += 1.0;
-	}
-	starving_population += p;
-	bad += 250;
-	drm += 100;
-	MP_INFO(x,y).int_2 = total_time;	/* for the starve screen */
+        if (rand() % DAYS_PER_STARVE == 1) {
+            p--;
+            unnat_deaths++;
+            total_starve_deaths++;
+            starve_deaths_history += 1.0;
+        }
+        starving_population += p;
+        bad += 250;
+        drm += 100;
+        MP_INFO(x, y).int_2 = total_time;       /* for the starve screen */
     }
     /* kick one out if overpopulated */
-    if (MP_TYPE(x,y) == CST_RESIDENCE_LL)
-    {
-	brm += RESIDENCE1_BRM;
-	drm += p * 8;
-	if (p &gt; 50)
-	{
-	    p--;
-	    people_pool++;
-	    brm += 20;
-	}
+    if (MP_TYPE(x, y) == CST_RESIDENCE_LL) {
+        brm += RESIDENCE1_BRM;
+        drm += p * 8;
+        if (p &gt; 50) {
+            p--;
+            people_pool++;
+            brm += 20;
+        }
+    } else if (MP_TYPE(x, y) == CST_RESIDENCE_ML) {
+        brm += RESIDENCE2_BRM;
+        drm += p * 3;
+        if (p &gt; 100) {
+            p--;
+            people_pool++;
+            brm += 10;
+        }
+    } else if (MP_TYPE(x, y) == CST_RESIDENCE_HL) {
+        brm += RESIDENCE3_BRM;
+        drm += p;
+        good += 40;
+        if (p &gt; 200) {
+            p--;
+            people_pool++;
+            brm += 10;
+        }
+    } else if (MP_TYPE(x, y) == CST_RESIDENCE_LH) {
+        brm += RESIDENCE4_BRM;
+        drm += p * 5;
+        if (p &gt; 100) {
+            p--;
+            people_pool++;
+            brm += 20;
+        }
+    } else if (MP_TYPE(x, y) == CST_RESIDENCE_MH) {
+        brm += RESIDENCE5_BRM;
+        drm += p / 2;
+        if (p &gt; 200) {
+            p--;
+            people_pool++;
+            brm += 10;
+        }
+    } else if (MP_TYPE(x, y) == CST_RESIDENCE_HH) {
+        good += 100;
+        brm += RESIDENCE6_BRM;
+        drm += p;
+        if (p &gt; 400) {
+            p--;
+            people_pool++;
+            brm += 10;
+        }
     }
-    else if (MP_TYPE(x,y) == CST_RESIDENCE_ML)
-    {
-	brm += RESIDENCE2_BRM;
-	drm += p * 3;
-	if (p &gt; 100)
-	{
-	    p--;
-	    people_pool++;
-	    brm += 10;
-	}
-    }
-    else if (MP_TYPE(x,y) == CST_RESIDENCE_HL)
-    {
-	brm += RESIDENCE3_BRM;
-	drm += p;
-	good += 40;
-	if (p &gt; 200)
-	{
-	    p--;
-	    people_pool++;
-	    brm += 10;
-	}
-    }
-    else if (MP_TYPE(x,y) == CST_RESIDENCE_LH)
-    {
-	brm += RESIDENCE4_BRM;
-	drm += p * 5;
-	if (p &gt; 100)
-	{
-	    p--;
-	    people_pool++;
-	    brm += 20;
-	}
-    }
-    else if (MP_TYPE(x,y) == CST_RESIDENCE_MH)
-    {
-	brm += RESIDENCE5_BRM;
-	drm += p / 2;
-	if (p &gt; 200)
-	{
-	    p--;
-	    people_pool++;
-	    brm += 10;
-	}
-    }
-    else if (MP_TYPE(x,y) == CST_RESIDENCE_HH)
-    {
-	good += 100;
-	brm += RESIDENCE6_BRM;
-	drm += p;
-	if (p &gt; 400)
-	{
-	    p--;
-	    people_pool++;
-	    brm += 10;
-	}
-    }
 
     /* XXX AL1: this is daily accumulator used stats.cpp, and maybe pop graph */
-    population += p; 
+    population += p;
 
     /* now get power */
-    if (get_power (x, y, POWER_RES_OVERHEAD
-		   + (POWER_USE_PER_PERSON * p), 0) != 0)
-    {
-	MP_INFO(x,y).flags |= FLAG_POWERED;
-	MP_INFO(x,y).flags |= FLAG_HAD_POWER;
-	good += 10;
+    if (get_power(x, y, POWER_RES_OVERHEAD + (POWER_USE_PER_PERSON * p), 0) != 0) {
+        MP_INFO(x, y).flags |= FLAG_POWERED;
+        MP_INFO(x, y).flags |= FLAG_HAD_POWER;
+        good += 10;
+    } else {
+        MP_INFO(x, y).flags &amp;= (0xffffffff - FLAG_POWERED);
+        bad += 15;
+        if ((MP_INFO(x, y).flags &amp; FLAG_HAD_POWER) != 0)
+            bad += 50;
     }
-    else
-    {
-	MP_INFO(x,y).flags &amp;= (0xffffffff - FLAG_POWERED);
-	bad += 15;
-	if ((MP_INFO(x,y).flags &amp; FLAG_HAD_POWER) != 0)
-	    bad += 50;
-    }
-    /* now get fed */  /* AL1: should be done earlier, before check for starvation */
-    if (get_food (x, y, p) != 0)
-    {
-	MP_INFO(x,y).flags |= FLAG_FED;
-	good += 10;
-    }
-    else
-	MP_INFO(x,y).flags &amp;= (0xffffffff - FLAG_FED);
+    /* now get fed *//* AL1: should be done earlier, before check for starvation */
+    if (get_food(x, y, p) != 0) {
+        MP_INFO(x, y).flags |= FLAG_FED;
+        good += 10;
+    } else
+        MP_INFO(x, y).flags &amp;= (0xffffffff - FLAG_FED);
 
     /* now supply jobs and buy goods if employed */
-    if (MP_INFO(x,y).int_1 &gt; 0)
-	swing = JOB_SWING + (hc * HC_JOB_SWING) + cc;
+    if (MP_INFO(x, y).int_1 &gt; 0)
+        swing = JOB_SWING + (hc * HC_JOB_SWING) + cc;
     else
-	swing = -(JOB_SWING + (hc * HC_JOB_SWING) + cc);
+        swing = -(JOB_SWING + (hc * HC_JOB_SWING) + cc);
 
-    if (put_jobs (x, y, ((p * (WORKING_POP_PERCENT + swing)) / 100)) != 0) {
-	MP_INFO(x,y).flags |= FLAG_EMPLOYED;
-	MP_INFO(x,y).int_1++;
-	if (MP_INFO(x,y).int_1 &gt; 10)
-	    MP_INFO(x,y).int_1 = 10;
-	good += 20;
-	if (get_goods (x, y, p / 4) != 0) {
-	    good += 10;
-	    if (get_power (x, y, p / 2, 0) != 0) {
-		good += 5;
-		brm += 10;
-		/*     buy more goods if got power for them */
-		if (get_goods (x, y, p / 4) != 0)
-		    good += 5;
-	    } else
-		bad += 5;
-	}
-    } else if (MP_INFO(x,y).int_1 &lt; 10) {
-	MP_INFO(x,y).flags &amp;= (0xffffffff - FLAG_EMPLOYED);
-	MP_INFO(x,y).int_1 -= 11;
-	if (MP_INFO(x,y).int_1 &lt; -300)
-	    MP_INFO(x,y).int_1 = -300;
-	unemployed_population += p;
-	total_unemployed_days += p;
-	if (total_unemployed_days &gt;= NUMOF_DAYS_IN_YEAR)
-	{
-	    total_unemployed_years++;
-	    /* think we're ok doing this, max of about 120 added each time. */
-	    total_unemployed_days -= NUMOF_DAYS_IN_YEAR;
-	    unemployed_history += 1.0;
-	}
-	unemployment_cost += p;	/* hmmm */
-	bad += 70;
+    if (put_jobs(x, y, ((p * (WORKING_POP_PERCENT + swing)) / 100)) != 0) {
+        MP_INFO(x, y).flags |= FLAG_EMPLOYED;
+        MP_INFO(x, y).int_1++;
+        if (MP_INFO(x, y).int_1 &gt; 10)
+            MP_INFO(x, y).int_1 = 10;
+        good += 20;
+        if (get_goods(x, y, p / 4) != 0) {
+            good += 10;
+            if (get_power(x, y, p / 2, 0) != 0) {
+                good += 5;
+                brm += 10;
+                /*     buy more goods if got power for them */
+                if (get_goods(x, y, p / 4) != 0)
+                    good += 5;
+            } else
+                bad += 5;
+        }
+    } else if (MP_INFO(x, y).int_1 &lt; 10) {
+        MP_INFO(x, y).flags &amp;= (0xffffffff - FLAG_EMPLOYED);
+        MP_INFO(x, y).int_1 -= 11;
+        if (MP_INFO(x, y).int_1 &lt; -300)
+            MP_INFO(x, y).int_1 = -300;
+        unemployed_population += p;
+        total_unemployed_days += p;
+        if (total_unemployed_days &gt;= NUMOF_DAYS_IN_YEAR) {
+            total_unemployed_years++;
+            /* think we're ok doing this, max of about 120 added each time. */
+            total_unemployed_days -= NUMOF_DAYS_IN_YEAR;
+            unemployed_history += 1.0;
+        }
+        unemployment_cost += p; /* hmmm */
+        bad += 70;
     } else {
-	MP_INFO(x,y).int_1 -= 20;
-	bad += 50;
+        MP_INFO(x, y).int_1 -= 20;
+        bad += 50;
     }
     drm += p / 4;
     /* people_pool stuff */
     bad += p / 2;
-    bad += MP_POL(x,y) / 20;
+    bad += MP_POL(x, y) / 20;
     good += people_pool / 27;
-    r = rand () % ((good + bad) * RESIDENCE_PPM);
+    r = rand() % ((good + bad) * RESIDENCE_PPM);
     if (r &lt; bad) {
-	if (p &gt; MIN_RES_POPULATION) {
-	    p--;
-	    people_pool++;
-	}
-    } else if (people_pool &gt; 0
-            &amp;&amp;  (MP_INFO(x,y).flags &amp; FLAG_FED) != 0  /* No newcomer gets in when there is starvation */
-            &amp;&amp; r &gt; ((good + bad) * (RESIDENCE_PPM - 1) + bad)) /* r &gt; (rmax - good) */ {
+        if (p &gt; MIN_RES_POPULATION) {
+            p--;
+            people_pool++;
+        }
+    } else if (people_pool &gt; 0 &amp;&amp; (MP_INFO(x, y).flags &amp; FLAG_FED) != 0 /* No newcomer gets in when there is starvation */
+               &amp;&amp; r &gt; ((good + bad) * (RESIDENCE_PPM - 1) + bad)) {     /* r &gt; (rmax - good) */
         p++;
         people_pool--;
     }
-    MP_INFO(x,y).population = p;
-    MP_INFO(x,y).int_4 = brm;
-    MP_INFO(x,y).int_5 = drm;
+    MP_INFO(x, y).population = p;
+    MP_INFO(x, y).int_4 = brm;
+    MP_INFO(x, y).int_5 = drm;
 }
 
-void
-mps_residence (int x, int y)
+void mps_residence(int x, int y)
 {
     int i = 0;
-    const char * p;
+    const char *p;
 
-    mps_store_title(i++,_(&quot;Residence&quot;));
+    mps_store_title(i++, _(&quot;Residence&quot;));
 
     i++;
 
-    mps_store_sd(i++,_(&quot;People&quot;), MP_INFO(x,y).population);
+    mps_store_sd(i++, _(&quot;People&quot;), MP_INFO(x, y).population);
 
     if (use_waterwell) {
-        p = ((MP_INFO(x,y).flags &amp; FLAG_WATERWELL_COVER) != 0) 
-                 ? _(&quot;YES&quot;) : _(&quot;NO&quot;);
+        p = ((MP_INFO(x, y).flags &amp; FLAG_WATERWELL_COVER) != 0)
+            ? _(&quot;YES&quot;) : _(&quot;NO&quot;);
         mps_store_ss(i++, _(&quot;Water&quot;), p);
     }
 
-    p = ((MP_INFO(x,y).flags &amp; FLAG_FED) != 0) ? _(&quot;YES&quot;) : _(&quot;NO&quot;);
+    p = ((MP_INFO(x, y).flags &amp; FLAG_FED) != 0) ? _(&quot;YES&quot;) : _(&quot;NO&quot;);
     mps_store_ss(i++, _(&quot;Fed&quot;), p);
 
-    p = ((MP_INFO(x,y).flags &amp; FLAG_POWERED) != 0) ? _(&quot;YES&quot;) : _(&quot;NO&quot;);
+    p = ((MP_INFO(x, y).flags &amp; FLAG_POWERED) != 0) ? _(&quot;YES&quot;) : _(&quot;NO&quot;);
     mps_store_ss(i++, _(&quot;Power&quot;), p);
 
-    p = ((MP_INFO(x,y).flags &amp; FLAG_EMPLOYED) != 0) ? _(&quot;YES&quot;) : _(&quot;NO&quot;);
+    p = ((MP_INFO(x, y).flags &amp; FLAG_EMPLOYED) != 0) ? _(&quot;YES&quot;) : _(&quot;NO&quot;);
     mps_store_ss(i++, _(&quot;Employed&quot;), p);
 
-    p = (MP_INFO(x,y).int_1 &gt;= 10) ? _(&quot;good&quot;) : _(&quot;poor&quot;);
+    p = (MP_INFO(x, y).int_1 &gt;= 10) ? _(&quot;good&quot;) : _(&quot;poor&quot;);
     mps_store_ss(i++, _(&quot;Job&quot;), p);
 
-    p = ((MP_INFO(x,y).flags &amp; FLAG_HEALTH_COVER) != 0) ? _(&quot;YES&quot;) : _(&quot;NO&quot;);
+    p = ((MP_INFO(x, y).flags &amp; FLAG_HEALTH_COVER) != 0) ? _(&quot;YES&quot;) : _(&quot;NO&quot;);
     mps_store_ss(i++, _(&quot;Health Cvr&quot;), p);
 
-    p = ((MP_INFO(x,y).flags &amp; FLAG_FIRE_COVER) != 0) ? _(&quot;YES&quot;) : _(&quot;NO&quot;);
+    p = ((MP_INFO(x, y).flags &amp; FLAG_FIRE_COVER) != 0) ? _(&quot;YES&quot;) : _(&quot;NO&quot;);
     mps_store_ss(i++, _(&quot;Fire&quot;), p);
 
-    p = ((MP_INFO(x,y).flags &amp; FLAG_CRICKET_COVER) != 0) ? _(&quot;YES&quot;) : _(&quot;NO&quot;);
+    p = ((MP_INFO(x, y).flags &amp; FLAG_CRICKET_COVER) != 0) ? _(&quot;YES&quot;) : _(&quot;NO&quot;);
     mps_store_ss(i++, _(&quot;Sport&quot;), p);
 
-    mps_store_sd(i++, _(&quot;Pollution&quot;), MP_POL(x,y));
+    mps_store_sd(i++, _(&quot;Pollution&quot;), MP_POL(x, y));
 
 }

Modified: trunk/src/lincity/modules/road.cpp
===================================================================
--- trunk/src/lincity/modules/road.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/road.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -21,45 +21,34 @@
    int_7 contains the amount of waste
   --------------------------------------------------------------------- */
 
-
-
-void
-do_road (int x, int y)
+void do_road(int x, int y)
 {
     static int wb_count = 0;
-    int *pol = &amp;MP_POL(x,y);
-    Map_Point_Info *minfo = &amp;MP_INFO(x,y);
+    int *pol = &amp;MP_POL(x, y);
+    Map_Point_Info *minfo = &amp;MP_INFO(x, y);
     ++transport_cost;
     if (total_time % DAYS_PER_ROAD_POLLUTION == 0)
-	*pol += ROAD_POLLUTION;
+        *pol += ROAD_POLLUTION;
     if ((total_time &amp; ROAD_GOODS_USED_MASK) == 0 &amp;&amp; minfo-&gt;int_4 &gt; 0) {
-	--minfo-&gt;int_4;
-	++minfo-&gt;int_7;
+        --minfo-&gt;int_4;
+        ++minfo-&gt;int_7;
     }
-    general_transport (minfo, pol, MAX_WASTE_ON_ROAD, &amp;wb_count);
+    general_transport(minfo, pol, MAX_WASTE_ON_ROAD, &amp;wb_count);
 }
 
-void
-mps_road (int x, int y)
+void mps_road(int x, int y)
 {
-  int i = 0;
+    int i = 0;
 
-  mps_store_title(i++,_(&quot;Road&quot;));
-  i++;
+    mps_store_title(i++, _(&quot;Road&quot;));
+    i++;
 
-  mps_store_sfp(i++,_(&quot;Food&quot;), 
-		MP_INFO(x,y).int_1 * 100.0 / MAX_FOOD_ON_ROAD);
-  mps_store_sfp(i++,_(&quot;Jobs&quot;), 
-		MP_INFO(x,y).int_2 * 100.0 / MAX_JOBS_ON_ROAD);
-  mps_store_sfp(i++,_(&quot;Coal&quot;), 
-		MP_INFO(x,y).int_3 * 100.0 / MAX_COAL_ON_ROAD);
-  mps_store_sfp(i++,_(&quot;Goods&quot;), 
-		MP_INFO(x,y).int_4 * 100.0 / MAX_GOODS_ON_ROAD);
-  mps_store_sfp(i++,_(&quot;Ore&quot;), 
-		MP_INFO(x,y).int_5 * 100.0 / MAX_ORE_ON_ROAD);
-  mps_store_sfp(i++,_(&quot;Steel&quot;), 
-		MP_INFO(x,y).int_6 * 100.0 / MAX_STEEL_ON_ROAD);
-  mps_store_sfp(i++,_(&quot;Waste&quot;), 
-		MP_INFO(x,y).int_7 * 100.0 / MAX_WASTE_ON_ROAD);
+    mps_store_sfp(i++, _(&quot;Food&quot;), MP_INFO(x, y).int_1 * 100.0 / MAX_FOOD_ON_ROAD);
+    mps_store_sfp(i++, _(&quot;Jobs&quot;), MP_INFO(x, y).int_2 * 100.0 / MAX_JOBS_ON_ROAD);
+    mps_store_sfp(i++, _(&quot;Coal&quot;), MP_INFO(x, y).int_3 * 100.0 / MAX_COAL_ON_ROAD);
+    mps_store_sfp(i++, _(&quot;Goods&quot;), MP_INFO(x, y).int_4 * 100.0 / MAX_GOODS_ON_ROAD);
+    mps_store_sfp(i++, _(&quot;Ore&quot;), MP_INFO(x, y).int_5 * 100.0 / MAX_ORE_ON_ROAD);
+    mps_store_sfp(i++, _(&quot;Steel&quot;), MP_INFO(x, y).int_6 * 100.0 / MAX_STEEL_ON_ROAD);
+    mps_store_sfp(i++, _(&quot;Waste&quot;), MP_INFO(x, y).int_7 * 100.0 / MAX_WASTE_ON_ROAD);
 
 }

Modified: trunk/src/lincity/modules/rocket_pad.cpp
===================================================================
--- trunk/src/lincity/modules/rocket_pad.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/rocket_pad.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -14,240 +14,222 @@
 
 #include &lt;stdlib.h&gt;
 
-void
-do_rocket_pad (int x, int y)
+void do_rocket_pad(int x, int y)
 {
     /*
-      // You need ROCKET_PAD_JOBS, ROCKET_PAD_GOODS and ROCKET_PAD_STEEL 
-      // to add 1 to % of ready to fire.
-      // int_1 is the stored jobs
-      // int_2 is the stored goods
-      // int_3 is the stored steel
-      // int_4 is the count which gets to ROCKET_PAD_LAUNCH to fire.
-      // int_5 is the time of the next animation frame, when waiting for launch.
-      */
-    if (MP_TYPE(x,y) == CST_ROCKET_FLOWN)
-	return;			/* The rocket has been launched. */
+       // You need ROCKET_PAD_JOBS, ROCKET_PAD_GOODS and ROCKET_PAD_STEEL 
+       // to add 1 to % of ready to fire.
+       // int_1 is the stored jobs
+       // int_2 is the stored goods
+       // int_3 is the stored steel
+       // int_4 is the count which gets to ROCKET_PAD_LAUNCH to fire.
+       // int_5 is the time of the next animation frame, when waiting for launch.
+     */
+    if (MP_TYPE(x, y) == CST_ROCKET_FLOWN)
+        return;                 /* The rocket has been launched. */
 
     /* get some jobs */
-    if (MP_INFO(x,y).int_1 &lt; ROCKET_PAD_JOBS_STORE)
-    {
-	if (get_jobs (x, y, ROCKET_PAD_JOBS + 10) != 0)
-	    MP_INFO(x,y).int_1 += ROCKET_PAD_JOBS;
+    if (MP_INFO(x, y).int_1 &lt; ROCKET_PAD_JOBS_STORE) {
+        if (get_jobs(x, y, ROCKET_PAD_JOBS + 10) != 0)
+            MP_INFO(x, y).int_1 += ROCKET_PAD_JOBS;
     }
     /* get goods */
-    if (MP_INFO(x,y).int_2 &lt; ROCKET_PAD_GOODS_STORE)
-    {
-	if (get_goods (x, y, ROCKET_PAD_GOODS + 10) != 0)
-	    MP_INFO(x,y).int_2 += ROCKET_PAD_GOODS;
-	else if (get_goods (x, y, ROCKET_PAD_GOODS / 10) != 0)
-	    MP_INFO(x,y).int_2 += ROCKET_PAD_GOODS / 5;
-	else if (get_goods (x, y, ROCKET_PAD_GOODS / 50) != 0)
-	    MP_INFO(x,y).int_2 += ROCKET_PAD_GOODS / 20;
+    if (MP_INFO(x, y).int_2 &lt; ROCKET_PAD_GOODS_STORE) {
+        if (get_goods(x, y, ROCKET_PAD_GOODS + 10) != 0)
+            MP_INFO(x, y).int_2 += ROCKET_PAD_GOODS;
+        else if (get_goods(x, y, ROCKET_PAD_GOODS / 10) != 0)
+            MP_INFO(x, y).int_2 += ROCKET_PAD_GOODS / 5;
+        else if (get_goods(x, y, ROCKET_PAD_GOODS / 50) != 0)
+            MP_INFO(x, y).int_2 += ROCKET_PAD_GOODS / 20;
     }
     /* get steel */
-    if (MP_INFO(x,y).int_3 &lt; ROCKET_PAD_STEEL_STORE)
-    {
-	if (get_steel (x, y, ROCKET_PAD_STEEL + 10) != 0)
-	    MP_INFO(x,y).int_3 += ROCKET_PAD_STEEL + 10;
-	else if (get_steel (x, y, ROCKET_PAD_STEEL / 5) != 0)
-	    MP_INFO(x,y).int_3 += ROCKET_PAD_STEEL / 5;
-	else if (get_steel (x, y, ROCKET_PAD_STEEL / 20) != 0)
-	    MP_INFO(x,y).int_3 += ROCKET_PAD_STEEL / 20;
+    if (MP_INFO(x, y).int_3 &lt; ROCKET_PAD_STEEL_STORE) {
+        if (get_steel(x, y, ROCKET_PAD_STEEL + 10) != 0)
+            MP_INFO(x, y).int_3 += ROCKET_PAD_STEEL + 10;
+        else if (get_steel(x, y, ROCKET_PAD_STEEL / 5) != 0)
+            MP_INFO(x, y).int_3 += ROCKET_PAD_STEEL / 5;
+        else if (get_steel(x, y, ROCKET_PAD_STEEL / 20) != 0)
+            MP_INFO(x, y).int_3 += ROCKET_PAD_STEEL / 20;
     }
 #ifdef DEBUG_ROCKETS
-    MP_INFO(x,y).int_4++;
+    MP_INFO(x, y).int_4++;
 #else
     /* now build the rocket.  Unlike uni's need a full store to make +1% */
-    if (MP_TYPE(x,y) &lt; CST_ROCKET_5
-	&amp;&amp; MP_INFO(x,y).int_1 &gt;= ROCKET_PAD_JOBS_STORE
-	&amp;&amp; MP_INFO(x,y).int_2 &gt;= ROCKET_PAD_GOODS_STORE
-	&amp;&amp; MP_INFO(x,y).int_3 &gt;= ROCKET_PAD_STEEL_STORE)
-    {
-	MP_INFO(x,y).int_1 -= ROCKET_PAD_JOBS_STORE;
-	MP_INFO(x,y).int_2 -= ROCKET_PAD_GOODS_STORE;
-	MP_INFO(x,y).int_3 -= ROCKET_PAD_STEEL_STORE;
-	MP_INFO(x,y).int_4++;
-	goods_used += ROCKET_PAD_GOODS_STORE;
+    if (MP_TYPE(x, y) &lt; CST_ROCKET_5
+        &amp;&amp; MP_INFO(x, y).int_1 &gt;= ROCKET_PAD_JOBS_STORE
+        &amp;&amp; MP_INFO(x, y).int_2 &gt;= ROCKET_PAD_GOODS_STORE &amp;&amp; MP_INFO(x, y).int_3 &gt;= ROCKET_PAD_STEEL_STORE) {
+        MP_INFO(x, y).int_1 -= ROCKET_PAD_JOBS_STORE;
+        MP_INFO(x, y).int_2 -= ROCKET_PAD_GOODS_STORE;
+        MP_INFO(x, y).int_3 -= ROCKET_PAD_STEEL_STORE;
+        MP_INFO(x, y).int_4++;
+        goods_used += ROCKET_PAD_GOODS_STORE;
 
     }
 #endif
     rocket_pad_cost += ROCKET_PAD_RUNNING_COST;
     /* animate and return if already said no to launch */
-    if (MP_TYPE(x,y) &gt;= CST_ROCKET_5
-	&amp;&amp; MP_INFO(x,y).int_4 &gt;= (100 * ROCKET_PAD_LAUNCH) / 100)
-    {
-	if (real_time &gt;= MP_INFO(x,y).int_5)
-	{
-	    MP_INFO(x,y).int_5 = real_time + ROCKET_ANIMATION_SPEED;
-	    switch (MP_TYPE(x,y))
-	    {
-	    case (CST_ROCKET_5):
-		MP_TYPE(x,y) = CST_ROCKET_6;
-		break;
-	    case (CST_ROCKET_6):
-		MP_TYPE(x,y) = CST_ROCKET_7;
-		break;
-	    case (CST_ROCKET_7):
-		MP_TYPE(x,y) = CST_ROCKET_5;
-		break;
-	    }
-	}
-	return;
+    if (MP_TYPE(x, y) &gt;= CST_ROCKET_5 &amp;&amp; MP_INFO(x, y).int_4 &gt;= (100 * ROCKET_PAD_LAUNCH) / 100) {
+        if (real_time &gt;= MP_INFO(x, y).int_5) {
+            MP_INFO(x, y).int_5 = real_time + ROCKET_ANIMATION_SPEED;
+            switch (MP_TYPE(x, y)) {
+            case (CST_ROCKET_5):
+                MP_TYPE(x, y) = CST_ROCKET_6;
+                break;
+            case (CST_ROCKET_6):
+                MP_TYPE(x, y) = CST_ROCKET_7;
+                break;
+            case (CST_ROCKET_7):
+                MP_TYPE(x, y) = CST_ROCKET_5;
+                break;
+            }
+        }
+        return;
     }
     /* now choose a graphic */
-    if (MP_INFO(x,y).int_4 &lt; (25 * ROCKET_PAD_LAUNCH) / 100)
-	MP_TYPE(x,y) = CST_ROCKET_1;
-    else if (MP_INFO(x,y).int_4 &lt; (60 * ROCKET_PAD_LAUNCH) / 100)
-	MP_TYPE(x,y) = CST_ROCKET_2;
-    else if (MP_INFO(x,y).int_4 &lt; (90 * ROCKET_PAD_LAUNCH) / 100)
-	MP_TYPE(x,y) = CST_ROCKET_3;
-    else if (MP_INFO(x,y).int_4 &lt; (100 * ROCKET_PAD_LAUNCH) / 100)
-	MP_TYPE(x,y) = CST_ROCKET_4;
-    else if (MP_INFO(x,y).int_4 &gt;= (100 * ROCKET_PAD_LAUNCH) / 100) {
-	MP_TYPE(x,y) = CST_ROCKET_5;
-	update_main_screen (0);
-	if (ask_launch_rocket_now (x,y)) {
+    if (MP_INFO(x, y).int_4 &lt; (25 * ROCKET_PAD_LAUNCH) / 100)
+        MP_TYPE(x, y) = CST_ROCKET_1;
+    else if (MP_INFO(x, y).int_4 &lt; (60 * ROCKET_PAD_LAUNCH) / 100)
+        MP_TYPE(x, y) = CST_ROCKET_2;
+    else if (MP_INFO(x, y).int_4 &lt; (90 * ROCKET_PAD_LAUNCH) / 100)
+        MP_TYPE(x, y) = CST_ROCKET_3;
+    else if (MP_INFO(x, y).int_4 &lt; (100 * ROCKET_PAD_LAUNCH) / 100)
+        MP_TYPE(x, y) = CST_ROCKET_4;
+    else if (MP_INFO(x, y).int_4 &gt;= (100 * ROCKET_PAD_LAUNCH) / 100) {
+        MP_TYPE(x, y) = CST_ROCKET_5;
+        update_main_screen(0);
+        if (ask_launch_rocket_now(x, y)) {
             /* ? AL1: in NG 1.1 it seems we are never here ?
              * ? ask_launch_rocket_now  manages everything and call launch_rocket ?
              */
-            launch_rocket (x,y);
-	}
-	/* so we don't get get our money back when we bulldoze. */
-	if (x == last_built_x &amp;&amp; y == last_built_y) {
-	    x = 0;
-	    y = 0;
-	}
+            launch_rocket(x, y);
+        }
+        /* so we don't get get our money back when we bulldoze. */
+        if (x == last_built_x &amp;&amp; y == last_built_y) {
+            x = 0;
+            y = 0;
+        }
     }
 }
 
-void
-remove_people (int num)
+void remove_people(int num)
 {
 #if defined (commentout)
-  int x, y, f;
-  time_t t;
-  f = 1;
-  t = time (0);
-  while (f &amp;&amp; (num &gt; 0)) {
-      for (y = 0; y &lt; WORLD_SIDE_LEN; y++)
-	for (x = 0; x &lt; WORLD_SIDE_LEN; x++)
-	  if (MP_GROUP_IS_RESIDENCE(x,y) &amp;&amp; MP_INFO(x,y).population &gt; 0)
-	    {
-	      MP_INFO(x,y).population--;
-	      // f = 1;
-	      f |= (MP_INFO(x,y).population &gt; 0);
-	      num--;
-	      total_evacuated++;
-	    }
-  }
-  while (num &gt; 0 &amp;&amp; people_pool &gt; 0) {
-      num--;
-      total_evacuated++;
-      people_pool--;
-  }
+    int x, y, f;
+    time_t t;
+    f = 1;
+    t = time(0);
+    while (f &amp;&amp; (num &gt; 0)) {
+        for (y = 0; y &lt; WORLD_SIDE_LEN; y++)
+            for (x = 0; x &lt; WORLD_SIDE_LEN; x++)
+                if (MP_GROUP_IS_RESIDENCE(x, y) &amp;&amp; MP_INFO(x, y).population &gt; 0) {
+                    MP_INFO(x, y).population--;
+                    // f = 1;
+                    f |= (MP_INFO(x, y).population &gt; 0);
+                    num--;
+                    total_evacuated++;
+                }
+    }
+    while (num &gt; 0 &amp;&amp; people_pool &gt; 0) {
+        num--;
+        total_evacuated++;
+        people_pool--;
+    }
 #endif
 
-  int x, y;
-  /* reset housed population so that we can display it correctly */
-  housed_population = 1;
-  while (housed_population &amp;&amp; (num &gt; 0)) {
-      housed_population = 0;
-      for (y = 0; y &lt; WORLD_SIDE_LEN; y++)
-	for (x = 0; x &lt; WORLD_SIDE_LEN; x++)
-	  if (MP_GROUP_IS_RESIDENCE(x,y) &amp;&amp; MP_INFO(x,y).population &gt; 0) {
-	      MP_INFO(x,y).population--;
-	      housed_population += MP_INFO(x,y).population;
-	      num--;
-	      total_evacuated++;
-	  }
-  }
-  while (num &gt; 0 &amp;&amp; people_pool &gt; 0) {
-      num--;
-      total_evacuated++;
-      people_pool--;
-  }
+    int x, y;
+    /* reset housed population so that we can display it correctly */
+    housed_population = 1;
+    while (housed_population &amp;&amp; (num &gt; 0)) {
+        housed_population = 0;
+        for (y = 0; y &lt; WORLD_SIDE_LEN; y++)
+            for (x = 0; x &lt; WORLD_SIDE_LEN; x++)
+                if (MP_GROUP_IS_RESIDENCE(x, y) &amp;&amp; MP_INFO(x, y).population &gt; 0) {
+                    MP_INFO(x, y).population--;
+                    housed_population += MP_INFO(x, y).population;
+                    num--;
+                    total_evacuated++;
+                }
+    }
+    while (num &gt; 0 &amp;&amp; people_pool &gt; 0) {
+        num--;
+        total_evacuated++;
+        people_pool--;
+    }
 
-  refresh_population_text ();
+    refresh_population_text();
 
 #if defined (commentout)
 /* last ship wasn't full so everyone has gone. */
-  if (num &gt; 0)
-    {
-      if (t &gt; HOF_START &amp;&amp; t &lt; HOF_STOP)
-	ok_dial_box (&quot;launch-gone-mail.mes&quot;, GOOD, 0L);
-      else
-	ok_dial_box (&quot;launch-gone.mes&quot;, GOOD, 0L);
-      housed_population = 0;
+    if (num &gt; 0) {
+        if (t &gt; HOF_START &amp;&amp; t &lt; HOF_STOP)
+            ok_dial_box(&quot;launch-gone-mail.mes&quot;, GOOD, 0L);
+        else
+            ok_dial_box(&quot;launch-gone.mes&quot;, GOOD, 0L);
+        housed_population = 0;
     }
 #endif
 
-  /* Note that the previous test was inaccurate.  There could be 
-     exactly 1000 people left. */
-  if (!housed_population &amp;&amp; !people_pool) {
-    ok_dial_box (&quot;launch-gone.mes&quot;, GOOD, 0L);
-  }
+    /* Note that the previous test was inaccurate.  There could be 
+       exactly 1000 people left. */
+    if (!housed_population &amp;&amp; !people_pool) {
+        ok_dial_box(&quot;launch-gone.mes&quot;, GOOD, 0L);
+    }
 }
 
-void
-launch_rocket (int x, int y)
+void launch_rocket(int x, int y)
 {
     int i, r, xx, yy, xxx, yyy;
     rockets_launched++;
-    MP_TYPE(x,y) = CST_ROCKET_FLOWN;
-    update_main_screen (0);
+    MP_TYPE(x, y) = CST_ROCKET_FLOWN;
+    update_main_screen(0);
     /* The first five failures gives 49.419 % chances of 5 success
      * TODO: some stress could be added by 3,2,1,0 and animation of rocket with sound...
      */
-    r = rand () % MAX_TECH_LEVEL;
-    if (r &gt; tech_level || rand () % 100 &gt; (rockets_launched * 15 + 25)) {
-	/* the launch failed */
-	display_rocket_result_dialog (ROCKET_LAUNCH_BAD);
-	rockets_launched_success = 0;
-	xx = ((rand () % 40) - 20) + x;
-	yy = ((rand () % 40) - 20) + y;
-	for (i = 0; i &lt; 20; i++) {
-	    xxx = ((rand () % 20) - 10) + xx;
-	    yyy = ((rand () % 20) - 10) + yy;
-	    if (xxx &gt; 0 &amp;&amp; xxx &lt; (WORLD_SIDE_LEN - 4)
-                    &amp;&amp; yyy &gt; 0 &amp;&amp; yyy &lt; (WORLD_SIDE_LEN - 4)) {
-		/* don't crash on it's own area */
-		if (xxx &gt;= x &amp;&amp; xxx &lt; (x + 4) &amp;&amp; yyy &gt;= y &amp;&amp; yyy &lt; (y + 4))
-		    continue;
-		fire_area (xxx, yyy);
-		/* make a sound perhaps */
-	    }
-	}
+    r = rand() % MAX_TECH_LEVEL;
+    if (r &gt; tech_level || rand() % 100 &gt; (rockets_launched * 15 + 25)) {
+        /* the launch failed */
+        display_rocket_result_dialog(ROCKET_LAUNCH_BAD);
+        rockets_launched_success = 0;
+        xx = ((rand() % 40) - 20) + x;
+        yy = ((rand() % 40) - 20) + y;
+        for (i = 0; i &lt; 20; i++) {
+            xxx = ((rand() % 20) - 10) + xx;
+            yyy = ((rand() % 20) - 10) + yy;
+            if (xxx &gt; 0 &amp;&amp; xxx &lt; (WORLD_SIDE_LEN - 4)
+                &amp;&amp; yyy &gt; 0 &amp;&amp; yyy &lt; (WORLD_SIDE_LEN - 4)) {
+                /* don't crash on it's own area */
+                if (xxx &gt;= x &amp;&amp; xxx &lt; (x + 4) &amp;&amp; yyy &gt;= y &amp;&amp; yyy &lt; (y + 4))
+                    continue;
+                fire_area(xxx, yyy);
+                /* make a sound perhaps */
+            }
+        }
     } else {
-	rockets_launched_success++;
+        rockets_launched_success++;
         /* TODO: Maybe should generate some pollution ? */
-	if (rockets_launched_success &gt; 5) {
-	    remove_people (1000);
-	    if (people_pool || housed_population)
-	      display_rocket_result_dialog (ROCKET_LAUNCH_EVAC);
-	} else {
-	    display_rocket_result_dialog (ROCKET_LAUNCH_GOOD);
-	}
+        if (rockets_launched_success &gt; 5) {
+            remove_people(1000);
+            if (people_pool || housed_population)
+                display_rocket_result_dialog(ROCKET_LAUNCH_EVAC);
+        } else {
+            display_rocket_result_dialog(ROCKET_LAUNCH_GOOD);
+        }
     }
 }
 
-void
-mps_rocket (int x, int y)
+void mps_rocket(int x, int y)
 {
     int i = 0;
 
-    mps_store_title(i++,_(&quot;Rocket Pad&quot;));
+    mps_store_title(i++, _(&quot;Rocket Pad&quot;));
     i++;
 
-    mps_store_title(i++,_(&quot;Completion&quot;));
-    mps_store_fp(i++, MP_INFO(x,y).int_4 * 100.0 / ROCKET_PAD_LAUNCH);    
+    mps_store_title(i++, _(&quot;Completion&quot;));
+    mps_store_fp(i++, MP_INFO(x, y).int_4 * 100.0 / ROCKET_PAD_LAUNCH);
     i++;
-    mps_store_title(i++,_(&quot;Inventory&quot;));
-    mps_store_sfp(i++,_(&quot;Jobs&quot;), 
-		  MP_INFO(x,y).int_1 * 100.0 / ROCKET_PAD_JOBS_STORE);
-    mps_store_sfp(i++,_(&quot;Goods&quot;),
-		  MP_INFO(x,y).int_2 * 100.0 / ROCKET_PAD_GOODS_STORE);
-    mps_store_sfp(i++,_(&quot;Steel&quot;),
-		  MP_INFO(x,y).int_3 * 100.0 / ROCKET_PAD_STEEL_STORE);
+    mps_store_title(i++, _(&quot;Inventory&quot;));
+    mps_store_sfp(i++, _(&quot;Jobs&quot;), MP_INFO(x, y).int_1 * 100.0 / ROCKET_PAD_JOBS_STORE);
+    mps_store_sfp(i++, _(&quot;Goods&quot;), MP_INFO(x, y).int_2 * 100.0 / ROCKET_PAD_GOODS_STORE);
+    mps_store_sfp(i++, _(&quot;Steel&quot;), MP_INFO(x, y).int_3 * 100.0 / ROCKET_PAD_STEEL_STORE);
 
 }

Modified: trunk/src/lincity/modules/rocket_pad.h
===================================================================
--- trunk/src/lincity/modules/rocket_pad.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/rocket_pad.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -10,6 +10,6 @@
 
 void do_rocket_pad(int x, int y);
 void launch_rocket(int x, int y);
-void mps_rocket (int x, int y);
+void mps_rocket(int x, int y);
 
 #endif /* __rocket_pad_h__ */

Modified: trunk/src/lincity/modules/school.cpp
===================================================================
--- trunk/src/lincity/modules/school.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/school.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -8,55 +8,47 @@
 #include &quot;modules.h&quot;
 #include &quot;school.h&quot;
 
-
-void
-do_school (int x, int y)
+void do_school(int x, int y)
 {
-  /*
-     // int_1 contains the job pool
-     // int_2 contains the goods at the school
-     // int_3 has the tech points made
-     // int_4 is the tech count so far this 100 days
-     // int_5 is the tech count last 100 days to give a % of max production
-   */
-  if (MP_INFO(x,y).int_1 &lt; (MAX_JOBS_AT_SCHOOL - SCHOOL_JOBS))
-    if (get_jobs (x, y, SCHOOL_JOBS) != 0)
-      MP_INFO(x,y).int_1 += SCHOOL_JOBS;
-  if (MP_INFO(x,y).int_2 &lt; (MAX_GOODS_AT_SCHOOL - SCHOOL_GOODS))
-    if (get_goods (x, y, SCHOOL_GOODS) != 0)
-      MP_INFO(x,y).int_2 += SCHOOL_GOODS;
-  if (MP_INFO(x,y).int_1 &gt;= JOBS_MAKE_TECH_SCHOOL
-      &amp;&amp; MP_INFO(x,y).int_2 &gt;= GOODS_MAKE_TECH_SCHOOL)
-    {
-      MP_INFO(x,y).int_1 -= JOBS_MAKE_TECH_SCHOOL;
-      MP_INFO(x,y).int_2 -= GOODS_MAKE_TECH_SCHOOL;
-      MP_INFO(x,y).int_3 += TECH_MADE_BY_SCHOOL;
-      MP_INFO(x,y).int_4++;
-      tech_level += TECH_MADE_BY_SCHOOL;
+    /*
+       // int_1 contains the job pool
+       // int_2 contains the goods at the school
+       // int_3 has the tech points made
+       // int_4 is the tech count so far this 100 days
+       // int_5 is the tech count last 100 days to give a % of max production
+     */
+    if (MP_INFO(x, y).int_1 &lt; (MAX_JOBS_AT_SCHOOL - SCHOOL_JOBS))
+        if (get_jobs(x, y, SCHOOL_JOBS) != 0)
+            MP_INFO(x, y).int_1 += SCHOOL_JOBS;
+    if (MP_INFO(x, y).int_2 &lt; (MAX_GOODS_AT_SCHOOL - SCHOOL_GOODS))
+        if (get_goods(x, y, SCHOOL_GOODS) != 0)
+            MP_INFO(x, y).int_2 += SCHOOL_GOODS;
+    if (MP_INFO(x, y).int_1 &gt;= JOBS_MAKE_TECH_SCHOOL &amp;&amp; MP_INFO(x, y).int_2 &gt;= GOODS_MAKE_TECH_SCHOOL) {
+        MP_INFO(x, y).int_1 -= JOBS_MAKE_TECH_SCHOOL;
+        MP_INFO(x, y).int_2 -= GOODS_MAKE_TECH_SCHOOL;
+        MP_INFO(x, y).int_3 += TECH_MADE_BY_SCHOOL;
+        MP_INFO(x, y).int_4++;
+        tech_level += TECH_MADE_BY_SCHOOL;
     }
-  school_cost += SCHOOL_RUNNING_COST;
-  if ((total_time % 100) == 0)
-    {
-      MP_INFO(x,y).int_5 = MP_INFO(x,y).int_4;
-      MP_INFO(x,y).int_4 = 0;
+    school_cost += SCHOOL_RUNNING_COST;
+    if ((total_time % 100) == 0) {
+        MP_INFO(x, y).int_5 = MP_INFO(x, y).int_4;
+        MP_INFO(x, y).int_4 = 0;
     }
 }
 
-void
-mps_school (int x, int y)
+void mps_school(int x, int y)
 {
-  int i = 0;
-  mps_store_title(i++,_(&quot;School&quot;));
-  i++;
-  mps_store_title(i++,_(&quot;Lessons Learned&quot;));
-  mps_store_f(i++,MP_INFO(x,y).int_3 * 100.0 / MAX_TECH_LEVEL);
-  i++;
-  mps_store_title(i++,_(&quot;Inventory&quot;));
-  mps_store_sfp(i++,_(&quot;Jobs&quot;),
-		MP_INFO(x,y).int_1 * 100.0 / MAX_JOBS_AT_SCHOOL);
-  mps_store_sfp(i++,_(&quot;Goods&quot;),
-		MP_INFO(x,y).int_2 * 100.0 / MAX_GOODS_AT_SCHOOL);
+    int i = 0;
+    mps_store_title(i++, _(&quot;School&quot;));
+    i++;
+    mps_store_title(i++, _(&quot;Lessons Learned&quot;));
+    mps_store_f(i++, MP_INFO(x, y).int_3 * 100.0 / MAX_TECH_LEVEL);
+    i++;
+    mps_store_title(i++, _(&quot;Inventory&quot;));
+    mps_store_sfp(i++, _(&quot;Jobs&quot;), MP_INFO(x, y).int_1 * 100.0 / MAX_JOBS_AT_SCHOOL);
+    mps_store_sfp(i++, _(&quot;Goods&quot;), MP_INFO(x, y).int_2 * 100.0 / MAX_GOODS_AT_SCHOOL);
 
-  mps_store_sfp(i++,_(&quot;Capacity&quot;), MP_INFO(x,y).int_5 * 4);
+    mps_store_sfp(i++, _(&quot;Capacity&quot;), MP_INFO(x, y).int_5 * 4);
 
 }

Modified: trunk/src/lincity/modules/school.h
===================================================================
--- trunk/src/lincity/modules/school.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/school.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -9,6 +9,6 @@
 #define __school_h__
 
 void do_school(int x, int y);
-void mps_school (int x, int y);
+void mps_school(int x, int y);
 
 #endif /* __school_h__ */

Modified: trunk/src/lincity/modules/shanty.cpp
===================================================================
--- trunk/src/lincity/modules/shanty.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/shanty.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -11,112 +11,102 @@
 
 #include &lt;stdlib.h&gt;
 
-void
-add_a_shanty (void)
+void add_a_shanty(void)
 {
-  int r, x, y;
-  x = rand () % WORLD_SIDE_LEN;
-  y = rand () % WORLD_SIDE_LEN;
-  if (numof_shanties &gt; 0 &amp;&amp; rand () % 8 != 0)
-    {
-      r = spiral_find_group (x, y, GROUP_SHANTY);
-      if (r == -1)
-	{
-	  printf (&quot;Looked for a shanty, without any! x=%d y=%d\n&quot;, x, y);
-	  return;
-	}
-      y = r / WORLD_SIDE_LEN;
-      x = r % WORLD_SIDE_LEN;
-      r = spiral_find_2x2 (x, y);
-      if (r == -1)
-	{
-#ifdef commentout /* wck: These are annoying when the map is full */
-	 	  printf (&quot;Adding a shanty (s), no space for it?!\n&quot;);
+    int r, x, y;
+    x = rand() % WORLD_SIDE_LEN;
+    y = rand() % WORLD_SIDE_LEN;
+    if (numof_shanties &gt; 0 &amp;&amp; rand() % 8 != 0) {
+        r = spiral_find_group(x, y, GROUP_SHANTY);
+        if (r == -1) {
+            printf(&quot;Looked for a shanty, without any! x=%d y=%d\n&quot;, x, y);
+            return;
+        }
+        y = r / WORLD_SIDE_LEN;
+        x = r % WORLD_SIDE_LEN;
+        r = spiral_find_2x2(x, y);
+        if (r == -1) {
+#ifdef commentout               /* wck: These are annoying when the map is full */
+            printf(&quot;Adding a shanty (s), no space for it?!\n&quot;);
 #endif
-	  return;
-	}
-      y = r / WORLD_SIDE_LEN;
-      x = r % WORLD_SIDE_LEN;
-    }
-  else
-    {
-      r = spiral_find_group (x, y, GROUP_MARKET);
-      if (r == -1)
-	return;			/* silently return, we havn't started yet. */
+            return;
+        }
+        y = r / WORLD_SIDE_LEN;
+        x = r % WORLD_SIDE_LEN;
+    } else {
+        r = spiral_find_group(x, y, GROUP_MARKET);
+        if (r == -1)
+            return;             /* silently return, we havn't started yet. */
 
-      y = r / WORLD_SIDE_LEN;
-      x = r % WORLD_SIDE_LEN;
-      r = spiral_find_2x2 (x, y);
-      if (r == -1)
-	{
-#ifdef commentout /* see above */
-	  printf (&quot;Adding a shanty (r), no space for it?!\n&quot;);
+        y = r / WORLD_SIDE_LEN;
+        x = r % WORLD_SIDE_LEN;
+        r = spiral_find_2x2(x, y);
+        if (r == -1) {
+#ifdef commentout               /* see above */
+            printf(&quot;Adding a shanty (r), no space for it?!\n&quot;);
 #endif
-	  return;
-	}
-      y = r / WORLD_SIDE_LEN;
-      x = r % WORLD_SIDE_LEN;
+            return;
+        }
+        y = r / WORLD_SIDE_LEN;
+        x = r % WORLD_SIDE_LEN;
     }
-  set_mappoint (x, y, CST_SHANTY);
-  numof_shanties++;
+    set_mappoint(x, y, CST_SHANTY);
+    numof_shanties++;
 }
 
-void remove_a_shanty (int x, int y)
+void remove_a_shanty(int x, int y)
 {
     numof_shanties--;
     /* ATTENTION:
      * fire_area calls bulldoze_item which calls remove shanty.
      */
-    do_bulldoze_area(CST_FIRE_1,x,y);
+    do_bulldoze_area(CST_FIRE_1, x, y);
 }
 
-void
-update_shanty (void)
+void update_shanty(void)
 {
-  int i, pp;
-  pp = people_pool - (COMMUNE_POP * numof_communes);
-  i = (pp - SHANTY_MIN_PP) / SHANTY_POP;
-  if (i &gt; numof_shanties) {
-      add_a_shanty ();
-  } else if ( numof_shanties &gt; 0 &amp;&amp; 
-                    ( i &lt; (numof_shanties - 1) || rand () % 100 == 1) ) {
+    int i, pp;
+    pp = people_pool - (COMMUNE_POP * numof_communes);
+    i = (pp - SHANTY_MIN_PP) / SHANTY_POP;
+    if (i &gt; numof_shanties) {
+        add_a_shanty();
+    } else if (numof_shanties &gt; 0 &amp;&amp; (i &lt; (numof_shanties - 1) || rand() % 100 == 1)) {
         int x, y, r;
-        x = rand () % WORLD_SIDE_LEN;
-        y = rand () % WORLD_SIDE_LEN;
-        r = spiral_find_group (x, y, GROUP_SHANTY);
+        x = rand() % WORLD_SIDE_LEN;
+        y = rand() % WORLD_SIDE_LEN;
+        r = spiral_find_group(x, y, GROUP_SHANTY);
         if (r == -1) {
-            fprintf (stderr,&quot;Can't find a shanty to remove!\n&quot;);
+            fprintf(stderr, &quot;Can't find a shanty to remove!\n&quot;);
             return;
         }
         y = r / WORLD_SIDE_LEN;
         x = r % WORLD_SIDE_LEN;
-        remove_a_shanty(x,y);  /* this will fire_area */
+        remove_a_shanty(x, y);  /* this will fire_area */
         /* now put the fire out: it becomes impossible to bulldoze */
-        MP_INFO(x,y).int_2 = FIRE_LENGTH + 1;
-        MP_INFO(x + 1,y).int_2 = FIRE_LENGTH + 1;
-        MP_INFO(x,y + 1).int_2 = FIRE_LENGTH + 1;
-        MP_INFO(x + 1,y + 1).int_2 = FIRE_LENGTH + 1;
-  }
+        MP_INFO(x, y).int_2 = FIRE_LENGTH + 1;
+        MP_INFO(x + 1, y).int_2 = FIRE_LENGTH + 1;
+        MP_INFO(x, y + 1).int_2 = FIRE_LENGTH + 1;
+        MP_INFO(x + 1, y + 1).int_2 = FIRE_LENGTH + 1;
+    }
 }
 
-void
-do_shanty (int x, int y)
-{				/* just steal some stuff and make pollution. */
+void do_shanty(int x, int y)
+{                               /* just steal some stuff and make pollution. */
 
-  get_food (x, y, SHANTY_GET_FOOD);
-  if (get_goods (x, y, SHANTY_GET_GOODS) != 0)
-    if ((goods_tax -= SHANTY_GET_GOODS * 2) &lt; 0)
-      goods_tax = 0;
-  get_ore (x, y, SHANTY_GET_ORE);
-  get_steel (x, y, SHANTY_GET_STEEL);
-  if (get_jobs (x, y, SHANTY_GET_JOBS) != 0)
-    if ((income_tax -= SHANTY_GET_JOBS * 2) &lt; 0)
-      income_tax = 0;
-  if (get_coal (x, y, SHANTY_GET_COAL) != 0)
-    if ((coal_tax -= SHANTY_GET_COAL * 2) &lt; 0)
-      coal_tax = 0;
-  if ((total_time &amp; 1) == 0)
-    MP_POL(x,y)++;
-  else
-    MP_POL(x+1,y+1)++;
+    get_food(x, y, SHANTY_GET_FOOD);
+    if (get_goods(x, y, SHANTY_GET_GOODS) != 0)
+        if ((goods_tax -= SHANTY_GET_GOODS * 2) &lt; 0)
+            goods_tax = 0;
+    get_ore(x, y, SHANTY_GET_ORE);
+    get_steel(x, y, SHANTY_GET_STEEL);
+    if (get_jobs(x, y, SHANTY_GET_JOBS) != 0)
+        if ((income_tax -= SHANTY_GET_JOBS * 2) &lt; 0)
+            income_tax = 0;
+    if (get_coal(x, y, SHANTY_GET_COAL) != 0)
+        if ((coal_tax -= SHANTY_GET_COAL * 2) &lt; 0)
+            coal_tax = 0;
+    if ((total_time &amp; 1) == 0)
+        MP_POL(x, y)++;
+    else
+        MP_POL(x + 1, y + 1)++;
 }

Modified: trunk/src/lincity/modules/solar_power.cpp
===================================================================
--- trunk/src/lincity/modules/solar_power.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/solar_power.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -21,46 +21,42 @@
   int_7 is a grid mapping timestamp
 */
 
-void
-do_power_source (int x, int y)
+void do_power_source(int x, int y)
 {
     /* Al1: fix for stupid bug i introduced before 1.1.1 =&gt; int1 and int3 had wrong valued as if tech = 0 ! */
-    MP_INFO(x,y).int_1 = (int)(POWERS_SOLAR_OUTPUT
-            + (((double) MP_INFO(x,y).int_2 * POWERS_SOLAR_OUTPUT) / MAX_TECH_LEVEL));
-    MP_INFO(x,y).int_3 = MP_INFO(x,y).int_1;
+    MP_INFO(x, y).int_1 = (int)(POWERS_SOLAR_OUTPUT
+                                + (((double)MP_INFO(x, y).int_2 * POWERS_SOLAR_OUTPUT) / MAX_TECH_LEVEL));
+    MP_INFO(x, y).int_3 = MP_INFO(x, y).int_1;
     /* end of fix */
 
     if (get_jobs(x, y, SOLAR_POWER_JOBS)) {
-	MP_INFO(x,y).int_5 = MP_INFO(x,y).int_3;
-	grid[MP_INFO(x,y).int_6]-&gt;avail_power += MP_INFO(x,y).int_3;
+        MP_INFO(x, y).int_5 = MP_INFO(x, y).int_3;
+        grid[MP_INFO(x, y).int_6]-&gt;avail_power += MP_INFO(x, y).int_3;
     } else {
-	MP_INFO(x,y).int_5 = 0;
+        MP_INFO(x, y).int_5 = 0;
     }
 }
 
-
-void
-mps_solar_power (int x, int y)
+void mps_solar_power(int x, int y)
 {
-  int i = 0;
+    int i = 0;
 
-  char s[12];
+    char s[12];
 
-  mps_store_title(i++,_(&quot;Solar&quot;));
-  mps_store_title(i++,_(&quot;Power Station&quot;));
-  i++;
+    mps_store_title(i++, _(&quot;Solar&quot;));
+    mps_store_title(i++, _(&quot;Power Station&quot;));
+    i++;
 
-  format_power (s, sizeof(s), MP_INFO(x,y).int_3);
-  mps_store_title(i++,_(&quot;Max Output&quot;));
-  mps_store_title(i++,s);
-  i++;
+    format_power(s, sizeof(s), MP_INFO(x, y).int_3);
+    mps_store_title(i++, _(&quot;Max Output&quot;));
+    mps_store_title(i++, s);
+    i++;
 
-  format_power (s, sizeof(s), MP_INFO(x,y).int_5);
-  mps_store_title(i++,_(&quot;Current Output&quot;));
-  mps_store_title(i++,s);
-  i++;
+    format_power(s, sizeof(s), MP_INFO(x, y).int_5);
+    mps_store_title(i++, _(&quot;Current Output&quot;));
+    mps_store_title(i++, s);
+    i++;
 
-  mps_store_sfp(i++,_(&quot;Tech&quot;),
-		MP_INFO(x,y).int_2 * 100.0 / MAX_TECH_LEVEL);  
-  mps_store_sd(i++,_(&quot;Grid ID&quot;), MP_INFO(x,y).int_6);
+    mps_store_sfp(i++, _(&quot;Tech&quot;), MP_INFO(x, y).int_2 * 100.0 / MAX_TECH_LEVEL);
+    mps_store_sd(i++, _(&quot;Grid ID&quot;), MP_INFO(x, y).int_6);
 }

Modified: trunk/src/lincity/modules/substation.cpp
===================================================================
--- trunk/src/lincity/modules/substation.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/substation.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -23,97 +23,93 @@
  * int_7 is a grid timestamp
  */
 
-void 
-do_power_substation (int x, int y) 
+void do_power_substation(int x, int y)
 {
-    switch(grid[MP_INFO(x,y).int_6]-&gt;powered) {
-    case -1: {
-	MP_TYPE(x,y) = CST_SUBSTATION_R; 
-    } break;
-    case 0 : {
-	MP_TYPE(x,y) = CST_SUBSTATION_RG;
-    } break;
-    case 1 : {
-	MP_TYPE(x,y) = CST_SUBSTATION_G;
-    } break;
-    default : {
-	printf(&quot;Default case in do_power_substation\n&quot;);
-    } break;
+    switch (grid[MP_INFO(x, y).int_6]-&gt;powered) {
+    case -1:{
+            MP_TYPE(x, y) = CST_SUBSTATION_R;
+        }
+        break;
+    case 0:{
+            MP_TYPE(x, y) = CST_SUBSTATION_RG;
+        }
+        break;
+    case 1:{
+            MP_TYPE(x, y) = CST_SUBSTATION_G;
+        }
+        break;
+    default:{
+            printf(&quot;Default case in do_power_substation\n&quot;);
+        }
+        break;
     }
 }
 
-int
-add_a_substation (int x, int y)	/* add to substationx substationy to list */
-{
-  if (numof_substations &gt;= MAX_NUMOF_SUBSTATIONS)
-    return (0);
-  substationx[numof_substations] = x;
-  substationy[numof_substations] = y;
-  numof_substations++;
-  return (1);
+int add_a_substation(int x, int y)
+{                               /* add to substationx substationy to list */
+    if (numof_substations &gt;= MAX_NUMOF_SUBSTATIONS)
+        return (0);
+    substationx[numof_substations] = x;
+    substationy[numof_substations] = y;
+    numof_substations++;
+    return (1);
 }
 
-void
-remove_a_substation (int x, int y)
+void remove_a_substation(int x, int y)
 {
-  int q;
-  for (q = 0; q &lt; numof_substations; q++)
-    if (substationx[q] == x &amp;&amp; substationy[q] == y)
-      break;
-  for (; q &lt; numof_substations; q++)
-    {
-      substationx[q] = substationx[q + 1];
-      substationy[q] = substationy[q + 1];
+    int q;
+    for (q = 0; q &lt; numof_substations; q++)
+        if (substationx[q] == x &amp;&amp; substationy[q] == y)
+            break;
+    for (; q &lt; numof_substations; q++) {
+        substationx[q] = substationx[q + 1];
+        substationy[q] = substationy[q + 1];
     }
-  numof_substations--;
+    numof_substations--;
 }
 
-void
-shuffle_substations (void)
+void shuffle_substations(void)
 {
-  int q, x, r, m;
-  m = (numof_substations / 2) + 1;
-  for (x = 0; x &lt; m; x++)
-    {
-      r = rand () % numof_substations;
-      if (r == x)
-	continue;
-      q = substationx[x];
-      substationx[x] = substationx[r];
-      substationx[r] = q;
-      q = substationy[x];
-      substationy[x] = substationy[r];
-      substationy[r] = q;
+    int q, x, r, m;
+    m = (numof_substations / 2) + 1;
+    for (x = 0; x &lt; m; x++) {
+        r = rand() % numof_substations;
+        if (r == x)
+            continue;
+        q = substationx[x];
+        substationx[x] = substationx[r];
+        substationx[r] = q;
+        q = substationy[x];
+        substationy[x] = substationy[r];
+        substationy[r] = q;
     }
 }
 
-void
-mps_substation (int x, int y)
+void mps_substation(int x, int y)
 {
     int i = 0;
     char s[12];
-    
-    mps_store_title(i++,_(&quot;Substation&quot;));
+
+    mps_store_title(i++, _(&quot;Substation&quot;));
     i++;
 
-    format_power (s, sizeof(s), MP_INFO(x,y).int_4);    
-    mps_store_title(i++,_(&quot;Local Demand&quot;));
-    mps_store_title(i++,s);
+    format_power(s, sizeof(s), MP_INFO(x, y).int_4);
+    mps_store_title(i++, _(&quot;Local Demand&quot;));
+    mps_store_title(i++, s);
     i++;
 
-    mps_store_title(i++,_(&quot;Grid Status&quot;));
+    mps_store_title(i++, _(&quot;Grid Status&quot;));
 
-    format_power (s, sizeof(s), grid[MP_INFO(x,y).int_6]-&gt;max_power);
-    mps_store_ss(i++,_(&quot;T. Cap.&quot;), s);
+    format_power(s, sizeof(s), grid[MP_INFO(x, y).int_6]-&gt;max_power);
+    mps_store_ss(i++, _(&quot;T. Cap.&quot;), s);
 
-    format_power (s, sizeof(s), grid[MP_INFO(x,y).int_6]-&gt;avail_power);
-    mps_store_ss(i++,_(&quot;A. Cap.&quot;), s);
-    
-    format_power (s, sizeof(s), grid[MP_INFO(x,y).int_6]-&gt;demand);
-    mps_store_ss(i++,_(&quot;Demand&quot;), s);
+    format_power(s, sizeof(s), grid[MP_INFO(x, y).int_6]-&gt;avail_power);
+    mps_store_ss(i++, _(&quot;A. Cap.&quot;), s);
+
+    format_power(s, sizeof(s), grid[MP_INFO(x, y).int_6]-&gt;demand);
+    mps_store_ss(i++, _(&quot;Demand&quot;), s);
     i++;
 
-    mps_store_sd(i++,_(&quot;Grid ID&quot;), MP_INFO(x,y).int_6);
+    mps_store_sd(i++, _(&quot;Grid ID&quot;), MP_INFO(x, y).int_6);
 
-
 }

Modified: trunk/src/lincity/modules/substation.h
===================================================================
--- trunk/src/lincity/modules/substation.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/substation.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -13,7 +13,6 @@
 void remove_a_substation(int x, int y);
 void shuffle_substations(void);
 
-void mps_substation (int x, int y);
+void mps_substation(int x, int y);
 
-
 #endif /* __substation_h__ */

Modified: trunk/src/lincity/modules/tip.cpp
===================================================================
--- trunk/src/lincity/modules/tip.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/tip.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -8,117 +8,107 @@
 #include &quot;modules.h&quot;
 #include &quot;tip.h&quot;
 
-
-void
-do_tip (int x, int y)
+void do_tip(int x, int y)
 {
-  /*
-     // int_1 is the amount of waste on the site.
-     // int_2 if the amount that has flowed in so far this month
-     // int_3 is the amount stored last month.
-     // int_4 counts up starting when tip fills, controlling how
-              long until the land is useful again.
-   */
-  int i;
+    /*
+       // int_1 is the amount of waste on the site.
+       // int_2 if the amount that has flowed in so far this month
+       // int_3 is the amount stored last month.
+       // int_4 counts up starting when tip fills, controlling how
+       long until the land is useful again.
+     */
+    int i;
 
 /* XXX: put this in a header somewhere */
 
 /* If the tip is full, age it until it degrades into useful soil */
 
-  if (MP_TYPE(x,y) == CST_TIP_8) {
-      MP_INFO(x,y).int_4++;
-      if (MP_INFO(x,y).int_4 &gt;= TIP_DEGRADE_TIME) {
-          if (use_waterwell) {
-              do_bulldoze_area (CST_DESERT, x, y);
-          } else {
-              do_bulldoze_area(CST_GREEN,x,y);
-          }
-      }
-      return;
-  }
+    if (MP_TYPE(x, y) == CST_TIP_8) {
+        MP_INFO(x, y).int_4++;
+        if (MP_INFO(x, y).int_4 &gt;= TIP_DEGRADE_TIME) {
+            if (use_waterwell) {
+                do_bulldoze_area(CST_DESERT, x, y);
+            } else {
+                do_bulldoze_area(CST_GREEN, x, y);
+            }
+        }
+        return;
+    }
 
-  /* just grab as much as we can from transport */
-  if (x &gt; 0 &amp;&amp; (MP_INFO(x - 1,y).flags &amp; FLAG_IS_TRANSPORT) != 0)
-    {
-      i = MP_INFO(x - 1,y).int_7 / 10;
-      MP_INFO(x,y).int_1 += i;
-      MP_INFO(x,y).int_2 += i;
-      MP_INFO(x - 1,y).int_7 -= i * 10;
-      sust_dig_ore_coal_tip_flag = 0;
+    /* just grab as much as we can from transport */
+    if (x &gt; 0 &amp;&amp; (MP_INFO(x - 1, y).flags &amp; FLAG_IS_TRANSPORT) != 0) {
+        i = MP_INFO(x - 1, y).int_7 / 10;
+        MP_INFO(x, y).int_1 += i;
+        MP_INFO(x, y).int_2 += i;
+        MP_INFO(x - 1, y).int_7 -= i * 10;
+        sust_dig_ore_coal_tip_flag = 0;
     }
-  if (y &gt; 0 &amp;&amp; (MP_INFO(x,y - 1).flags &amp; FLAG_IS_TRANSPORT) != 0)
-    {
-      i = MP_INFO(x,y - 1).int_7 / 10;
-      MP_INFO(x,y).int_1 += i;
-      MP_INFO(x,y).int_2 += i;
-      MP_INFO(x,y - 1).int_7 -= i * 10;
-      sust_dig_ore_coal_tip_flag = 0;
+    if (y &gt; 0 &amp;&amp; (MP_INFO(x, y - 1).flags &amp; FLAG_IS_TRANSPORT) != 0) {
+        i = MP_INFO(x, y - 1).int_7 / 10;
+        MP_INFO(x, y).int_1 += i;
+        MP_INFO(x, y).int_2 += i;
+        MP_INFO(x, y - 1).int_7 -= i * 10;
+        sust_dig_ore_coal_tip_flag = 0;
     }
-
 #if defined (commentout)
-  /* Increment the &quot;ore&quot; reserve; this prevents a new tip from being
-     built on top of a degraded one. */
-  MP_INFO(x,y).ore_reserve++;
+    /* Increment the &quot;ore&quot; reserve; this prevents a new tip from being
+       built on top of a degraded one. */
+    MP_INFO(x, y).ore_reserve++;
 #endif
 
-  /* now choose an icon. */
-  if ((total_time % NUMOF_DAYS_IN_MONTH) == 0)
-    {
-      i = (MP_INFO(x,y).int_1 * 7) / MAX_WASTE_AT_TIP;
-      if (MP_INFO(x,y).int_1 &gt; 0)
-	i++;
-      switch (i)
-	{
-	case (0):
-	  MP_TYPE(x,y) = CST_TIP_0;
-	  break;
-	case (1):
-	  MP_TYPE(x,y) = CST_TIP_1;
-	  break;
-	case (2):
-	  MP_TYPE(x,y) = CST_TIP_2;
-	  break;
-	case (3):
-	  MP_TYPE(x,y) = CST_TIP_3;
-	  break;
-	case (4):
-	  MP_TYPE(x,y) = CST_TIP_4;
-	  break;
-	case (5):
-	  MP_TYPE(x,y) = CST_TIP_5;
-	  break;
-	case (6):
-	  MP_TYPE(x,y) = CST_TIP_6;
-	  break;
-	case (7):
-	  MP_TYPE(x,y) = CST_TIP_7;
-	  break;
-	case (8):
-	  MP_TYPE(x,y) = CST_TIP_8;
-	  MP_INFO(x,y).int_2 = 0;
-	  MP_INFO(x,y).int_4 = 0;
-	  break;
+    /* now choose an icon. */
+    if ((total_time % NUMOF_DAYS_IN_MONTH) == 0) {
+        i = (MP_INFO(x, y).int_1 * 7) / MAX_WASTE_AT_TIP;
+        if (MP_INFO(x, y).int_1 &gt; 0)
+            i++;
+        switch (i) {
+        case (0):
+            MP_TYPE(x, y) = CST_TIP_0;
+            break;
+        case (1):
+            MP_TYPE(x, y) = CST_TIP_1;
+            break;
+        case (2):
+            MP_TYPE(x, y) = CST_TIP_2;
+            break;
+        case (3):
+            MP_TYPE(x, y) = CST_TIP_3;
+            break;
+        case (4):
+            MP_TYPE(x, y) = CST_TIP_4;
+            break;
+        case (5):
+            MP_TYPE(x, y) = CST_TIP_5;
+            break;
+        case (6):
+            MP_TYPE(x, y) = CST_TIP_6;
+            break;
+        case (7):
+            MP_TYPE(x, y) = CST_TIP_7;
+            break;
+        case (8):
+            MP_TYPE(x, y) = CST_TIP_8;
+            MP_INFO(x, y).int_2 = 0;
+            MP_INFO(x, y).int_4 = 0;
+            break;
 
-	}
-      MP_INFO(x,y).int_3 = MP_INFO(x,y).int_2;
-      MP_INFO(x,y).int_2 = 0;
+        }
+        MP_INFO(x, y).int_3 = MP_INFO(x, y).int_2;
+        MP_INFO(x, y).int_2 = 0;
     }
 }
 
-void
-mps_tip (int x, int y)
+void mps_tip(int x, int y)
 {
-  int i = 0;
+    int i = 0;
 
-  mps_store_title(i++,_(&quot;Landfill&quot;));
-  i++;
+    mps_store_title(i++, _(&quot;Landfill&quot;));
+    i++;
 
-  mps_store_title(i++,_(&quot;Last Month&quot;));
-  mps_store_sd(i++,_(&quot;Tons&quot;), MP_INFO(x,y).int_3);
-  mps_store_sfp(i++,_(&quot;Percent&quot;), 
-	       MP_INFO(x,y).int_3 * 100.0 / MAX_WASTE_AT_TIP);
-  i++;
-  mps_store_title(i++,_(&quot;% Filled&quot;));
-  mps_store_fp(i++,
-	       MP_INFO(x,y).int_1 * 100.0 / MAX_WASTE_AT_TIP);
+    mps_store_title(i++, _(&quot;Last Month&quot;));
+    mps_store_sd(i++, _(&quot;Tons&quot;), MP_INFO(x, y).int_3);
+    mps_store_sfp(i++, _(&quot;Percent&quot;), MP_INFO(x, y).int_3 * 100.0 / MAX_WASTE_AT_TIP);
+    i++;
+    mps_store_title(i++, _(&quot;% Filled&quot;));
+    mps_store_fp(i++, MP_INFO(x, y).int_1 * 100.0 / MAX_WASTE_AT_TIP);
 }

Modified: trunk/src/lincity/modules/tip.h
===================================================================
--- trunk/src/lincity/modules/tip.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/tip.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -9,6 +9,6 @@
 #define __tip_h__
 
 void do_tip(int x, int y);
-void mps_tip (int x, int y);
+void mps_tip(int x, int y);
 
 #endif /* __tip_h__ */

Modified: trunk/src/lincity/modules/track.cpp
===================================================================
--- trunk/src/lincity/modules/track.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/track.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -21,36 +21,25 @@
    int_7 contains the amount of waste
   --------------------------------------------------------------------- */
 
-
-void
-do_track (int x, int y)
+void do_track(int x, int y)
 {
     static int wb_count = 0;
-    general_transport (&amp;MP_INFO(x,y), &amp;MP_POL(x,y),
-		       MAX_WASTE_ON_TRACK, &amp;wb_count);
+    general_transport(&amp;MP_INFO(x, y), &amp;MP_POL(x, y), MAX_WASTE_ON_TRACK, &amp;wb_count);
 }
 
-void
-mps_track (int x, int y)
+void mps_track(int x, int y)
 {
-  int i = 0;
+    int i = 0;
 
-  mps_store_title(i++,_(&quot;Track&quot;));
-  i++;
+    mps_store_title(i++, _(&quot;Track&quot;));
+    i++;
 
-  mps_store_sfp(i++,_(&quot;Food&quot;), 
-		MP_INFO(x,y).int_1 * 100.0 / MAX_FOOD_ON_TRACK);
-  mps_store_sfp(i++,_(&quot;Jobs&quot;), 
-		MP_INFO(x,y).int_2 * 100.0 / MAX_JOBS_ON_TRACK);
-  mps_store_sfp(i++,_(&quot;Coal&quot;), 
-		MP_INFO(x,y).int_3 * 100.0 / MAX_COAL_ON_TRACK);
-  mps_store_sfp(i++,_(&quot;Goods&quot;), 
-		MP_INFO(x,y).int_4 * 100.0 / MAX_GOODS_ON_TRACK);
-  mps_store_sfp(i++,_(&quot;Ore&quot;), 
-		MP_INFO(x,y).int_5 * 100.0 / MAX_ORE_ON_TRACK);
-  mps_store_sfp(i++,_(&quot;Steel&quot;), 
-		MP_INFO(x,y).int_6 * 100.0 / MAX_STEEL_ON_TRACK);
-  mps_store_sfp(i++,_(&quot;Waste&quot;), 
-		MP_INFO(x,y).int_7 * 100.0 / MAX_WASTE_ON_TRACK);
+    mps_store_sfp(i++, _(&quot;Food&quot;), MP_INFO(x, y).int_1 * 100.0 / MAX_FOOD_ON_TRACK);
+    mps_store_sfp(i++, _(&quot;Jobs&quot;), MP_INFO(x, y).int_2 * 100.0 / MAX_JOBS_ON_TRACK);
+    mps_store_sfp(i++, _(&quot;Coal&quot;), MP_INFO(x, y).int_3 * 100.0 / MAX_COAL_ON_TRACK);
+    mps_store_sfp(i++, _(&quot;Goods&quot;), MP_INFO(x, y).int_4 * 100.0 / MAX_GOODS_ON_TRACK);
+    mps_store_sfp(i++, _(&quot;Ore&quot;), MP_INFO(x, y).int_5 * 100.0 / MAX_ORE_ON_TRACK);
+    mps_store_sfp(i++, _(&quot;Steel&quot;), MP_INFO(x, y).int_6 * 100.0 / MAX_STEEL_ON_TRACK);
+    mps_store_sfp(i++, _(&quot;Waste&quot;), MP_INFO(x, y).int_7 * 100.0 / MAX_WASTE_ON_TRACK);
 
 }

Modified: trunk/src/lincity/modules/university.cpp
===================================================================
--- trunk/src/lincity/modules/university.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/university.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -9,72 +9,61 @@
 #include &quot;../lcconfig.h&quot;
 #include &quot;university.h&quot;
 
-void
-do_university (int x, int y)
+void do_university(int x, int y)
 {
-  /*
-     // You need UNIVERSITY_JOBS and UNIVERSITY_GOODS to add 1 to tech_level
-     // int_1 is the stored jobs
-     // int_2 is the stored goods
-     // int_3 is the total tech points made by this uni.
-     // int_4 is the count so far in this 100 days
-     // int_5 is the count in the last 100 days to give a percent value
-     // get some jobs
-   */
-  if (MP_INFO(x,y).int_1 &lt; UNIVERSITY_JOBS_STORE)
-    {
-      if (get_jobs (x, y, UNIVERSITY_JOBS + 10) != 0)
-	MP_INFO(x,y).int_1 += UNIVERSITY_JOBS + 10;
+    /*
+       // You need UNIVERSITY_JOBS and UNIVERSITY_GOODS to add 1 to tech_level
+       // int_1 is the stored jobs
+       // int_2 is the stored goods
+       // int_3 is the total tech points made by this uni.
+       // int_4 is the count so far in this 100 days
+       // int_5 is the count in the last 100 days to give a percent value
+       // get some jobs
+     */
+    if (MP_INFO(x, y).int_1 &lt; UNIVERSITY_JOBS_STORE) {
+        if (get_jobs(x, y, UNIVERSITY_JOBS + 10) != 0)
+            MP_INFO(x, y).int_1 += UNIVERSITY_JOBS + 10;
     }
-  /* get goods */
-  if (MP_INFO(x,y).int_2 &lt; UNIVERSITY_GOODS_STORE)
-    {
-      if (get_goods (x, y, UNIVERSITY_GOODS + 10) != 0)
-	MP_INFO(x,y).int_2 += UNIVERSITY_GOODS + 10;
-      else if (get_goods (x, y, UNIVERSITY_GOODS / 5) != 0)
-	MP_INFO(x,y).int_2 += UNIVERSITY_GOODS / 5;
-      else if (get_goods (x, y, UNIVERSITY_GOODS / 20) != 0)
-	MP_INFO(x,y).int_2 += UNIVERSITY_GOODS / 20;
+    /* get goods */
+    if (MP_INFO(x, y).int_2 &lt; UNIVERSITY_GOODS_STORE) {
+        if (get_goods(x, y, UNIVERSITY_GOODS + 10) != 0)
+            MP_INFO(x, y).int_2 += UNIVERSITY_GOODS + 10;
+        else if (get_goods(x, y, UNIVERSITY_GOODS / 5) != 0)
+            MP_INFO(x, y).int_2 += UNIVERSITY_GOODS / 5;
+        else if (get_goods(x, y, UNIVERSITY_GOODS / 20) != 0)
+            MP_INFO(x, y).int_2 += UNIVERSITY_GOODS / 20;
     }
-  /* now do some research */
-  if (MP_INFO(x,y).int_1 &gt;= UNIVERSITY_JOBS
-      &amp;&amp; MP_INFO(x,y).int_2 &gt;= UNIVERSITY_GOODS)
-    {
-      MP_INFO(x,y).int_1 -= UNIVERSITY_JOBS;
-      MP_INFO(x,y).int_2 -= UNIVERSITY_GOODS;
-      goods_used += UNIVERSITY_GOODS;
-      if (university_intake_rate &gt;= (total_time % 100))
-	{
-	  MP_INFO(x,y).int_3 += UNIVERSITY_TECH_MADE;
-	  tech_level += UNIVERSITY_TECH_MADE;
-	  MP_INFO(x,y).int_4++;
-	}
+    /* now do some research */
+    if (MP_INFO(x, y).int_1 &gt;= UNIVERSITY_JOBS &amp;&amp; MP_INFO(x, y).int_2 &gt;= UNIVERSITY_GOODS) {
+        MP_INFO(x, y).int_1 -= UNIVERSITY_JOBS;
+        MP_INFO(x, y).int_2 -= UNIVERSITY_GOODS;
+        goods_used += UNIVERSITY_GOODS;
+        if (university_intake_rate &gt;= (total_time % 100)) {
+            MP_INFO(x, y).int_3 += UNIVERSITY_TECH_MADE;
+            tech_level += UNIVERSITY_TECH_MADE;
+            MP_INFO(x, y).int_4++;
+        }
     }
-  if (total_time % 100 == 0)
-    {
-      MP_INFO(x,y).int_5 = MP_INFO(x,y).int_4;
-      MP_INFO(x,y).int_4 = 0;
+    if (total_time % 100 == 0) {
+        MP_INFO(x, y).int_5 = MP_INFO(x, y).int_4;
+        MP_INFO(x, y).int_4 = 0;
     }
-  university_cost += UNIVERSITY_RUNNING_COST;
+    university_cost += UNIVERSITY_RUNNING_COST;
 }
 
-void
-mps_university (int x, int y)
+void mps_university(int x, int y)
 {
-  int i = 0;
-  char s[12];
+    int i = 0;
+    char s[12];
 
-  mps_store_title(i++,_(&quot;University&quot;));
-  i++;
-  mps_store_title(i++,_(&quot;Tech Produced&quot;));
-  snprintf (s, sizeof(s), &quot;%6.1f&quot;, 
-	    MP_INFO(x,y).int_3 * 100.0 / MAX_TECH_LEVEL);  
-  mps_store_title(i++,s);
-  i++;
-  mps_store_title(i++,_(&quot;Inventory&quot;));
-  mps_store_sfp(i++,_(&quot;Jobs&quot;), 
-		MP_INFO(x,y).int_1 * 100.0 / UNIVERSITY_JOBS_STORE);
-  mps_store_sfp(i++,_(&quot;Goods&quot;),
-		MP_INFO(x,y).int_2 * 100.0 / UNIVERSITY_GOODS_STORE);
-  mps_store_sfp(i++,_(&quot;Capacity&quot;), MP_INFO(x,y).int_4);
+    mps_store_title(i++, _(&quot;University&quot;));
+    i++;
+    mps_store_title(i++, _(&quot;Tech Produced&quot;));
+    snprintf(s, sizeof(s), &quot;%6.1f&quot;, MP_INFO(x, y).int_3 * 100.0 / MAX_TECH_LEVEL);
+    mps_store_title(i++, s);
+    i++;
+    mps_store_title(i++, _(&quot;Inventory&quot;));
+    mps_store_sfp(i++, _(&quot;Jobs&quot;), MP_INFO(x, y).int_1 * 100.0 / UNIVERSITY_JOBS_STORE);
+    mps_store_sfp(i++, _(&quot;Goods&quot;), MP_INFO(x, y).int_2 * 100.0 / UNIVERSITY_GOODS_STORE);
+    mps_store_sfp(i++, _(&quot;Capacity&quot;), MP_INFO(x, y).int_4);
 }

Modified: trunk/src/lincity/modules/water.cpp
===================================================================
--- trunk/src/lincity/modules/water.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/water.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -8,18 +8,15 @@
 #include &quot;modules.h&quot;
 #include &quot;water.h&quot;
 
-
-void
-mps_water (int x, int y)
+void mps_water(int x, int y)
 {
     int i = 0;
 
-    const char * p;
+    const char *p;
 
-    mps_store_title(i++,_(&quot;Water&quot;));
+    mps_store_title(i++, _(&quot;Water&quot;));
     i++;
 
-    p = (MP_INFO(x,y).flags &amp; FLAG_IS_RIVER) ? _(&quot;Yes&quot;) : _(&quot;No&quot;);
-    mps_store_ss(i++,_(&quot;Navigable&quot;),p);
+    p = (MP_INFO(x, y).flags &amp; FLAG_IS_RIVER) ? _(&quot;Yes&quot;) : _(&quot;No&quot;);
+    mps_store_ss(i++, _(&quot;Navigable&quot;), p);
 }
-

Modified: trunk/src/lincity/modules/water.h
===================================================================
--- trunk/src/lincity/modules/water.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/water.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -8,6 +8,6 @@
 #ifndef __water_h__
 #define __water_h__
 
-void mps_water (int x, int y);
+void mps_water(int x, int y);
 
 #endif /* __water_h__ */

Modified: trunk/src/lincity/modules/waterwell.cpp
===================================================================
--- trunk/src/lincity/modules/waterwell.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/waterwell.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -8,51 +8,46 @@
 #include &quot;modules.h&quot;
 #include &quot;waterwell.h&quot;
 
-
-void
-do_waterwell_cover (int x, int y)
+void do_waterwell_cover(int x, int y)
 {
-  int xx, x1, x2, y1, y2;
+    int xx, x1, x2, y1, y2;
 #ifdef DEBUG_WATERWELL
-  if (use_waterwell)
-  	fprintf(stderr,&quot; doing waterwell cover\n&quot;);
-  else 
-  	return;
+    if (use_waterwell)
+        fprintf(stderr, &quot; doing waterwell cover\n&quot;);
+    else
+        return;
 #endif
 
-  x1 = x - WATERWELL_RANGE;
-  if (x1 &lt; 0)
-    x1 = 0;
-  x2 = x + WATERWELL_RANGE;
-  if (x2 &gt; WORLD_SIDE_LEN)
-    x2 = WORLD_SIDE_LEN;
-  y1 = y - WATERWELL_RANGE;
-  if (y1 &lt; 0)
-    y1 = 0;
-  y2 = y + WATERWELL_RANGE;
-  if (y2 &gt; WORLD_SIDE_LEN)
-    y2 = WORLD_SIDE_LEN;
-  for (; y1 &lt; y2; y1++)
-    for (xx = x1; xx &lt; x2; xx++)
-      MP_INFO(xx,y1).flags |= FLAG_WATERWELL_COVER;
+    x1 = x - WATERWELL_RANGE;
+    if (x1 &lt; 0)
+        x1 = 0;
+    x2 = x + WATERWELL_RANGE;
+    if (x2 &gt; WORLD_SIDE_LEN)
+        x2 = WORLD_SIDE_LEN;
+    y1 = y - WATERWELL_RANGE;
+    if (y1 &lt; 0)
+        y1 = 0;
+    y2 = y + WATERWELL_RANGE;
+    if (y2 &gt; WORLD_SIDE_LEN)
+        y2 = WORLD_SIDE_LEN;
+    for (; y1 &lt; y2; y1++)
+        for (xx = x1; xx &lt; x2; xx++)
+            MP_INFO(xx, y1).flags |= FLAG_WATERWELL_COVER;
 }
 
-
-void
-mps_waterwell (int x, int y)
+void mps_waterwell(int x, int y)
 {
     int i = 0;
 
-    const char * p;
+    const char *p;
 
-    mps_store_title(i++,_(&quot;Water_well&quot;));
-    i++; /* blank line */
+    mps_store_title(i++, _(&quot;Water_well&quot;));
+    i++;                        /* blank line */
 
-    mps_store_sd(i++, _(&quot;Pollution&quot;), MP_POL(x,y));
+    mps_store_sd(i++, _(&quot;Pollution&quot;), MP_POL(x, y));
 
     /* p = (MP_INFO(x,y).flags &amp; FLAG_IS_RIVER) ? _(&quot;Yes&quot;) : _(&quot;No&quot;); */
     p = _(&quot;Yes&quot;);
-    mps_store_ss(i++,_(&quot;Drinkable&quot;),p);
+    mps_store_ss(i++, _(&quot;Drinkable&quot;), p);
 
 }
-

Modified: trunk/src/lincity/modules/waterwell.h
===================================================================
--- trunk/src/lincity/modules/waterwell.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/waterwell.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -10,7 +10,7 @@
 
 #undef DEBUG_WATERWELL
 
-void do_waterwell_cover (int x, int y);
-void mps_waterwell (int x, int y);
+void do_waterwell_cover(int x, int y);
+void mps_waterwell(int x, int y);
 
 #endif /* __waterwell_h__ */

Modified: trunk/src/lincity/modules/windmill.cpp
===================================================================
--- trunk/src/lincity/modules/windmill.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/modules/windmill.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -23,87 +23,82 @@
   //  int_2 reserved = y
   //  int_3 is the last real time that a sail was turned
 */
-void
-do_windmill (int x, int y) 
+void do_windmill(int x, int y)
 {
-  int anim_tile; 
+    int anim_tile;
 
-  if (get_jobs (x, y, WINDMILL_JOBS) != 0) {
-    MP_INFO(x,y).int_5 = MP_INFO(x,y).int_1;
-    grid[MP_INFO(x,y).int_6]-&gt;avail_power += MP_INFO(x,y).int_1;
-  } else {
-    MP_INFO(x + 1, y).int_3 = real_time + MODERN_WINDMILL_ANIM_SPEED;
-    return;
-  }
-
-  /* update animation. ATTENTION: (x,y) and (x+1,y) are used to store info */
-  if (real_time &gt; MP_INFO(x + 1, y).int_3) {
-    MP_INFO(x,y).int_3++;
-    if (MP_INFO(x,y).int_2 &lt; MODERN_WINDMILL_TECH) {
-      MP_INFO(x + 1, y).int_3 = real_time + ANTIQUE_WINDMILL_ANIM_SPEED;
+    if (get_jobs(x, y, WINDMILL_JOBS) != 0) {
+        MP_INFO(x, y).int_5 = MP_INFO(x, y).int_1;
+        grid[MP_INFO(x, y).int_6]-&gt;avail_power += MP_INFO(x, y).int_1;
     } else {
-      MP_INFO(x + 1, y).int_3 = real_time + MODERN_WINDMILL_ANIM_SPEED;
+        MP_INFO(x + 1, y).int_3 = real_time + MODERN_WINDMILL_ANIM_SPEED;
+        return;
     }
-  }
 
-  /* figure out which tile to use */
-  anim_tile = (MP_INFO(x,y).int_3 % 3);
+    /* update animation. ATTENTION: (x,y) and (x+1,y) are used to store info */
+    if (real_time &gt; MP_INFO(x + 1, y).int_3) {
+        MP_INFO(x, y).int_3++;
+        if (MP_INFO(x, y).int_2 &lt; MODERN_WINDMILL_TECH) {
+            MP_INFO(x + 1, y).int_3 = real_time + ANTIQUE_WINDMILL_ANIM_SPEED;
+        } else {
+            MP_INFO(x + 1, y).int_3 = real_time + MODERN_WINDMILL_ANIM_SPEED;
+        }
+    }
 
-  if (MP_INFO(x,y).int_2 &lt; MODERN_WINDMILL_TECH)
-    MP_TYPE(x,y) = CST_WINDMILL_1_W + anim_tile;
-  else
-    switch(grid[MP_INFO(x,y).int_6]-&gt;powered) 
-      {
-      case -1: 
-	MP_TYPE(x,y) = CST_WINDMILL_1_R + anim_tile; 
-	break;
-      case 0 : 
-	MP_TYPE(x,y) = CST_WINDMILL_1_RG + anim_tile;
-	break;
-      case 1 : 
-	MP_TYPE(x,y) = CST_WINDMILL_1_G + anim_tile;
-	break;
-      default : 
-	printf(&quot;Default case in do_power_substation\n&quot;);
-	break;
-      }      
+    /* figure out which tile to use */
+    anim_tile = (MP_INFO(x, y).int_3 % 3);
+
+    if (MP_INFO(x, y).int_2 &lt; MODERN_WINDMILL_TECH)
+        MP_TYPE(x, y) = CST_WINDMILL_1_W + anim_tile;
+    else
+        switch (grid[MP_INFO(x, y).int_6]-&gt;powered) {
+        case -1:
+            MP_TYPE(x, y) = CST_WINDMILL_1_R + anim_tile;
+            break;
+        case 0:
+            MP_TYPE(x, y) = CST_WINDMILL_1_RG + anim_tile;
+            break;
+        case 1:
+            MP_TYPE(x, y) = CST_WINDMILL_1_G + anim_tile;
+            break;
+        default:
+            printf(&quot;Default case in do_power_substation\n&quot;);
+            break;
+        }
 }
 
-void
-mps_windmill (int x, int y)
+void mps_windmill(int x, int y)
 {
     int i = 0;
     char s[12];
-    
-    mps_store_title(i++,_(&quot;Windmill&quot;));
-    mps_store_sfp(i++,_(&quot;Tech&quot;),
-		  MP_INFO(x,y).int_2 * 100.0 / MAX_TECH_LEVEL);  
+
+    mps_store_title(i++, _(&quot;Windmill&quot;));
+    mps_store_sfp(i++, _(&quot;Tech&quot;), MP_INFO(x, y).int_2 * 100.0 / MAX_TECH_LEVEL);
     i++;
-   
-    if (MP_INFO(x,y).int_2 &gt;= MODERN_WINDMILL_TECH) {
-	mps_store_title(i++,_(&quot;Local Status&quot;));
 
-	format_power (s, sizeof(s), MP_INFO(x,y).int_5);    
-	mps_store_ss(i++,_(&quot;Prod.&quot;),s);
+    if (MP_INFO(x, y).int_2 &gt;= MODERN_WINDMILL_TECH) {
+        mps_store_title(i++, _(&quot;Local Status&quot;));
 
-	format_power (s, sizeof(s), MP_INFO(x,y).int_4);    
-	mps_store_ss(i++,_(&quot;Demand&quot;),s);
+        format_power(s, sizeof(s), MP_INFO(x, y).int_5);
+        mps_store_ss(i++, _(&quot;Prod.&quot;), s);
 
-	i++;
-	
-	mps_store_title(i++,_(&quot;Grid Status&quot;));
-	
-	format_power (s, sizeof(s), grid[MP_INFO(x,y).int_6]-&gt;max_power);
-	mps_store_ss(i++,_(&quot;T. Cap.&quot;), s);
-	
-	format_power (s, sizeof(s), grid[MP_INFO(x,y).int_6]-&gt;avail_power);
-	mps_store_ss(i++,_(&quot;A. Cap.&quot;), s);
-	
-	format_power (s, sizeof(s), grid[MP_INFO(x,y).int_6]-&gt;demand);
-	mps_store_ss(i++,_(&quot;Demand&quot;), s);
-	i++;
-	
-	mps_store_sd(i++,_(&quot;Grid ID&quot;), MP_INFO(x,y).int_6);
+        format_power(s, sizeof(s), MP_INFO(x, y).int_4);
+        mps_store_ss(i++, _(&quot;Demand&quot;), s);
+
+        i++;
+
+        mps_store_title(i++, _(&quot;Grid Status&quot;));
+
+        format_power(s, sizeof(s), grid[MP_INFO(x, y).int_6]-&gt;max_power);
+        mps_store_ss(i++, _(&quot;T. Cap.&quot;), s);
+
+        format_power(s, sizeof(s), grid[MP_INFO(x, y).int_6]-&gt;avail_power);
+        mps_store_ss(i++, _(&quot;A. Cap.&quot;), s);
+
+        format_power(s, sizeof(s), grid[MP_INFO(x, y).int_6]-&gt;demand);
+        mps_store_ss(i++, _(&quot;Demand&quot;), s);
+        i++;
+
+        mps_store_sd(i++, _(&quot;Grid ID&quot;), MP_INFO(x, y).int_6);
     }
 }
-

Modified: trunk/src/lincity/power.cpp
===================================================================
--- trunk/src/lincity/power.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/power.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -1,9 +1,9 @@
  /* ---------------------------------------------------------------------- *
- * 
- * This file is part of lincity.
- * Lincity is copyright (c) I J Peters 1995-1997, (c) Greg Sharp 1997-2001.
- * (c) Corey Keasling 2001-2004.
- * ---------------------------------------------------------------------- */
+  * 
+  * This file is part of lincity.
+  * Lincity is copyright (c) I J Peters 1995-1997, (c) Greg Sharp 1997-2001.
+  * (c) Corey Keasling 2001-2004.
+  * ---------------------------------------------------------------------- */
 
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
@@ -17,7 +17,7 @@
 #include &quot;simulate.h&quot;
 #include &quot;lcintl.h&quot;
 #include &quot;power.h&quot;
-#include &quot;transport.h&quot; /* for XY_IS_TRANSPORT */
+#include &quot;transport.h&quot;          /* for XY_IS_TRANSPORT */
 
 #include &quot;gui_interface/dialbox_interface.h&quot;
 
@@ -28,88 +28,84 @@
    used to determine if a square has been mapped */
 int grid_inc = 0;
 
-Grid * grid[MAX_GRIDS];
+Grid *grid[MAX_GRIDS];
 
 /* power_time_step 
    Take the avail_power from last timestep, and move in into the 
    total_power, which will be used during this timestep on a first-come 
    first-served basis.
 */
-void
-power_time_step () 
+void power_time_step()
 {
     int gi;
-    int net; /* net power */
+    int net;                    /* net power */
 
     if (grid_num == 0)
-	return;
+        return;
 
     /* AL1: Do we want to shuffle substations ? It is not done in NG 1.1
      *     shuffle_substations();
      */
     for (gi = 1; gi &lt;= grid_num; gi++) {
-	grid[gi]-&gt;total_power = grid[gi]-&gt;avail_power - 
-		(grid[gi]-&gt;power_lines * POWER_LINE_LOSS);
+        grid[gi]-&gt;total_power = grid[gi]-&gt;avail_power - (grid[gi]-&gt;power_lines * POWER_LINE_LOSS);
 
-	net = (grid[gi]-&gt;total_power - grid[gi]-&gt;demand);
+        net = (grid[gi]-&gt;total_power - grid[gi]-&gt;demand);
         /* -&gt;powered is used only for animation of power_lines,
          * substations and windmills
          */
-	if (net &lt; 0)
-	    grid[gi]-&gt;powered = -1;
-	else if (net &lt; (grid[gi]-&gt;avail_power / 4))
-	    grid[gi]-&gt;powered = 0;
-	else 
-	    grid[gi]-&gt;powered = 1;
+        if (net &lt; 0)
+            grid[gi]-&gt;powered = -1;
+        else if (net &lt; (grid[gi]-&gt;avail_power / 4))
+            grid[gi]-&gt;powered = 0;
+        else
+            grid[gi]-&gt;powered = 1;
 
-	grid[gi]-&gt;avail_power = 0;
-	grid[gi]-&gt;demand = 0;
+        grid[gi]-&gt;avail_power = 0;
+        grid[gi]-&gt;demand = 0;
     }
 
     /* Clear substation 'Here' counter */
     /*  int_4 is the local power demand in the substation */
-    for (gi = 0; gi &lt; numof_substations; gi++) 
-	MP_INFO(substationx[gi],substationy[gi]).int_4 = 0;
+    for (gi = 0; gi &lt; numof_substations; gi++)
+        MP_INFO(substationx[gi], substationy[gi]).int_4 = 0;
 }
 
-void 
-map_power_grid (bool resetgrids)
+void map_power_grid(bool resetgrids)
 {
     int mapx, mapy;
-    grid_num = 0;  /* how many grids found so far */
-    grid_inc++; /* how many times have we run map_power_grid */
+    grid_num = 0;               /* how many grids found so far */
+    grid_inc++;                 /* how many times have we run map_power_grid */
 
     // used to fix up bad int_7 values after loading a map
-    if(resetgrids) {
-        for(int mapx = 0; mapx &lt; WORLD_SIDE_LEN; mapx++) {
-            for(int mapy = 0; mapy &lt; WORLD_SIDE_LEN; mapy++) {
-	    	if (XY_IS_GRID(mapx,mapy))
-                	MP_INFO(mapx,mapy).int_7 = grid_inc-1;
+    if (resetgrids) {
+        for (int mapx = 0; mapx &lt; WORLD_SIDE_LEN; mapx++) {
+            for (int mapy = 0; mapy &lt; WORLD_SIDE_LEN; mapy++) {
+                if (XY_IS_GRID(mapx, mapy))
+                    MP_INFO(mapx, mapy).int_7 = grid_inc - 1;
             }
         }
     }
     for (mapx = 0; mapx &lt; WORLD_SIDE_LEN; mapx++) {
-	for (mapy = 0; mapy &lt; WORLD_SIDE_LEN; mapy++) {
-	    if (XY_IS_GRID(mapx,mapy)) {
-		if (MP_INFO(mapx,mapy).int_7 != grid_inc) {
-		    if (grid_num == MAX_GRIDS) {
-			ok_dial_box(&quot;warning.mes&quot;, BAD,
-                                _(&quot;You have too many power grids. Join some of them&quot;));
-			return;
-		    }
-		    grid[++grid_num] = (Grid *)lcalloc(sizeof(Grid));
-		    grid[grid_num]-&gt;total_power = 0;
-		    grid[grid_num]-&gt;power_lines = 0;
-		    grid[grid_num]-&gt;demand = 0;
-		    grid[grid_num]-&gt;max_power = 0;
+        for (mapy = 0; mapy &lt; WORLD_SIDE_LEN; mapy++) {
+            if (XY_IS_GRID(mapx, mapy)) {
+                if (MP_INFO(mapx, mapy).int_7 != grid_inc) {
+                    if (grid_num == MAX_GRIDS) {
+                        ok_dial_box(&quot;warning.mes&quot;, BAD, _(&quot;You have too many power grids. Join some of them&quot;));
+                        return;
+                    }
+                    grid[++grid_num] = (Grid *) lcalloc(sizeof(Grid));
+                    grid[grid_num]-&gt;total_power = 0;
+                    grid[grid_num]-&gt;power_lines = 0;
+                    grid[grid_num]-&gt;demand = 0;
+                    grid[grid_num]-&gt;max_power = 0;
 
-		    recurse_power_grid(mapx,mapy,0);
-		}
-	    }
-	}
+                    recurse_power_grid(mapx, mapy, 0);
+                }
+            }
+        }
     }
 #ifdef DEBUG_POWER
-    printf(&quot;grid_inc: %d found %d grids\n&quot;,grid_inc, grid_num);
+    printf(&quot;grid_inc: %d found %d grids\n&quot;, grid_inc, grid_num);
 #endif
 }
 
@@ -123,162 +119,164 @@
 total.  Now set it to our grid.  If it is a power line, return
 1, otherwise 0. */
 
-int 
-check_grid(int x, int y, int xi, int yi) 
+int check_grid(int x, int y, int xi, int yi)
 {
-  if (XY_IS_GRID(x,y) &amp;&amp; !IS_OLD_WINDMILL(x,y)) {
-    if (GRID_CURRENT(x,y)) {
-        if (MP_INFO(x,y).int_6 != grid_num) {
+    if (XY_IS_GRID(x, y) &amp;&amp; !IS_OLD_WINDMILL(x, y)) {
+        if (GRID_CURRENT(x, y)) {
+            if (MP_INFO(x, y).int_6 != grid_num) {
                 /* XXX: This can occur if connecting to a power source at different
-	         *   locations.
-	         *   Treat a power source or a substation as a power line in order to
+                 *   locations.
+                 *   Treat a power source or a substation as a power line in order to
                  *   have both output with the same grid ID.
-	         */
+                 */
                 return 1;
-        }
-    } else if (!IS_POWER_LINE(x,y)) {
-        if (IS_POWER_SOURCE(x,y)) {
+            }
+        } else if (!IS_POWER_LINE(x, y)) {
+            if (IS_POWER_SOURCE(x, y)) {
                 /* Pick the produced power from power sources */
-                grid[grid_num]-&gt;total_power += MP_INFO(x,y).int_5;
-                grid[grid_num]-&gt;max_power += MP_INFO(x,y).int_1;
+                grid[grid_num]-&gt;total_power += MP_INFO(x, y).int_5;
+                grid[grid_num]-&gt;max_power += MP_INFO(x, y).int_1;
 
-        } /* else = is pure substation */
-        MP_INFO(x,y).int_6 = grid_num;
-        MP_INFO(x,y).int_7 = grid_inc;
-        return 1; /* say power sources and substation are power line */
-    } else /* is a power line */
-        return 1;
+            }                   /* else = is pure substation */
+            MP_INFO(x, y).int_6 = grid_num;
+            MP_INFO(x, y).int_7 = grid_inc;
+            return 1;           /* say power sources and substation are power line */
+        } else                  /* is a power line */
+            return 1;
 
-  } else if (XY_IS_TRANSPORT(x,y) || XY_IS_WATER(x,y)) { /* can we step over?*/
+    } else if (XY_IS_TRANSPORT(x, y) || XY_IS_WATER(x, y)) {    /* can we step over? */
         if (xi == 0 &amp;&amp; yi == 0) /* already stepped */
-                return 0;
-        if (x+xi &gt;= 1 &amp;&amp; x+xi &lt; WORLD_SIDE_LEN &amp;&amp;
-                        y+yi &gt;= 1 &amp;&amp; y+yi &lt; WORLD_SIDE_LEN)
-                return (check_grid(x+xi,y+yi,0,0) ? 2 : 0);
+            return 0;
+        if (x + xi &gt;= 1 &amp;&amp; x + xi &lt; WORLD_SIDE_LEN &amp;&amp; y + yi &gt;= 1 &amp;&amp; y + yi &lt; WORLD_SIDE_LEN)
+            return (check_grid(x + xi, y + yi, 0, 0) ? 2 : 0);
         else
-                return 0;
-  }
-  return 0;
+            return 0;
+    }
+    return 0;
 }
-  
+
 /* Go through the power grid and figure out what is connected.  This
 should really handle the connect_transport bit for power lines.  That
 would help perspicuity anyway. */
 
-void 
-recurse_power_grid (int startx, int starty, int steps) 
+void recurse_power_grid(int startx, int starty, int steps)
 {
-    static int level;             /* debug: levels of recursion encountered */
-    int count = steps;            /* number of steps taken - for animation */
-    short dir = -1;   /* -1 undetermined, 0 nothing left, Direction #defines */
-    int mapx = startx, mapy = starty;                     /* to move about */
-    int inc;           /* handles special case of stepping over transport */
-  
+    static int level;           /* debug: levels of recursion encountered */
+    int count = steps;          /* number of steps taken - for animation */
+    short dir = -1;             /* -1 undetermined, 0 nothing left, Direction #defines */
+    int mapx = startx, mapy = starty;   /* to move about */
+    int inc;                    /* handles special case of stepping over transport */
+
     level++;
     if (count % POWER_MODULUS == 0)
-	count = 0;
+        count = 0;
 
     /* Old windmills aren't grid connected, so they are on their own 'grid'.  We
        ignore them in the main loop.  This case should only be reached from a 
        call from map_power_grid with a new grid_num, not from a new path in the
        code below */
     if (IS_OLD_WINDMILL(mapx, mapy)) {
-	MP_INFO(mapx,mapy).int_6 = grid_num;
-	MP_INFO(mapx,mapy).int_7 = grid_inc;
-	grid[grid_num]-&gt;max_power += MP_INFO(mapx,mapy).int_1;
-	level--;
-	return;
+        MP_INFO(mapx, mapy).int_6 = grid_num;
+        MP_INFO(mapx, mapy).int_7 = grid_inc;
+        grid[grid_num]-&gt;max_power += MP_INFO(mapx, mapy).int_1;
+        level--;
+        return;
     }
 
     /* Crawl about the grid, finding paths and what not.  */
     while (dir != 0) {
-	/* Set to current grid */
-	/* figure out what we are on */
-	if (IS_POWER_LINE(mapx,mapy)) {
-	    grid[grid_num]-&gt;power_lines++;
-	    MP_INFO(mapx,mapy).int_5 = (count++ % POWER_MODULUS);
-	    if ((MP_TYPE(mapx,mapy) &gt;= 1) &amp;&amp; (MP_TYPE(mapx,mapy) &lt;= 11))
-		MP_TYPE(mapx,mapy) += 11;
-	}
-	MP_INFO(mapx,mapy).int_6 = grid_num;
-	MP_INFO(mapx,mapy).int_7 = grid_inc;
+        /* Set to current grid */
+        /* figure out what we are on */
+        if (IS_POWER_LINE(mapx, mapy)) {
+            grid[grid_num]-&gt;power_lines++;
+            MP_INFO(mapx, mapy).int_5 = (count++ % POWER_MODULUS);
+            if ((MP_TYPE(mapx, mapy) &gt;= 1) &amp;&amp; (MP_TYPE(mapx, mapy) &lt;= 11))
+                MP_TYPE(mapx, mapy) += 11;
+        }
+        MP_INFO(mapx, mapy).int_6 = grid_num;
+        MP_INFO(mapx, mapy).int_7 = grid_inc;
 
-	/* For each direction, check map bounds, check if there is power stuff
-	   there, then either remember to follow it later or start a new
-	   recursion to follow the path now */
+        /* For each direction, check map bounds, check if there is power stuff
+           there, then either remember to follow it later or start a new
+           recursion to follow the path now */
 
-	/* West */
-	if (mapx &gt;= 1)
-	    if ((inc = check_grid(mapx - 1, mapy, -1, 0)))
-		if (dir &lt; 1)
-		    dir = WEST;
-		else
-		    recurse_power_grid(mapx - inc, mapy, count + 1);
-	/* North */
-	if (mapy &gt;= 1) 
-	    if ((inc = check_grid(mapx, mapy - 1, 0, -1)))
-		if (dir &lt; 1)
-		    dir = NORTH;
-		else
-		    recurse_power_grid(mapx, mapy - inc, count + 1);
-	/* East */    
-	if (mapx &lt; WORLD_SIDE_LEN)
-	    if ((inc = check_grid(mapx + 1, mapy, 1, 0)))
-		if (dir &lt; 1)
-		    dir = EAST;
-		else 
-		    recurse_power_grid(mapx + inc, mapy, count + 1);
-	/* South */    
-	if (mapy &lt; WORLD_SIDE_LEN)
-	    if ((inc = check_grid(mapx, mapy + 1, 0, 1)))
-		if (dir &lt; 1)
-		    dir = SOUTH;
-		else 
-		    recurse_power_grid(mapx, mapy + inc, count + 1);
+        /* West */
+        if (mapx &gt;= 1)
+            if ((inc = check_grid(mapx - 1, mapy, -1, 0)))
+                if (dir &lt; 1)
+                    dir = WEST;
+                else
+                    recurse_power_grid(mapx - inc, mapy, count + 1);
+        /* North */
+        if (mapy &gt;= 1)
+            if ((inc = check_grid(mapx, mapy - 1, 0, -1)))
+                if (dir &lt; 1)
+                    dir = NORTH;
+                else
+                    recurse_power_grid(mapx, mapy - inc, count + 1);
+        /* East */
+        if (mapx &lt; WORLD_SIDE_LEN)
+            if ((inc = check_grid(mapx + 1, mapy, 1, 0)))
+                if (dir &lt; 1)
+                    dir = EAST;
+                else
+                    recurse_power_grid(mapx + inc, mapy, count + 1);
+        /* South */
+        if (mapy &lt; WORLD_SIDE_LEN)
+            if ((inc = check_grid(mapx, mapy + 1, 0, 1)))
+                if (dir &lt; 1)
+                    dir = SOUTH;
+                else
+                    recurse_power_grid(mapx, mapy + inc, count + 1);
 
-	/* Move to a new square if the chosen direction is not already mapped. */
-	switch (dir) {
-	case (-1):  /* Didn't find one, must not be any.  Stop looping */ 
-	    {
-		dir = 0; 
-	    } break;
-	case WEST: {
-		if (mapx &gt;= 1)
-		    if ((inc = check_grid(mapx - 1, mapy, -1, 0))) {
-			mapx -= inc;
-			dir = -1;
-		    } else
-			dir = 0;
-	    } break;
-	case NORTH: {
-		if (mapy &gt;= 1)
-		    if ((inc = check_grid(mapx, mapy - 1, 0, -1))) {
-			mapy -= inc;
-			dir = -1;
-		    } else
-			dir = 0;
-	    } break;
-	case EAST: {
-		if (mapx &lt; WORLD_SIDE_LEN)
-		    if ((inc = check_grid(mapx + 1, mapy, 1, 0))) {
-			mapx += inc;
-			dir = -1;
-		    } else
-			dir = 0;
-	    } break;
-	case SOUTH: { 
-		if (mapy &lt; WORLD_SIDE_LEN)
-		    if ((inc = check_grid(mapx, mapy + 1, 0, 1))) {
-			mapy += inc;
-			dir = -1;
-		    } else
-			dir = 0;
-	    } break;
-	} /* switch dir */
-    } /* while dir !=0 */
+        /* Move to a new square if the chosen direction is not already mapped. */
+        switch (dir) {
+        case (-1):             /* Didn't find one, must not be any.  Stop looping */
+            {
+                dir = 0;
+            }
+            break;
+        case WEST:{
+                if (mapx &gt;= 1)
+                    if ((inc = check_grid(mapx - 1, mapy, -1, 0))) {
+                        mapx -= inc;
+                        dir = -1;
+                    } else
+                        dir = 0;
+            }
+            break;
+        case NORTH:{
+                if (mapy &gt;= 1)
+                    if ((inc = check_grid(mapx, mapy - 1, 0, -1))) {
+                        mapy -= inc;
+                        dir = -1;
+                    } else
+                        dir = 0;
+            }
+            break;
+        case EAST:{
+                if (mapx &lt; WORLD_SIDE_LEN)
+                    if ((inc = check_grid(mapx + 1, mapy, 1, 0))) {
+                        mapx += inc;
+                        dir = -1;
+                    } else
+                        dir = 0;
+            }
+            break;
+        case SOUTH:{
+                if (mapy &lt; WORLD_SIDE_LEN)
+                    if ((inc = check_grid(mapx, mapy + 1, 0, 1))) {
+                        mapy += inc;
+                        dir = -1;
+                    } else
+                        dir = 0;
+            }
+            break;
+        }                       /* switch dir */
+    }                           /* while dir !=0 */
 
     level--;
-    /*  printf(&quot;exiting recurse_power_grid:level %d\n&quot;,level);*/
+    /*  printf(&quot;exiting recurse_power_grid:level %d\n&quot;,level); */
 }
 
 /* get_power
@@ -287,44 +285,41 @@
    and then try and get power from it's grid.  If we can't, continue.
 */
 
-int 
-get_power (int x, int y, int power, int block_industry)
+int get_power(int x, int y, int power, int block_industry)
 {
-  /* block_industry = 1 for industries and recyclers */
-  int i;
-  int xi, yi;
-  int grid_tmp; /* for simplicity */
+    /* block_industry = 1 for industries and recyclers */
+    int i;
+    int xi, yi;
+    int grid_tmp;               /* for simplicity */
 
-  MP_INFO(x,y).flags |= FLAG_ASKED_FOR_POWER;
-  if (numof_substations == 0)
-    return(0);
+    MP_INFO(x, y).flags |= FLAG_ASKED_FOR_POWER;
+    if (numof_substations == 0)
+        return (0);
 
-  for (i = 0; i &lt; numof_substations; i++) 
-    {
-      xi = substationx[i];
-      yi = substationy[i];
-      if (abs (xi - x) &lt; SUBSTATION_RANGE &amp;&amp; 
-	  abs (yi - y) &lt; SUBSTATION_RANGE) {
+    for (i = 0; i &lt; numof_substations; i++) {
+        xi = substationx[i];
+        yi = substationy[i];
+        if (abs(xi - x) &lt; SUBSTATION_RANGE &amp;&amp; abs(yi - y) &lt; SUBSTATION_RANGE) {
 
-	if (block_industry != 0 &amp;&amp; MP_GROUP(xi, yi) == GROUP_WINDMILL)
-	  continue;
+            if (block_industry != 0 &amp;&amp; MP_GROUP(xi, yi) == GROUP_WINDMILL)
+                continue;
 
-	grid_tmp = MP_INFO(xi,yi).int_6;
+            grid_tmp = MP_INFO(xi, yi).int_6;
 
-        /* FIXME: in case of unsatisfied demand, the demand may be counted 
-         * several times in differents substations (in the same grid or not)
-         * and thus diplayed informations are misleading.
-         */
-	grid[grid_tmp]-&gt;demand += power;
+            /* FIXME: in case of unsatisfied demand, the demand may be counted 
+             * several times in differents substations (in the same grid or not)
+             * and thus diplayed informations are misleading.
+             */
+            grid[grid_tmp]-&gt;demand += power;
 
-	if (grid[grid_tmp]-&gt;total_power &gt;= power) {
-	  grid[grid_tmp]-&gt;total_power -= power;
-	  MP_INFO(xi,yi).int_4 += power; // local demand in substation xi yi
-          MP_INFO(x,y).flags |= FLAG_GOT_POWER;
-	  return 1;
-	}
-	
-      }
+            if (grid[grid_tmp]-&gt;total_power &gt;= power) {
+                grid[grid_tmp]-&gt;total_power -= power;
+                MP_INFO(xi, yi).int_4 += power; // local demand in substation xi yi
+                MP_INFO(x, y).flags |= FLAG_GOT_POWER;
+                return 1;
+            }
+
+        }
     }
-  return 0;
+    return 0;
 }

Modified: trunk/src/lincity/power.h
===================================================================
--- trunk/src/lincity/power.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/power.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -4,36 +4,36 @@
 #undef DEBUG_POWER
 
 struct grid_struct {
-  int power_lines;
-  long total_power; 
-  long avail_power; /* Capacity available */
-  long max_power;
-  long demand;
-  short powered;
+    int power_lines;
+    long total_power;
+    long avail_power;           /* Capacity available */
+    long max_power;
+    long demand;
+    short powered;
 };
 
 typedef struct grid_struct Grid;
 
 /* public */
-#define MAX_GRIDS 128 // How many grids in the array, not how many to allocate
-extern Grid* grid[MAX_GRIDS];
+#define MAX_GRIDS 128           // How many grids in the array, not how many to allocate
+extern Grid *grid[MAX_GRIDS];
 
 void map_power_grid(bool resetgrids = false);
-int get_power (int x, int y, int power, int block_industry);
+int get_power(int x, int y, int power, int block_industry);
 void do_windmill(int x, int y);
 void do_power_substation(int x, int y);
 void do_power_source(int x, int y);
 void do_power_source_coal(int x, int y);
 void do_power_line(int x, int y);
-void power_time_step ();
+void power_time_step();
 
 /* intended private */
-void recurse_power_grid (int startx, int starty, int steps);
+void recurse_power_grid(int startx, int starty, int steps);
 int check_grid(int x, int y, int xi, int yi);
 void project_power(int x, int y);
 
-#define POWER_LINE_LOSS 1 /* one KW */
-#define POWER_MODULUS 25 /* Controls how often we see a packet in anim */
+#define POWER_LINE_LOSS 1       /* one KW */
+#define POWER_MODULUS 25        /* Controls how often we see a packet in anim */
 
 #define WEST 1
 #define NORTH 2

Modified: trunk/src/lincity/shrglobs.cpp
===================================================================
--- trunk/src/lincity/shrglobs.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/shrglobs.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -55,7 +55,7 @@
 int sust_old_money_count = 0, sust_old_population = 0, sust_old_population_count = 0;
 int sust_old_tech = 0, sust_old_tech_count = 0, sust_fire_count = 0;
 
-int total_time = 0;    /* game time */
+int total_time = 0;             /* game time */
 
 int population, starving_population;
 int housed_population;
@@ -85,14 +85,11 @@
 
 int selected_type_cost;
 
-int ex_tax_dis[NUMOF_DISCOUNT_TRIGGERS] =
-{
-  EX_DISCOUNT_TRIGGER_1,
-  EX_DISCOUNT_TRIGGER_2,
-  EX_DISCOUNT_TRIGGER_3,
-  EX_DISCOUNT_TRIGGER_4,
-  EX_DISCOUNT_TRIGGER_5,
-  EX_DISCOUNT_TRIGGER_6,
+int ex_tax_dis[NUMOF_DISCOUNT_TRIGGERS] = {
+    EX_DISCOUNT_TRIGGER_1,
+    EX_DISCOUNT_TRIGGER_2,
+    EX_DISCOUNT_TRIGGER_3,
+    EX_DISCOUNT_TRIGGER_4,
+    EX_DISCOUNT_TRIGGER_5,
+    EX_DISCOUNT_TRIGGER_6,
 };
-
-

Modified: trunk/src/lincity/shrtypes.cpp
===================================================================
--- trunk/src/lincity/shrtypes.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/shrtypes.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -14,515 +14,478 @@
 //#include &quot;cliglobs.h&quot;
 #include &quot;engglobs.h&quot;
 
-void
-set_mappoint_used (int fromx, int fromy, int x, int y)
+void set_mappoint_used(int fromx, int fromy, int x, int y)
 {
-    MP_TYPE(x,y) = CST_USED;
-    MP_GROUP(x,y) = GROUP_USED;
-    MP_INFO(x,y).int_1 = fromx;
-    MP_INFO(x,y).int_2 = fromy;
+    MP_TYPE(x, y) = CST_USED;
+    MP_GROUP(x, y) = GROUP_USED;
+    MP_INFO(x, y).int_1 = fromx;
+    MP_INFO(x, y).int_2 = fromy;
 }
 
-  
-void
-set_mappoint (int x, int y, short selected_type)
+void set_mappoint(int x, int y, short selected_type)
 {
-  int grp;
+    int grp;
 
-  if ((grp = get_group_of_type(selected_type)) &lt; 0) return;
+    if ((grp = get_group_of_type(selected_type)) &lt; 0)
+        return;
 
-  MP_TYPE(x,y) = selected_type;
-  MP_GROUP(x,y) = grp;
+    MP_TYPE(x, y) = selected_type;
+    MP_GROUP(x, y) = grp;
 
-  if (main_groups[grp].size == 2)
-    {
-      set_mappoint_used (x, y, x + 1, y);
-      set_mappoint_used (x, y, x, y + 1);
-      set_mappoint_used (x, y, x + 1, y + 1);
-    }
-  else if (main_groups[grp].size == 3)
-    {
-      set_mappoint_used (x, y, x + 1, y);
-      set_mappoint_used (x, y, x + 2, y);
-      set_mappoint_used (x, y, x + 1, y + 1);
-      set_mappoint_used (x, y, x + 2, y + 1);
-      set_mappoint_used (x, y, x + 1, y + 2);
-      set_mappoint_used (x, y, x + 2, y + 2);
-      set_mappoint_used (x, y, x, y + 1);
-      set_mappoint_used (x, y, x, y + 2);
-    }
-  else if (main_groups[grp].size == 4)
-    {
-      set_mappoint_used (x, y, x + 1, y);
-      set_mappoint_used (x, y, x + 2, y);
-      set_mappoint_used (x, y, x + 1, y + 1);
-      set_mappoint_used (x, y, x + 2, y + 1);
-      set_mappoint_used (x, y, x + 1, y + 2);
-      set_mappoint_used (x, y, x + 2, y + 2);
-      set_mappoint_used (x, y, x, y + 1);
-      set_mappoint_used (x, y, x, y + 2);
+    if (main_groups[grp].size == 2) {
+        set_mappoint_used(x, y, x + 1, y);
+        set_mappoint_used(x, y, x, y + 1);
+        set_mappoint_used(x, y, x + 1, y + 1);
+    } else if (main_groups[grp].size == 3) {
+        set_mappoint_used(x, y, x + 1, y);
+        set_mappoint_used(x, y, x + 2, y);
+        set_mappoint_used(x, y, x + 1, y + 1);
+        set_mappoint_used(x, y, x + 2, y + 1);
+        set_mappoint_used(x, y, x + 1, y + 2);
+        set_mappoint_used(x, y, x + 2, y + 2);
+        set_mappoint_used(x, y, x, y + 1);
+        set_mappoint_used(x, y, x, y + 2);
+    } else if (main_groups[grp].size == 4) {
+        set_mappoint_used(x, y, x + 1, y);
+        set_mappoint_used(x, y, x + 2, y);
+        set_mappoint_used(x, y, x + 1, y + 1);
+        set_mappoint_used(x, y, x + 2, y + 1);
+        set_mappoint_used(x, y, x + 1, y + 2);
+        set_mappoint_used(x, y, x + 2, y + 2);
+        set_mappoint_used(x, y, x, y + 1);
+        set_mappoint_used(x, y, x, y + 2);
 
-      set_mappoint_used (x, y, x + 3, y);
-      set_mappoint_used (x, y, x + 3, y + 1);
-      set_mappoint_used (x, y, x + 3, y + 2);
-      set_mappoint_used (x, y, x + 3, y + 3);
-      set_mappoint_used (x, y, x, y + 3);
-      set_mappoint_used (x, y, x + 1, y + 3);
-      set_mappoint_used (x, y, x + 2, y + 3);
+        set_mappoint_used(x, y, x + 3, y);
+        set_mappoint_used(x, y, x + 3, y + 1);
+        set_mappoint_used(x, y, x + 3, y + 2);
+        set_mappoint_used(x, y, x + 3, y + 3);
+        set_mappoint_used(x, y, x, y + 3);
+        set_mappoint_used(x, y, x + 1, y + 3);
+        set_mappoint_used(x, y, x + 2, y + 3);
     }
 }
 
-
-void
-connect_transport (int originx, int originy, int w, int h)
+void connect_transport(int originx, int originy, int w, int h)
 {
-  int x, y, mask, tflags;
-  short group, type;
+    int x, y, mask, tflags;
+    short group, type;
 
-  static const short power_table[16] =
-  {
-    CST_POWERL_H_D, CST_POWERL_V_D, CST_POWERL_H_D, CST_POWERL_RD_D,
-    CST_POWERL_H_D, CST_POWERL_LD_D, CST_POWERL_H_D, CST_POWERL_LDR_D,
-    CST_POWERL_V_D, CST_POWERL_V_D, CST_POWERL_RU_D, CST_POWERL_UDR_D,
-    CST_POWERL_LU_D, CST_POWERL_LDU_D, CST_POWERL_LUR_D, CST_POWERL_LUDR_D
-  };
-  static const short track_table[16] =
-  {
-    CST_TRACK_LR, CST_TRACK_LR, CST_TRACK_UD, CST_TRACK_LU,
-    CST_TRACK_LR, CST_TRACK_LR, CST_TRACK_UR, CST_TRACK_LUR,
-    CST_TRACK_UD, CST_TRACK_LD, CST_TRACK_UD, CST_TRACK_LUD,
-    CST_TRACK_DR, CST_TRACK_LDR, CST_TRACK_UDR, CST_TRACK_LUDR
-  };
-  static const short road_table[16] =
-  {
-    CST_ROAD_LR, CST_ROAD_LR, CST_ROAD_UD, CST_ROAD_LU,
-    CST_ROAD_LR, CST_ROAD_LR, CST_ROAD_UR, CST_ROAD_LUR,
-    CST_ROAD_UD, CST_ROAD_LD, CST_ROAD_UD, CST_ROAD_LUD,
-    CST_ROAD_DR, CST_ROAD_LDR, CST_ROAD_UDR, CST_ROAD_LUDR
-  };
-  static const short rail_table[16] =
-  {
-    CST_RAIL_LR, CST_RAIL_LR, CST_RAIL_UD, CST_RAIL_LU,
-    CST_RAIL_LR, CST_RAIL_LR, CST_RAIL_UR, CST_RAIL_LUR,
-    CST_RAIL_UD, CST_RAIL_LD, CST_RAIL_UD, CST_RAIL_LUD,
-    CST_RAIL_DR, CST_RAIL_LDR, CST_RAIL_UDR, CST_RAIL_LUDR
-  }; 
-  static const short water_table[16] =
-  {
-    CST_WATER, CST_WATER_D, CST_WATER_R, CST_WATER_RD,
-    CST_WATER_L, CST_WATER_LD, CST_WATER_LR, CST_WATER_LRD,
-    CST_WATER_U, CST_WATER_UD, CST_WATER_UR, CST_WATER_URD,
-    CST_WATER_LU, CST_WATER_LUD, CST_WATER_LUR, CST_WATER_LURD
-  };
+    static const short power_table[16] = {
+        CST_POWERL_H_D, CST_POWERL_V_D, CST_POWERL_H_D, CST_POWERL_RD_D,
+        CST_POWERL_H_D, CST_POWERL_LD_D, CST_POWERL_H_D, CST_POWERL_LDR_D,
+        CST_POWERL_V_D, CST_POWERL_V_D, CST_POWERL_RU_D, CST_POWERL_UDR_D,
+        CST_POWERL_LU_D, CST_POWERL_LDU_D, CST_POWERL_LUR_D, CST_POWERL_LUDR_D
+    };
+    static const short track_table[16] = {
+        CST_TRACK_LR, CST_TRACK_LR, CST_TRACK_UD, CST_TRACK_LU,
+        CST_TRACK_LR, CST_TRACK_LR, CST_TRACK_UR, CST_TRACK_LUR,
+        CST_TRACK_UD, CST_TRACK_LD, CST_TRACK_UD, CST_TRACK_LUD,
+        CST_TRACK_DR, CST_TRACK_LDR, CST_TRACK_UDR, CST_TRACK_LUDR
+    };
+    static const short road_table[16] = {
+        CST_ROAD_LR, CST_ROAD_LR, CST_ROAD_UD, CST_ROAD_LU,
+        CST_ROAD_LR, CST_ROAD_LR, CST_ROAD_UR, CST_ROAD_LUR,
+        CST_ROAD_UD, CST_ROAD_LD, CST_ROAD_UD, CST_ROAD_LUD,
+        CST_ROAD_DR, CST_ROAD_LDR, CST_ROAD_UDR, CST_ROAD_LUDR
+    };
+    static const short rail_table[16] = {
+        CST_RAIL_LR, CST_RAIL_LR, CST_RAIL_UD, CST_RAIL_LU,
+        CST_RAIL_LR, CST_RAIL_LR, CST_RAIL_UR, CST_RAIL_LUR,
+        CST_RAIL_UD, CST_RAIL_LD, CST_RAIL_UD, CST_RAIL_LUD,
+        CST_RAIL_DR, CST_RAIL_LDR, CST_RAIL_UDR, CST_RAIL_LUDR
+    };
+    static const short water_table[16] = {
+        CST_WATER, CST_WATER_D, CST_WATER_R, CST_WATER_RD,
+        CST_WATER_L, CST_WATER_LD, CST_WATER_LR, CST_WATER_LRD,
+        CST_WATER_U, CST_WATER_UD, CST_WATER_UR, CST_WATER_URD,
+        CST_WATER_LU, CST_WATER_LUD, CST_WATER_LUR, CST_WATER_LURD
+    };
 
-  /* Adjust originx,originy,w,h to proper range */
-  if (originx &lt;= 0) {
-    w -= 1 - originx;
-    originx = 1;
-  }
-  if (originy &lt;= 0) {
-    h -= 1 - originy;
-    originy = 1;
-  }
-  if (originx + w &gt;= WORLD_SIDE_LEN) {
-    w = WORLD_SIDE_LEN - originx;
-  }
-  if (originy + h &gt;= WORLD_SIDE_LEN) {
-    h = WORLD_SIDE_LEN - originy;
-  }
-  
-  for (x = originx; x &lt; originx + w; x++) {
-    for (y = originy; y &lt; originy + h; y++) {
-      switch (MP_GROUP(x,y))
-	{
-	case GROUP_POWER_LINE:
-	  /* First, set up a mask indicating into which directions 
-	     power may be transferred */
-	  mask = 0;
-#ifdef	THOMMY_MAY_BE_WRONG	/* just in case -- (ThMO) */
-	  if (y &gt; 0)
+    /* Adjust originx,originy,w,h to proper range */
+    if (originx &lt;= 0) {
+        w -= 1 - originx;
+        originx = 1;
+    }
+    if (originy &lt;= 0) {
+        h -= 1 - originy;
+        originy = 1;
+    }
+    if (originx + w &gt;= WORLD_SIDE_LEN) {
+        w = WORLD_SIDE_LEN - originx;
+    }
+    if (originy + h &gt;= WORLD_SIDE_LEN) {
+        h = WORLD_SIDE_LEN - originy;
+    }
+
+    for (x = originx; x &lt; originx + w; x++) {
+        for (y = originy; y &lt; originy + h; y++) {
+            switch (MP_GROUP(x, y)) {
+            case GROUP_POWER_LINE:
+                /* First, set up a mask indicating into which directions 
+                   power may be transferred */
+                mask = 0;
+#ifdef	THOMMY_MAY_BE_WRONG     /* just in case -- (ThMO) */
+                if (y &gt; 0)
 #endif
-	    {		/* up -- (ThMO) */
-	      group = MP_GROUP(x,y-1);
+                {               /* up -- (ThMO) */
+                    group = MP_GROUP(x, y - 1);
 
-	      /* see if dug under track, rail or road */
+                    /* see if dug under track, rail or road */
 
-	      if (y &gt; 1 &amp;&amp; (group == GROUP_TRACK
-			    || group == GROUP_RAIL
-			    || group == GROUP_ROAD
-			    || group == GROUP_WATER))
-		group = MP_GROUP(x,y-2);
-	      switch (group)
-		{
-		case GROUP_POWER_LINE:
-		case GROUP_SOLAR_POWER:
-		case GROUP_SUBSTATION:
-		case GROUP_COAL_POWER:
-		  mask |= 8;
-		  break;
-		}
-	    }
-#ifdef	THOMMY_MAY_BE_WRONG	/* just in case -- (ThMO) */
-	  if (x &gt; 0)
+                    if (y &gt; 1 &amp;&amp; (group == GROUP_TRACK
+                                  || group == GROUP_RAIL || group == GROUP_ROAD || group == GROUP_WATER))
+                        group = MP_GROUP(x, y - 2);
+                    switch (group) {
+                    case GROUP_POWER_LINE:
+                    case GROUP_SOLAR_POWER:
+                    case GROUP_SUBSTATION:
+                    case GROUP_COAL_POWER:
+                        mask |= 8;
+                        break;
+                    }
+                }
+#ifdef	THOMMY_MAY_BE_WRONG     /* just in case -- (ThMO) */
+                if (x &gt; 0)
 #endif
-	    {		/* left -- (ThMO) */
-	      group = MP_GROUP(x-1,y);
-	      if (x &gt; 1 &amp;&amp; (group == GROUP_TRACK
-			    || group == GROUP_RAIL
-			    || group == GROUP_ROAD
-			    || group == GROUP_WATER))
-		group = MP_GROUP(x-2,y);
-	      switch (group)
-		{
-		case GROUP_POWER_LINE:
-		case GROUP_SOLAR_POWER:
-		case GROUP_SUBSTATION:
-		case GROUP_COAL_POWER:
-		  mask |= 4;
-		  break;
-		}
-	    }
-#ifdef	THOMMY_MAY_BE_WRONG	/* just in case -- (ThMO) */
-	  if (x &lt; WORLD_SIDE_LEN - 1)
+                {               /* left -- (ThMO) */
+                    group = MP_GROUP(x - 1, y);
+                    if (x &gt; 1 &amp;&amp; (group == GROUP_TRACK
+                                  || group == GROUP_RAIL || group == GROUP_ROAD || group == GROUP_WATER))
+                        group = MP_GROUP(x - 2, y);
+                    switch (group) {
+                    case GROUP_POWER_LINE:
+                    case GROUP_SOLAR_POWER:
+                    case GROUP_SUBSTATION:
+                    case GROUP_COAL_POWER:
+                        mask |= 4;
+                        break;
+                    }
+                }
+#ifdef	THOMMY_MAY_BE_WRONG     /* just in case -- (ThMO) */
+                if (x &lt; WORLD_SIDE_LEN - 1)
 #endif
-	    {		/* right -- (ThMO) */
-	      group = MP_GROUP(x+1,y);
-	      if (x &lt; WORLD_SIDE_LEN - 2 &amp;&amp; (group == GROUP_TRACK
-					     || group == GROUP_RAIL
-					     || group == GROUP_ROAD
-					     || group == GROUP_WATER))
-		group = MP_GROUP(x+2,y);
-	      switch (group)
-		{
-		case GROUP_WINDMILL:
-		  if (MP_INFO(x + 1,y).int_2 &lt; MODERN_WINDMILL_TECH)
-		    break;
-		case GROUP_POWER_LINE:
-		case GROUP_SOLAR_POWER:
-		case GROUP_SUBSTATION:
-		case GROUP_COAL_POWER:
-		  mask |= 2;
-		  break;
-		}
-	    }
-#ifdef	THOMMY_MAY_BE_WRONG	/* just in case -- (ThMO) */
-	  if (y &lt; WORLD_SIDE_LEN - 1)
+                {               /* right -- (ThMO) */
+                    group = MP_GROUP(x + 1, y);
+                    if (x &lt; WORLD_SIDE_LEN - 2 &amp;&amp; (group == GROUP_TRACK
+                                                   || group == GROUP_RAIL
+                                                   || group == GROUP_ROAD || group == GROUP_WATER))
+                        group = MP_GROUP(x + 2, y);
+                    switch (group) {
+                    case GROUP_WINDMILL:
+                        if (MP_INFO(x + 1, y).int_2 &lt; MODERN_WINDMILL_TECH)
+                            break;
+                    case GROUP_POWER_LINE:
+                    case GROUP_SOLAR_POWER:
+                    case GROUP_SUBSTATION:
+                    case GROUP_COAL_POWER:
+                        mask |= 2;
+                        break;
+                    }
+                }
+#ifdef	THOMMY_MAY_BE_WRONG     /* just in case -- (ThMO) */
+                if (y &lt; WORLD_SIDE_LEN - 1)
 #endif
-	    {		/* down -- (ThMO) */
-	      group = MP_GROUP(x,y+1);
-	      if (y &lt; WORLD_SIDE_LEN - 2 &amp;&amp; (group == GROUP_TRACK
-					     || group == GROUP_RAIL
-					     || group == GROUP_ROAD
-					     || group == GROUP_WATER))
-		group = MP_GROUP(x,y+2);
-	      switch (group)
-		{
-		case GROUP_WINDMILL:
-		  if (MP_INFO(x,y + 1).int_2 &lt; MODERN_WINDMILL_TECH)
-		    break;
-		case GROUP_POWER_LINE:
-		case GROUP_SOLAR_POWER:
-		case GROUP_SUBSTATION:
-		case GROUP_COAL_POWER:
-		  ++mask;
-		  break;
-		}
-	    }
-	  /* Next, set the connectivity into MP_TYPE */
-	  MP_TYPE(x,y) = power_table[mask];
-	  /* Finally, adjust MP_TYPE to show electon bolt */
+                {               /* down -- (ThMO) */
+                    group = MP_GROUP(x, y + 1);
+                    if (y &lt; WORLD_SIDE_LEN - 2 &amp;&amp; (group == GROUP_TRACK
+                                                   || group == GROUP_RAIL
+                                                   || group == GROUP_ROAD || group == GROUP_WATER))
+                        group = MP_GROUP(x, y + 2);
+                    switch (group) {
+                    case GROUP_WINDMILL:
+                        if (MP_INFO(x, y + 1).int_2 &lt; MODERN_WINDMILL_TECH)
+                            break;
+                    case GROUP_POWER_LINE:
+                    case GROUP_SOLAR_POWER:
+                    case GROUP_SUBSTATION:
+                    case GROUP_COAL_POWER:
+                        ++mask;
+                        break;
+                    }
+                }
+                /* Next, set the connectivity into MP_TYPE */
+                MP_TYPE(x, y) = power_table[mask];
+                /* Finally, adjust MP_TYPE to show electon bolt */
 #ifdef commentout
-	   WCK: This is done in do_power_line now 
-	  	  if (MP_INFO(x,y).int_1 != 0)
-		  MP_TYPE(x,y) -= 11; 
+              WCK:This is done in do_power_line now if (MP_INFO(x, y).int_1 != 0)
+                    MP_TYPE(x, y) -= 11;
 #endif
-	  break;
+                break;
 
-	case GROUP_TRACK:
+            case GROUP_TRACK:
 #if	FLAG_LEFT != 1 || FLAG_UP != 2 || FLAG_RIGHT != 4 || FLAG_DOWN != 8
 #error  check_track_graphics(): you loose
 #error  this algorithm depends on proper flag settings -- (ThMO)
 #endif
-	  mask = 0;
-#ifdef	THOMMY_MAY_BE_WRONG	/* just in case -- (ThMO) */
-	  if (y &gt; 0)
+                mask = 0;
+#ifdef	THOMMY_MAY_BE_WRONG     /* just in case -- (ThMO) */
+                if (y &gt; 0)
 #endif
-	    {
-	      if (MP_GROUP(x,y-1) == GROUP_TRACK)
-		mask |= FLAG_UP;
-	    }
-#ifdef	THOMMY_MAY_BE_WRONG	/* just in case -- (ThMO) */
-	  if (x &gt; 0)
+                {
+                    if (MP_GROUP(x, y - 1) == GROUP_TRACK)
+                        mask |= FLAG_UP;
+                }
+#ifdef	THOMMY_MAY_BE_WRONG     /* just in case -- (ThMO) */
+                if (x &gt; 0)
 #endif
-	    {
-	      if (MP_GROUP(x-1,y) == GROUP_TRACK)
-		mask |= FLAG_LEFT;
-	    }
-	  tflags = mask;
-#ifdef	THOMMY_MAY_BE_WRONG	/* just in case -- (ThMO) */
-	  if (x &lt; WORLD_SIDE_LEN - 1)
+                {
+                    if (MP_GROUP(x - 1, y) == GROUP_TRACK)
+                        mask |= FLAG_LEFT;
+                }
+                tflags = mask;
+#ifdef	THOMMY_MAY_BE_WRONG     /* just in case -- (ThMO) */
+                if (x &lt; WORLD_SIDE_LEN - 1)
 #endif
-	    {
-	      switch (MP_GROUP(x+1,y))
-		{
-		case GROUP_TRACK:
-		  tflags |= FLAG_RIGHT;
-		case GROUP_COMMUNE:
-		case GROUP_COALMINE:
-		case GROUP_OREMINE:
-		case GROUP_INDUSTRY_L:
-		case GROUP_INDUSTRY_H:
-		case GROUP_RECYCLE:
-		case GROUP_TIP:
-		case GROUP_PORT:
-		  mask |= FLAG_RIGHT;
-		  break;
-		default:
-#ifdef	THOMMY_MAY_BE_WRONG	/* just in case -- (ThMO) */
-		  if (y &gt; 0)
+                {
+                    switch (MP_GROUP(x + 1, y)) {
+                    case GROUP_TRACK:
+                        tflags |= FLAG_RIGHT;
+                    case GROUP_COMMUNE:
+                    case GROUP_COALMINE:
+                    case GROUP_OREMINE:
+                    case GROUP_INDUSTRY_L:
+                    case GROUP_INDUSTRY_H:
+                    case GROUP_RECYCLE:
+                    case GROUP_TIP:
+                    case GROUP_PORT:
+                        mask |= FLAG_RIGHT;
+                        break;
+                    default:
+#ifdef	THOMMY_MAY_BE_WRONG     /* just in case -- (ThMO) */
+                        if (y &gt; 0)
 #endif
-		    if (MP_GROUP(x+1,y-1) == GROUP_COAL_POWER)
-		      mask |= FLAG_RIGHT;
-		  break;
-		}
-	    }
-#ifdef	THOMMY_MAY_BE_WRONG	/* just in case -- (ThMO) */
-	  if (y &lt; WORLD_SIDE_LEN - 1)
+                            if (MP_GROUP(x + 1, y - 1) == GROUP_COAL_POWER)
+                                mask |= FLAG_RIGHT;
+                        break;
+                    }
+                }
+#ifdef	THOMMY_MAY_BE_WRONG     /* just in case -- (ThMO) */
+                if (y &lt; WORLD_SIDE_LEN - 1)
 #endif
-	    {
-	      switch (MP_GROUP(x,y+1))
-		{
-		case GROUP_TRACK:
-		  tflags |= FLAG_DOWN;
-		case GROUP_COMMUNE:
-		case GROUP_COALMINE:
-		case GROUP_OREMINE:
-		case GROUP_INDUSTRY_L:
-		case GROUP_INDUSTRY_H:
-		case GROUP_RECYCLE:
-		case GROUP_TIP:
-		case GROUP_PORT:
-		  mask |= FLAG_DOWN;
-		  break;
-		default:
-#ifdef	THOMMY_MAY_BE_WRONG	/* just in case -- (ThMO) */
-		  if (x &gt; 0)
+                {
+                    switch (MP_GROUP(x, y + 1)) {
+                    case GROUP_TRACK:
+                        tflags |= FLAG_DOWN;
+                    case GROUP_COMMUNE:
+                    case GROUP_COALMINE:
+                    case GROUP_OREMINE:
+                    case GROUP_INDUSTRY_L:
+                    case GROUP_INDUSTRY_H:
+                    case GROUP_RECYCLE:
+                    case GROUP_TIP:
+                    case GROUP_PORT:
+                        mask |= FLAG_DOWN;
+                        break;
+                    default:
+#ifdef	THOMMY_MAY_BE_WRONG     /* just in case -- (ThMO) */
+                        if (x &gt; 0)
 #endif
-		    if (MP_GROUP(x-1,y+1) == GROUP_COAL_POWER)
-		      mask |= FLAG_DOWN;
-		  break;
-		}
-	    }
-	  MP_INFO(x,y).flags &amp;= ~(FLAG_UP | FLAG_DOWN | FLAG_LEFT
-				  | FLAG_RIGHT);
-	  MP_INFO(x,y).flags |= tflags;
-	  MP_TYPE(x,y) = track_table[mask];
-	  break;
+                            if (MP_GROUP(x - 1, y + 1) == GROUP_COAL_POWER)
+                                mask |= FLAG_DOWN;
+                        break;
+                    }
+                }
+                MP_INFO(x, y).flags &amp;= ~(FLAG_UP | FLAG_DOWN | FLAG_LEFT | FLAG_RIGHT);
+                MP_INFO(x, y).flags |= tflags;
+                MP_TYPE(x, y) = track_table[mask];
+                break;
 
-	case GROUP_ROAD:
+            case GROUP_ROAD:
 #if	FLAG_LEFT != 1 || FLAG_UP != 2 || FLAG_RIGHT != 4 || FLAG_DOWN != 8
 #error  check_road_graphics(): you loose
 #error  this algorithm depends on proper flag settings -- (ThMO)
 #endif
-	  mask = 0;
-#ifdef	THOMMY_MAY_BE_WRONG	/* just in case -- (ThMO) */
-	  if (y &gt; 0)
+                mask = 0;
+#ifdef	THOMMY_MAY_BE_WRONG     /* just in case -- (ThMO) */
+                if (y &gt; 0)
 #endif
-	    {
-	      if (MP_GROUP(x,y-1) == GROUP_ROAD)
-		mask |= FLAG_UP;
-	    }
-#ifdef	THOMMY_MAY_BE_WRONG	/* just in case -- (ThMO) */
-	  if (x &gt; 0)
+                {
+                    if (MP_GROUP(x, y - 1) == GROUP_ROAD)
+                        mask |= FLAG_UP;
+                }
+#ifdef	THOMMY_MAY_BE_WRONG     /* just in case -- (ThMO) */
+                if (x &gt; 0)
 #endif
-	    {
-	      if (MP_GROUP(x-1,y) == GROUP_ROAD)
-		mask |= FLAG_LEFT;
-	    }
-	  tflags = mask;
-#ifdef	THOMMY_MAY_BE_WRONG	/* just in case -- (ThMO) */
-	  if (x &lt; WORLD_SIDE_LEN - 1)
+                {
+                    if (MP_GROUP(x - 1, y) == GROUP_ROAD)
+                        mask |= FLAG_LEFT;
+                }
+                tflags = mask;
+#ifdef	THOMMY_MAY_BE_WRONG     /* just in case -- (ThMO) */
+                if (x &lt; WORLD_SIDE_LEN - 1)
 #endif
-	    {
-	      switch (MP_GROUP(x+1,y))
-		{
-		case GROUP_ROAD:
-		  tflags |= FLAG_RIGHT;
-		case GROUP_COMMUNE:
-		case GROUP_COALMINE:
-		case GROUP_OREMINE:
-		case GROUP_INDUSTRY_L:
-		case GROUP_INDUSTRY_H:
-		case GROUP_RECYCLE:
-		case GROUP_TIP:
-		case GROUP_PORT:
-		  mask |= FLAG_RIGHT;
-		  break;
-		default:
-#ifdef	THOMMY_MAY_BE_WRONG	/* just in case -- (ThMO) */
-		  if (y &gt; 0)
+                {
+                    switch (MP_GROUP(x + 1, y)) {
+                    case GROUP_ROAD:
+                        tflags |= FLAG_RIGHT;
+                    case GROUP_COMMUNE:
+                    case GROUP_COALMINE:
+                    case GROUP_OREMINE:
+                    case GROUP_INDUSTRY_L:
+                    case GROUP_INDUSTRY_H:
+                    case GROUP_RECYCLE:
+                    case GROUP_TIP:
+                    case GROUP_PORT:
+                        mask |= FLAG_RIGHT;
+                        break;
+                    default:
+#ifdef	THOMMY_MAY_BE_WRONG     /* just in case -- (ThMO) */
+                        if (y &gt; 0)
 #endif
-		    if (MP_GROUP(x+1,y-1) == GROUP_COAL_POWER)
-		      mask |= FLAG_RIGHT;
-		  break;
-		}
-	    }
-#ifdef	THOMMY_MAY_BE_WRONG	/* just in case -- (ThMO) */
-	  if (y &lt; WORLD_SIDE_LEN - 1)
+                            if (MP_GROUP(x + 1, y - 1) == GROUP_COAL_POWER)
+                                mask |= FLAG_RIGHT;
+                        break;
+                    }
+                }
+#ifdef	THOMMY_MAY_BE_WRONG     /* just in case -- (ThMO) */
+                if (y &lt; WORLD_SIDE_LEN - 1)
 #endif
-	    {
-	      switch (MP_GROUP(x,y+1))
-		{
-		case GROUP_ROAD:
-		  tflags |= FLAG_DOWN;
-		case GROUP_COMMUNE:
-		case GROUP_COALMINE:
-		case GROUP_OREMINE:
-		case GROUP_INDUSTRY_L:
-		case GROUP_INDUSTRY_H:
-		case GROUP_RECYCLE:
-		case GROUP_TIP:
-		case GROUP_PORT:
-		  mask |= FLAG_DOWN;
-		  break;
-		default:
-#ifdef	THOMMY_MAY_BE_WRONG	/* just in case -- (ThMO) */
-		  if (x &gt; 0)
+                {
+                    switch (MP_GROUP(x, y + 1)) {
+                    case GROUP_ROAD:
+                        tflags |= FLAG_DOWN;
+                    case GROUP_COMMUNE:
+                    case GROUP_COALMINE:
+                    case GROUP_OREMINE:
+                    case GROUP_INDUSTRY_L:
+                    case GROUP_INDUSTRY_H:
+                    case GROUP_RECYCLE:
+                    case GROUP_TIP:
+                    case GROUP_PORT:
+                        mask |= FLAG_DOWN;
+                        break;
+                    default:
+#ifdef	THOMMY_MAY_BE_WRONG     /* just in case -- (ThMO) */
+                        if (x &gt; 0)
 #endif
-		    if (MP_GROUP(x-1,y+1) == GROUP_COAL_POWER)
-		      mask |= FLAG_DOWN;
-		  break;
-		}
-	    }
-	  MP_INFO(x,y).flags &amp;= ~(FLAG_UP | FLAG_DOWN | FLAG_LEFT
-				  | FLAG_RIGHT);
-	  MP_INFO(x,y).flags |= tflags;
-	  MP_TYPE(x,y) = road_table[mask];
-	  break;
+                            if (MP_GROUP(x - 1, y + 1) == GROUP_COAL_POWER)
+                                mask |= FLAG_DOWN;
+                        break;
+                    }
+                }
+                MP_INFO(x, y).flags &amp;= ~(FLAG_UP | FLAG_DOWN | FLAG_LEFT | FLAG_RIGHT);
+                MP_INFO(x, y).flags |= tflags;
+                MP_TYPE(x, y) = road_table[mask];
+                break;
 
-	case GROUP_RAIL:
+            case GROUP_RAIL:
 #if	FLAG_LEFT != 1 || FLAG_UP != 2 || FLAG_RIGHT != 4 || FLAG_DOWN != 8
 #error  check_rail_graphics(): you loose
 #error  this algorithm depends on proper flag settings -- (ThMO)
 #endif
-	  mask = 0;
-#ifdef	THOMMY_MAY_BE_WRONG	/* just in case -- (ThMO) */
-	  if (y &gt; 0)
+                mask = 0;
+#ifdef	THOMMY_MAY_BE_WRONG     /* just in case -- (ThMO) */
+                if (y &gt; 0)
 #endif
-	    {
-	      if (MP_GROUP(x,y-1) == GROUP_RAIL)
-		mask |= FLAG_UP;
-	    }
-#ifdef	THOMMY_MAY_BE_WRONG	/* just in case -- (ThMO) */
-	  if (x &gt; 0)
+                {
+                    if (MP_GROUP(x, y - 1) == GROUP_RAIL)
+                        mask |= FLAG_UP;
+                }
+#ifdef	THOMMY_MAY_BE_WRONG     /* just in case -- (ThMO) */
+                if (x &gt; 0)
 #endif
-	    {
-	      if (MP_GROUP(x-1,y) == GROUP_RAIL)
-		mask |= FLAG_LEFT;
-	    }
-	  tflags = mask;
-#ifdef	THOMMY_MAY_BE_WRONG	/* just in case -- (ThMO) */
-	  if (x &lt; WORLD_SIDE_LEN - 1)
+                {
+                    if (MP_GROUP(x - 1, y) == GROUP_RAIL)
+                        mask |= FLAG_LEFT;
+                }
+                tflags = mask;
+#ifdef	THOMMY_MAY_BE_WRONG     /* just in case -- (ThMO) */
+                if (x &lt; WORLD_SIDE_LEN - 1)
 #endif
-	    {
-	      switch (MP_GROUP(x+1,y))
-		{
-		case GROUP_RAIL:
-		  tflags |= FLAG_RIGHT;
-		case GROUP_COMMUNE:
-		case GROUP_COALMINE:
-		case GROUP_OREMINE:
-		case GROUP_INDUSTRY_L:
-		case GROUP_INDUSTRY_H:
-		case GROUP_RECYCLE:
-		case GROUP_TIP:
-		case GROUP_PORT:
-		  mask |= FLAG_RIGHT;
-		  break;
-		default:
-#ifdef	THOMMY_MAY_BE_WRONG	/* just in case -- (ThMO) */
-		  if (y &gt; 0)
+                {
+                    switch (MP_GROUP(x + 1, y)) {
+                    case GROUP_RAIL:
+                        tflags |= FLAG_RIGHT;
+                    case GROUP_COMMUNE:
+                    case GROUP_COALMINE:
+                    case GROUP_OREMINE:
+                    case GROUP_INDUSTRY_L:
+                    case GROUP_INDUSTRY_H:
+                    case GROUP_RECYCLE:
+                    case GROUP_TIP:
+                    case GROUP_PORT:
+                        mask |= FLAG_RIGHT;
+                        break;
+                    default:
+#ifdef	THOMMY_MAY_BE_WRONG     /* just in case -- (ThMO) */
+                        if (y &gt; 0)
 #endif
-		    if (MP_GROUP(x+1,y-1) == GROUP_COAL_POWER)
-		      mask |= FLAG_RIGHT;
-		  break;
-		}
-	    }
-#ifdef	THOMMY_MAY_BE_WRONG	/* just in case -- (ThMO) */
-	  if (y &lt; WORLD_SIDE_LEN - 1)
+                            if (MP_GROUP(x + 1, y - 1) == GROUP_COAL_POWER)
+                                mask |= FLAG_RIGHT;
+                        break;
+                    }
+                }
+#ifdef	THOMMY_MAY_BE_WRONG     /* just in case -- (ThMO) */
+                if (y &lt; WORLD_SIDE_LEN - 1)
 #endif
-	    {
-	      switch (MP_GROUP(x,y + 1))
-		{
-		case GROUP_RAIL:
-		  tflags |= FLAG_DOWN;
-		case GROUP_COMMUNE:
-		case GROUP_COALMINE:
-		case GROUP_OREMINE:
-		case GROUP_INDUSTRY_L:
-		case GROUP_INDUSTRY_H:
-		case GROUP_RECYCLE:
-		case GROUP_TIP:
-		case GROUP_PORT:
-		  mask |= FLAG_DOWN;
-		  break;
-		default:
-#ifdef	THOMMY_MAY_BE_WRONG	/* just in case -- (ThMO) */
-		  if (x &gt; 0)
+                {
+                    switch (MP_GROUP(x, y + 1)) {
+                    case GROUP_RAIL:
+                        tflags |= FLAG_DOWN;
+                    case GROUP_COMMUNE:
+                    case GROUP_COALMINE:
+                    case GROUP_OREMINE:
+                    case GROUP_INDUSTRY_L:
+                    case GROUP_INDUSTRY_H:
+                    case GROUP_RECYCLE:
+                    case GROUP_TIP:
+                    case GROUP_PORT:
+                        mask |= FLAG_DOWN;
+                        break;
+                    default:
+#ifdef	THOMMY_MAY_BE_WRONG     /* just in case -- (ThMO) */
+                        if (x &gt; 0)
 #endif
-		    if (MP_GROUP(x - 1,y + 1)
-			== GROUP_COAL_POWER)
-		      mask |= FLAG_DOWN;
-		  break;
-		}
-	    }
-	  MP_INFO(x,y).flags &amp;= ~(FLAG_UP | FLAG_DOWN | FLAG_LEFT
-				  | FLAG_RIGHT);
-	  MP_INFO(x,y).flags |= tflags;
-	  MP_TYPE(x,y) = rail_table[mask];
-	  break;
+                            if (MP_GROUP(x - 1, y + 1)
+                                == GROUP_COAL_POWER)
+                                mask |= FLAG_DOWN;
+                        break;
+                    }
+                }
+                MP_INFO(x, y).flags &amp;= ~(FLAG_UP | FLAG_DOWN | FLAG_LEFT | FLAG_RIGHT);
+                MP_INFO(x, y).flags |= tflags;
+                MP_TYPE(x, y) = rail_table[mask];
+                break;
 
-	case GROUP_WATER:
-	  mask = 0;
-#ifdef	THOMMY_MAY_BE_WRONG	/* just in case -- (ThMO) */
-	  if (y &gt; 0)
+            case GROUP_WATER:
+                mask = 0;
+#ifdef	THOMMY_MAY_BE_WRONG     /* just in case -- (ThMO) */
+                if (y &gt; 0)
 #endif
-	    {		/* up -- (ThMO) */
-	      if (MP_GROUP(x,y - 1)
-		  == GROUP_WATER)
-		mask |= 8;
-	    }
-#ifdef	THOMMY_MAY_BE_WRONG	/* just in case -- (ThMO) */
-	  if (x &gt; 0)
+                {               /* up -- (ThMO) */
+                    if (MP_GROUP(x, y - 1)
+                        == GROUP_WATER)
+                        mask |= 8;
+                }
+#ifdef	THOMMY_MAY_BE_WRONG     /* just in case -- (ThMO) */
+                if (x &gt; 0)
 #endif
-	    {		/* left -- (ThMO) */
-	      type = MP_TYPE(x - 1,y);
-	      if ((type == CST_USED &amp;&amp; 
-		   MP_GROUP(MP_INFO(x-1,y).int_1,MP_INFO(x-1,y).int_2)
-		   == GROUP_PORT)
-		  || get_group_of_type(type) == GROUP_WATER)
-		mask |= 4;
-	    }
-#ifdef	THOMMY_MAY_BE_WRONG	/* just in case -- (ThMO) */
-	  if (x &lt; WORLD_SIDE_LEN - 1)
+                {               /* left -- (ThMO) */
+                    type = MP_TYPE(x - 1, y);
+                    if ((type == CST_USED &amp;&amp; MP_GROUP(MP_INFO(x - 1, y).int_1, MP_INFO(x - 1, y).int_2)
+                         == GROUP_PORT)
+                        || get_group_of_type(type) == GROUP_WATER)
+                        mask |= 4;
+                }
+#ifdef	THOMMY_MAY_BE_WRONG     /* just in case -- (ThMO) */
+                if (x &lt; WORLD_SIDE_LEN - 1)
 #endif
-	    {		/* right -- (ThMO) */
-	      if (MP_GROUP(x + 1,y)
-		  == GROUP_WATER)
-		mask |= 2;
-	    }
-#ifdef	THOMMY_MAY_BE_WRONG	/* just in case -- (ThMO) */
-	  if (y &lt; WORLD_SIDE_LEN - 1)
+                {               /* right -- (ThMO) */
+                    if (MP_GROUP(x + 1, y)
+                        == GROUP_WATER)
+                        mask |= 2;
+                }
+#ifdef	THOMMY_MAY_BE_WRONG     /* just in case -- (ThMO) */
+                if (y &lt; WORLD_SIDE_LEN - 1)
 #endif
-	    {		/* down -- (ThMO) */
-	      if (MP_GROUP(x,y + 1)
-		  == GROUP_WATER)
-		++mask;
-	    }
-	  MP_TYPE(x,y) = water_table[mask];
-	  break;
-	} /* end switch */
-    } /* end for */
-  } /* end for */
+                {               /* down -- (ThMO) */
+                    if (MP_GROUP(x, y + 1)
+                        == GROUP_WATER)
+                        ++mask;
+                }
+                MP_TYPE(x, y) = water_table[mask];
+                break;
+            }                   /* end switch */
+        }                       /* end for */
+    }                           /* end for */
 }
-

Modified: trunk/src/lincity/simulate.cpp
===================================================================
--- trunk/src/lincity/simulate.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/simulate.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -39,34 +39,33 @@
 #include &quot;gui_interface/pbar_interface.h&quot;
 //#include &quot;module_buttons.h&quot;
 
-extern void connect_rivers (void);
-extern void do_daily_ecology (void);
+extern void connect_rivers(void);
+extern void do_daily_ecology(void);
 
 /* ---------------------------------------------------------------------- *
  * Private Fn Prototypes
  * ---------------------------------------------------------------------- */
-static void do_periodic_events (void);
-static void end_of_month_update (void);
-static void start_of_year_update (void);
-static void end_of_year_update (void);
-static void random_start (int* originx, int* originy);
-static void simulate_mappoints (void);
-static void quick_start_add (int x, int y, short type, int size);
-static void nullify_mappoint (int x, int y);
-static void setup_land (void);
+static void do_periodic_events(void);
+static void end_of_month_update(void);
+static void start_of_year_update(void);
+static void end_of_year_update(void);
+static void random_start(int *originx, int *originy);
+static void simulate_mappoints(void);
+static void quick_start_add(int x, int y, short type, int size);
+static void nullify_mappoint(int x, int y);
+static void setup_land(void);
 
 #define IS_RIVER(x,y) (MP_INFO(x,y).flags &amp; FLAG_IS_RIVER)
 
 /* ---------------------------------------------------------------------- *
  * Public Functions
  * ---------------------------------------------------------------------- */
-void
-do_time_step (void)
+void do_time_step(void)
 {
     /* Increment game time */
     total_time++;
 #ifdef DEBUG_ENGINE
-    printf (&quot;In do_time_step (%d)\n&quot;, total_time);
+    printf(&quot;In do_time_step (%d)\n&quot;, total_time);
 #endif
 
     /* Initialize daily accumulators */
@@ -74,281 +73,261 @@
 
     /* Initialize monthly accumulators */
     if (total_time % NUMOF_DAYS_IN_MONTH == 0) {
-	init_monthly();
+        init_monthly();
     }
 
     /* Initialize yearly accumulators */
     if ((total_time % NUMOF_DAYS_IN_YEAR) == 0) {
-	init_yearly();
+        init_yearly();
     }
 
     /* Clear the power grid */
-    power_time_step ();
+    power_time_step();
 
     /* Run through simulation equations for each farm, residence, etc. */
-    simulate_mappoints ();
+    simulate_mappoints();
 
     /* Now do the stuff that happens once a year, once a month, etc. */
-    do_periodic_events ();
+    do_periodic_events();
 }
 
-static void 
-nullify_mappoint (int x, int y)
+static void nullify_mappoint(int x, int y)
 {
-    MP_TYPE(x,y) = CST_GREEN;
-    MP_GROUP(x,y) = GROUP_BARE;
-    MP_SIZE(x,y) = 1;
-    MP_POL(x,y) = 0;
-    MP_INFO(x,y).population = 0;
-    MP_INFO(x,y).flags = 0;
-    MP_INFO(x,y).coal_reserve = 0;
-    MP_INFO(x,y).ore_reserve = 0;
-    MP_INFO(x,y).int_1 = 0;
-    MP_INFO(x,y).int_2 = 0;
-    MP_INFO(x,y).int_3 = 0;
-    MP_INFO(x,y).int_4 = 0;
-    MP_INFO(x,y).int_5 = 0;
-    MP_INFO(x,y).int_6 = 0;
-    MP_INFO(x,y).int_7 = 0;
+    MP_TYPE(x, y) = CST_GREEN;
+    MP_GROUP(x, y) = GROUP_BARE;
+    MP_SIZE(x, y) = 1;
+    MP_POL(x, y) = 0;
+    MP_INFO(x, y).population = 0;
+    MP_INFO(x, y).flags = 0;
+    MP_INFO(x, y).coal_reserve = 0;
+    MP_INFO(x, y).ore_reserve = 0;
+    MP_INFO(x, y).int_1 = 0;
+    MP_INFO(x, y).int_2 = 0;
+    MP_INFO(x, y).int_3 = 0;
+    MP_INFO(x, y).int_4 = 0;
+    MP_INFO(x, y).int_5 = 0;
+    MP_INFO(x, y).int_6 = 0;
+    MP_INFO(x, y).int_7 = 0;
 }
 
-static void 
-simulate_mappoints (void)
+static void simulate_mappoints(void)
 {
     int xx, yy;
-    shuffle_mappoint_array ();
+    shuffle_mappoint_array();
     for (yy = 0; yy &lt; WORLD_SIDE_LEN; yy++) {
-	/* indirection to rand array to stop lots of linear effects */
-	int y = mappoint_array_y[yy];
-	for (xx = 0; xx &lt; WORLD_SIDE_LEN; xx++) {
-	    int x = mappoint_array_x[xx];
-	    short grp = MP_GROUP(x,y);
-	    if (grp == GROUP_USED || GROUP_IS_BARE(grp))
-		continue;
-	    switch (grp) {
-	    case GROUP_TRACK:
-		do_track (x, y);
-		break;
-	    case GROUP_RAIL:
-		do_rail (x, y);
-		break;
-	    case GROUP_ROAD:
-		do_road (x, y);
-		break;
-	    case GROUP_ORGANIC_FARM:
-		do_organic_farm (x, y);
-		break;
-	    case GROUP_MARKET:
-		do_market (x, y);
-		break;
-	    case GROUP_RESIDENCE_LL:
-		do_residence (x, y);
-		break;
-	    case GROUP_RESIDENCE_ML:
-		do_residence (x, y);
-		break;
-	    case GROUP_RESIDENCE_HL:
-		do_residence (x, y);
-		break;
-	    case GROUP_RESIDENCE_LH:
-		do_residence (x, y);
-		break;
-	    case GROUP_RESIDENCE_MH:
-		do_residence (x, y);
-		break;
-	    case GROUP_RESIDENCE_HH:
-		do_residence (x, y);
-		break;
-	    case GROUP_POWER_LINE:
-	        do_power_line (x, y);
-		break;
-	    case GROUP_SOLAR_POWER:
-		do_power_source (x, y);
-		break;
-	    case GROUP_SUBSTATION:
-		do_power_substation (x, y);
-		break;
-	    case GROUP_COALMINE:
-		do_coalmine (x, y);
-		break;
-	    case GROUP_COAL_POWER:
-		do_power_source_coal (x, y);
-		break;
-	    case GROUP_INDUSTRY_L:
-		do_industry_l (x, y);
-		break;
-	    case GROUP_INDUSTRY_H:
-		do_industry_h (x, y);
-		break;
-	    case GROUP_COMMUNE:
-		do_commune (x, y);
-		break;
-	    case GROUP_OREMINE:
-		do_oremine (x, y);
-		break;
-	    case GROUP_PORT:
-		do_port (x, y);
-		break;
-	    case GROUP_TIP:
-		do_tip (x, y);
-		break;
-	    case GROUP_PARKLAND:
-		do_parkland (x, y);
-		break;
-	    case GROUP_UNIVERSITY:
-		do_university (x, y);
-		break;
-	    case GROUP_RECYCLE:
-		do_recycle (x, y);
-		break;
-	    case GROUP_HEALTH:
-		do_health_centre (x, y);
-		break;
-	    case GROUP_ROCKET:
-		do_rocket_pad (x, y);
-		break;
-	    case GROUP_WINDMILL:
-		do_windmill (x, y);
-		break;
-	    case GROUP_MONUMENT:
-		do_monument (x, y);
-		break;
-	    case GROUP_SCHOOL:
-		do_school (x, y);
-		break;
-	    case GROUP_BLACKSMITH:
-		do_blacksmith (x, y);
-		break;
-	    case GROUP_MILL:
-		do_mill (x, y);
-		break;
-	    case GROUP_POTTERY:
-		do_pottery (x, y);
-		break;
-	    case GROUP_FIRESTATION:
-		do_firestation (x, y);
-		break;
-	    case GROUP_CRICKET:
-		do_cricket (x, y);
-		break;
-	    case GROUP_FIRE:
-		do_fire (x, y);
-		break;
-	    case GROUP_SHANTY:
-		do_shanty (x, y);
-		break;
-	    }
-	}
+        /* indirection to rand array to stop lots of linear effects */
+        int y = mappoint_array_y[yy];
+        for (xx = 0; xx &lt; WORLD_SIDE_LEN; xx++) {
+            int x = mappoint_array_x[xx];
+            short grp = MP_GROUP(x, y);
+            if (grp == GROUP_USED || GROUP_IS_BARE(grp))
+                continue;
+            switch (grp) {
+            case GROUP_TRACK:
+                do_track(x, y);
+                break;
+            case GROUP_RAIL:
+                do_rail(x, y);
+                break;
+            case GROUP_ROAD:
+                do_road(x, y);
+                break;
+            case GROUP_ORGANIC_FARM:
+                do_organic_farm(x, y);
+                break;
+            case GROUP_MARKET:
+                do_market(x, y);
+                break;
+            case GROUP_RESIDENCE_LL:
+                do_residence(x, y);
+                break;
+            case GROUP_RESIDENCE_ML:
+                do_residence(x, y);
+                break;
+            case GROUP_RESIDENCE_HL:
+                do_residence(x, y);
+                break;
+            case GROUP_RESIDENCE_LH:
+                do_residence(x, y);
+                break;
+            case GROUP_RESIDENCE_MH:
+                do_residence(x, y);
+                break;
+            case GROUP_RESIDENCE_HH:
+                do_residence(x, y);
+                break;
+            case GROUP_POWER_LINE:
+                do_power_line(x, y);
+                break;
+            case GROUP_SOLAR_POWER:
+                do_power_source(x, y);
+                break;
+            case GROUP_SUBSTATION:
+                do_power_substation(x, y);
+                break;
+            case GROUP_COALMINE:
+                do_coalmine(x, y);
+                break;
+            case GROUP_COAL_POWER:
+                do_power_source_coal(x, y);
+                break;
+            case GROUP_INDUSTRY_L:
+                do_industry_l(x, y);
+                break;
+            case GROUP_INDUSTRY_H:
+                do_industry_h(x, y);
+                break;
+            case GROUP_COMMUNE:
+                do_commune(x, y);
+                break;
+            case GROUP_OREMINE:
+                do_oremine(x, y);
+                break;
+            case GROUP_PORT:
+                do_port(x, y);
+                break;
+            case GROUP_TIP:
+                do_tip(x, y);
+                break;
+            case GROUP_PARKLAND:
+                do_parkland(x, y);
+                break;
+            case GROUP_UNIVERSITY:
+                do_university(x, y);
+                break;
+            case GROUP_RECYCLE:
+                do_recycle(x, y);
+                break;
+            case GROUP_HEALTH:
+                do_health_centre(x, y);
+                break;
+            case GROUP_ROCKET:
+                do_rocket_pad(x, y);
+                break;
+            case GROUP_WINDMILL:
+                do_windmill(x, y);
+                break;
+            case GROUP_MONUMENT:
+                do_monument(x, y);
+                break;
+            case GROUP_SCHOOL:
+                do_school(x, y);
+                break;
+            case GROUP_BLACKSMITH:
+                do_blacksmith(x, y);
+                break;
+            case GROUP_MILL:
+                do_mill(x, y);
+                break;
+            case GROUP_POTTERY:
+                do_pottery(x, y);
+                break;
+            case GROUP_FIRESTATION:
+                do_firestation(x, y);
+                break;
+            case GROUP_CRICKET:
+                do_cricket(x, y);
+                break;
+            case GROUP_FIRE:
+                do_fire(x, y);
+                break;
+            case GROUP_SHANTY:
+                do_shanty(x, y);
+                break;
+            }
+        }
     }
 }
 
 /* ---------------------------------------------------------------------- *
  * Private Functions
  * ---------------------------------------------------------------------- */
-static void
-do_periodic_events (void)
+static void do_periodic_events(void)
 {
-  add_daily_to_monthly();
-  do_daily_ecology ();
+    add_daily_to_monthly();
+    do_daily_ecology();
 
-  if ((total_time % NUMOF_DAYS_IN_YEAR) == 0) {
-    start_of_year_update ();
-  }
-  if ((total_time % DAYS_PER_POLLUTION) == 3) {
-    do_pollution ();
-  }
-  if ((total_time % DAYS_BETWEEN_FIRES) == 9
-      &amp;&amp; tech_level &gt; (GROUP_FIRESTATION_TECH * MAX_TECH_LEVEL / 1000)) {
-    do_random_fire (-1, -1, 1);
-  }
-  if ((total_time % DAYS_BETWEEN_COVER) == 75) {
-    clear_fire_health_and_cricket_cover ();
-    do_fire_health_and_cricket_cover ();
-  }
-  if ((total_time % DAYS_BETWEEN_SHANTY) == 85
-      &amp;&amp; tech_level &gt; (GROUP_HEALTH_TECH * MAX_TECH_LEVEL / 1000)) {
-   update_shanty ();
-  }
-  if (total_time % NUMOF_DAYS_IN_MONTH == (NUMOF_DAYS_IN_MONTH - 1)) {
-    end_of_month_update ();
-  }
-  if (total_time % NUMOF_DAYS_IN_YEAR == (NUMOF_DAYS_IN_YEAR - 1)) {
-    end_of_year_update ();
-  }
+    if ((total_time % NUMOF_DAYS_IN_YEAR) == 0) {
+        start_of_year_update();
+    }
+    if ((total_time % DAYS_PER_POLLUTION) == 3) {
+        do_pollution();
+    }
+    if ((total_time % DAYS_BETWEEN_FIRES) == 9 &amp;&amp; tech_level &gt; (GROUP_FIRESTATION_TECH * MAX_TECH_LEVEL / 1000)) {
+        do_random_fire(-1, -1, 1);
+    }
+    if ((total_time % DAYS_BETWEEN_COVER) == 75) {
+        clear_fire_health_and_cricket_cover();
+        do_fire_health_and_cricket_cover();
+    }
+    if ((total_time % DAYS_BETWEEN_SHANTY) == 85 &amp;&amp; tech_level &gt; (GROUP_HEALTH_TECH * MAX_TECH_LEVEL / 1000)) {
+        update_shanty();
+    }
+    if (total_time % NUMOF_DAYS_IN_MONTH == (NUMOF_DAYS_IN_MONTH - 1)) {
+        end_of_month_update();
+    }
+    if (total_time % NUMOF_DAYS_IN_YEAR == (NUMOF_DAYS_IN_YEAR - 1)) {
+        end_of_year_update();
+    }
 }
 
-
-static void 
-end_of_month_update (void)
+static void end_of_month_update(void)
 {
-  /* GCS FIX -- seems to be a bit of engine code embedded in 
-     do_monthgraph(), such as coal_made, coal_used, etc.
-     Check it out soon... */
-  housed_population = (tpopulation / NUMOF_DAYS_IN_MONTH);
-  if ((housed_population + people_pool) &gt; max_pop_ever)
-    max_pop_ever = housed_population + people_pool;
+    /* GCS FIX -- seems to be a bit of engine code embedded in 
+       do_monthgraph(), such as coal_made, coal_used, etc.
+       Check it out soon... */
+    housed_population = (tpopulation / NUMOF_DAYS_IN_MONTH);
+    if ((housed_population + people_pool) &gt; max_pop_ever)
+        max_pop_ever = housed_population + people_pool;
 
-  if (people_pool &gt; 100) {
-    if (rand () % 1000 &lt; people_pool)
-      people_pool -= 10;
-  }
-  if (people_pool &lt; 0)
-    people_pool = 0;
+    if (people_pool &gt; 100) {
+        if (rand() % 1000 &lt; people_pool)
+            people_pool -= 10;
+    }
+    if (people_pool &lt; 0)
+        people_pool = 0;
 
-  if (tech_level &gt; TECH_LEVEL_LOSS_START)
-    {
-      tech_level-=(int)(tech_level*(1./TECH_LEVEL_LOSS)
-	*(1+(tpopulation
-	     *(1./NUMOF_DAYS_IN_MONTH/120
-	       /(TECH_LEVEL_LOSS-200)))));
+    if (tech_level &gt; TECH_LEVEL_LOSS_START) {
+        tech_level -= (int)(tech_level * (1. / TECH_LEVEL_LOSS)
+                            * (1 + (tpopulation * (1. / NUMOF_DAYS_IN_MONTH / 120 / (TECH_LEVEL_LOSS - 200)))));
 
-    }
-  else
-    tech_level += TECH_LEVEL_UNAIDED;
-  /* we can go over 100, but it's even more difficult */
-  if (tech_level &gt; MAX_TECH_LEVEL)
-    tech_level-=(int)((tech_level-MAX_TECH_LEVEL)
-      *(1./TECH_LEVEL_LOSS)
-      *(1+(tpopulation
-	   *(1./NUMOF_DAYS_IN_MONTH/120
-	     /(TECH_LEVEL_LOSS-100)))));
+    } else
+        tech_level += TECH_LEVEL_UNAIDED;
+    /* we can go over 100, but it's even more difficult */
+    if (tech_level &gt; MAX_TECH_LEVEL)
+        tech_level -= (int)((tech_level - MAX_TECH_LEVEL)
+                            * (1. / TECH_LEVEL_LOSS)
+                            * (1 + (tpopulation * (1. / NUMOF_DAYS_IN_MONTH / 120 / (TECH_LEVEL_LOSS - 100)))));
 
-  if (highest_tech_level &lt; tech_level)
-    highest_tech_level = tech_level;
+    if (highest_tech_level &lt; tech_level)
+        highest_tech_level = tech_level;
 
-  deaths_cost += unnat_deaths * UNNAT_DEATHS_COST;
+    deaths_cost += unnat_deaths * UNNAT_DEATHS_COST;
 
 }
 
-
-static void 
-start_of_year_update (void)
+static void start_of_year_update(void)
 {
-  int u;
+    int u;
 
-  sustainability_test ();
+    sustainability_test();
 
-  pollution_deaths_history
-    -= pollution_deaths_history / 100.0;
-  starve_deaths_history
-    -= starve_deaths_history / 100.0;
-  unemployed_history
-    -= unemployed_history / 100.0;
-  u = count_groups (GROUP_UNIVERSITY);
-  if (u &gt; 0) {
-    university_intake_rate = (count_groups (GROUP_SCHOOL) * 20) / u;
-    if (university_intake_rate &gt; 100)
-      university_intake_rate = 100;
-  } else {
-    university_intake_rate = 50;
-  }
+    pollution_deaths_history -= pollution_deaths_history / 100.0;
+    starve_deaths_history -= starve_deaths_history / 100.0;
+    unemployed_history -= unemployed_history / 100.0;
+    u = count_groups(GROUP_UNIVERSITY);
+    if (u &gt; 0) {
+        university_intake_rate = (count_groups(GROUP_SCHOOL) * 20) / u;
+        if (university_intake_rate &gt; 100)
+            university_intake_rate = 100;
+    } else {
+        university_intake_rate = 50;
+    }
 
-  map_power_grid();
+    map_power_grid();
 }
 
-
-static void 
-end_of_year_update (void)
+static void end_of_year_update(void)
 {
     income_tax = (income_tax * income_tax_rate) / 100;
     ly_income_tax = income_tax;
@@ -359,23 +338,21 @@
     total_money += coal_tax;
 
     goods_tax = (goods_tax * goods_tax_rate) / 100;
-    goods_tax += (int) ((float) (goods_tax * goods_tax_rate)
-			   * (float) tech_level / 2000000.0);
+    goods_tax += (int)((float)(goods_tax * goods_tax_rate)
+                       * (float)tech_level / 2000000.0);
     ly_goods_tax = goods_tax;
     total_money += goods_tax;
 
     /* The price of exports on the world market drops as you export more.
        The exporters have to discount there wares, therefore the 
        tax take is less.
-    */
-    if (export_tax &gt; ex_tax_dis[0])
-    {
-	int discount, disi;
-	discount = 0;
-	for (disi = 0; disi &lt; NUMOF_DISCOUNT_TRIGGERS
-		     &amp;&amp; export_tax &gt; ex_tax_dis[disi]; disi++)
-	    discount += (export_tax - ex_tax_dis[disi]) / 10;
-	export_tax -= discount;
+     */
+    if (export_tax &gt; ex_tax_dis[0]) {
+        int discount, disi;
+        discount = 0;
+        for (disi = 0; disi &lt; NUMOF_DISCOUNT_TRIGGERS &amp;&amp; export_tax &gt; ex_tax_dis[disi]; disi++)
+            discount += (export_tax - ex_tax_dis[disi]) / 10;
+        export_tax -= discount;
     }
     ly_export_tax = export_tax;
     total_money += export_tax;
@@ -384,26 +361,22 @@
     ly_recycle_cost = recycle_cost;
     ly_deaths_cost = deaths_cost;
     ly_health_cost = (health_cost * (tech_level / 10000)
-		      * HEALTH_RUNNING_COST_MUL) / (MAX_TECH_LEVEL / 10000);
+                      * HEALTH_RUNNING_COST_MUL) / (MAX_TECH_LEVEL / 10000);
     ly_rocket_pad_cost = rocket_pad_cost;
     ly_school_cost = school_cost;
     ly_windmill_cost = windmill_cost;
     ly_fire_cost = (fire_cost * (tech_level / 10000)
-		    * FIRESTATION_RUNNING_COST_MUL) / (MAX_TECH_LEVEL / 10000);
+                    * FIRESTATION_RUNNING_COST_MUL) / (MAX_TECH_LEVEL / 10000);
     ly_cricket_cost = cricket_cost;
-    if (total_money &lt; 0)
-    {
-	ly_interest = ((-total_money / 1000) * INTEREST_RATE);
-	if (ly_interest &gt; 1000000)
-	    ly_interest = 1000000;
-    }
-    else
-	ly_interest = 0;
+    if (total_money &lt; 0) {
+        ly_interest = ((-total_money / 1000) * INTEREST_RATE);
+        if (ly_interest &gt; 1000000)
+            ly_interest = 1000000;
+    } else
+        ly_interest = 0;
 
     other_cost = university_cost + recycle_cost + deaths_cost
-	    + ly_health_cost + rocket_pad_cost + school_cost
-	    + ly_interest + windmill_cost + ly_fire_cost
-	    + ly_cricket_cost;
+        + ly_health_cost + rocket_pad_cost + school_cost + ly_interest + windmill_cost + ly_fire_cost + ly_cricket_cost;
     ly_other_cost = other_cost;
     total_money -= other_cost;
 
@@ -420,22 +393,20 @@
     total_money -= import_cost;
 
     if (total_money &gt; 2000000000)
-	total_money = 2000000000;
+        total_money = 2000000000;
     else if (total_money &lt; -2000000000)
-	total_money = -2000000000;
+        total_money = -2000000000;
 
-    print_total_money ();
+    print_total_money();
 }
 
-
-static void
-clear_game (void)
+static void clear_game(void)
 {
     int x, y;
     for (y = 0; y &lt; WORLD_SIDE_LEN; y++) {
-	for (x = 0; x &lt; WORLD_SIDE_LEN; x++) {
-	    nullify_mappoint (x, y);
-	}
+        for (x = 0; x &lt; WORLD_SIDE_LEN; x++) {
+            nullify_mappoint(x, y);
+        }
     }
     total_time = 0;
     coal_survey_done = 0;
@@ -460,348 +431,332 @@
     ldsv_version = MIN_WATERWELL_VERSION;
 }
 
-void
-new_city (int* originx, int* originy, int random_village)
+void new_city(int *originx, int *originy, int random_village)
 {
-    clear_game ();
-    coal_reserve_setup ();
-    setup_river ();
-    setup_land ();
-    ore_reserve_setup ();
-    init_pbars ();
+    clear_game();
+    coal_reserve_setup();
+    setup_river();
+    setup_land();
+    ore_reserve_setup();
+    init_pbars();
 
     /* Initial population is 100 for empty board or 200 
        for random village (100 are housed). */
     people_pool = 100;
 
     if (random_village != 0) {
-	random_start (originx, originy);
-	update_pbar(PPOP,200,1); /* So pbars don't flash */
+        random_start(originx, originy);
+        update_pbar(PPOP, 200, 1);      /* So pbars don't flash */
     } else {
-	*originx = *originy = WORLD_SIDE_LEN/2 ;
-	update_pbar(PPOP,100,1);
+        *originx = *originy = WORLD_SIDE_LEN / 2;
+        update_pbar(PPOP, 100, 1);
     }
-    connect_transport (1,1,WORLD_SIDE_LEN-2,WORLD_SIDE_LEN-2);
-    refresh_pbars ();
+    connect_transport(1, 1, WORLD_SIDE_LEN - 2, WORLD_SIDE_LEN - 2);
+    refresh_pbars();
 }
 
-void
-coal_reserve_setup (void)
+void coal_reserve_setup(void)
 {
-  int i, j, x, y, xx, yy;
-  for (i = 0; i &lt; NUMOF_COAL_RESERVES / 5; i++)
-    {
-      x = (rand () % (WORLD_SIDE_LEN - 12)) + 6;
-      y = (rand () % (WORLD_SIDE_LEN - 10)) + 6;
-      do
-	{
-	  xx = (rand () % 3) - 1;
-	  yy = (rand () % 3) - 1;
-	}
-      while (xx == 0 &amp;&amp; yy == 0);
-      for (j = 0; j &lt; 5; j++)
-	{
-	  MP_INFO(x,y).coal_reserve
-	    += rand () % COAL_RESERVE_SIZE;
-	  x += xx;
-	  y += yy;
-	}
+    int i, j, x, y, xx, yy;
+    for (i = 0; i &lt; NUMOF_COAL_RESERVES / 5; i++) {
+        x = (rand() % (WORLD_SIDE_LEN - 12)) + 6;
+        y = (rand() % (WORLD_SIDE_LEN - 10)) + 6;
+        do {
+            xx = (rand() % 3) - 1;
+            yy = (rand() % 3) - 1;
+        }
+        while (xx == 0 &amp;&amp; yy == 0);
+        for (j = 0; j &lt; 5; j++) {
+            MP_INFO(x, y).coal_reserve += rand() % COAL_RESERVE_SIZE;
+            x += xx;
+            y += yy;
+        }
     }
 }
 
-void
-ore_reserve_setup (void)
+void ore_reserve_setup(void)
 {
     int x, y;
     for (y = 0; y &lt; WORLD_SIDE_LEN; y++)
-	for (x = 0; x &lt; WORLD_SIDE_LEN; x++)
-	    MP_INFO(x,y).ore_reserve = ORE_RESERVE;
+        for (x = 0; x &lt; WORLD_SIDE_LEN; x++)
+            MP_INFO(x, y).ore_reserve = ORE_RESERVE;
 }
 
-void
-setup_river (void)
+void setup_river(void)
 {
     int x, y, i, j;
-    x = (1 * WORLD_SIDE_LEN  + rand () % WORLD_SIDE_LEN) / 3 ;
+    x = (1 * WORLD_SIDE_LEN + rand() % WORLD_SIDE_LEN) / 3;
     y = WORLD_SIDE_LEN - 1;
-    i = (rand () % 12) + 6;
+    i = (rand() % 12) + 6;
     for (j = 0; j &lt; i; j++) {
-	x += (rand () % 3) - 1;
-	MP_TYPE(x,y) = CST_WATER;
-	MP_GROUP(x,y) = GROUP_WATER;
-	MP_INFO(x,y).flags |= FLAG_IS_RIVER;
-	MP_TYPE(x+1,y) = CST_WATER;
-	MP_GROUP(x+1,y) = GROUP_WATER;
-	MP_INFO(x+1,y).flags |= FLAG_IS_RIVER;
-	MP_TYPE(x-1,y) = CST_WATER;
-	MP_GROUP(x-1,y) = GROUP_WATER;
-	MP_INFO(x-1,y).flags |= FLAG_IS_RIVER;
-	y--;
+        x += (rand() % 3) - 1;
+        MP_TYPE(x, y) = CST_WATER;
+        MP_GROUP(x, y) = GROUP_WATER;
+        MP_INFO(x, y).flags |= FLAG_IS_RIVER;
+        MP_TYPE(x + 1, y) = CST_WATER;
+        MP_GROUP(x + 1, y) = GROUP_WATER;
+        MP_INFO(x + 1, y).flags |= FLAG_IS_RIVER;
+        MP_TYPE(x - 1, y) = CST_WATER;
+        MP_GROUP(x - 1, y) = GROUP_WATER;
+        MP_INFO(x - 1, y).flags |= FLAG_IS_RIVER;
+        y--;
     }
-    MP_TYPE(x,y) = CST_WATER;
-    MP_GROUP(x,y) = GROUP_WATER;
-    MP_INFO(x,y).flags |= FLAG_IS_RIVER;
-    MP_TYPE(x+1,y) = CST_WATER;
-    MP_GROUP(x+1,y) = GROUP_WATER;
-    MP_INFO(x+1,y).flags |= FLAG_IS_RIVER;
-    MP_TYPE(x-1,y) = CST_WATER;
-    MP_GROUP(x-1,y) = GROUP_WATER;
-    MP_INFO(x-1,y).flags |= FLAG_IS_RIVER;
+    MP_TYPE(x, y) = CST_WATER;
+    MP_GROUP(x, y) = GROUP_WATER;
+    MP_INFO(x, y).flags |= FLAG_IS_RIVER;
+    MP_TYPE(x + 1, y) = CST_WATER;
+    MP_GROUP(x + 1, y) = GROUP_WATER;
+    MP_INFO(x + 1, y).flags |= FLAG_IS_RIVER;
+    MP_TYPE(x - 1, y) = CST_WATER;
+    MP_GROUP(x - 1, y) = GROUP_WATER;
+    MP_INFO(x - 1, y).flags |= FLAG_IS_RIVER;
 
-    setup_river2 (x - 1, y, -1);	/* left tributary */
-    setup_river2 (x + 1, y, 1);	/* right tributary */
+    setup_river2(x - 1, y, -1); /* left tributary */
+    setup_river2(x + 1, y, 1);  /* right tributary */
 }
 
-void
-setup_river2 (int x, int y, int d)
+void setup_river2(int x, int y, int d)
 {
     int i, j, r;
-    i = (rand () % 55) + 15;
-    for (j = 0; j &lt; i; j++)
-    {
-	r = (rand () % 3) - 1 + (d * (rand () % 3));
-	if (r &lt; -1)
-	    r = -1;
-	else if (r &gt; 1)
-	    r = 1;
-	x += r;
-	if (!GROUP_IS_BARE(MP_GROUP(x+(d+d),y))
-	    || !GROUP_IS_BARE(MP_GROUP(x+(d+d+d),y)) )
-	    return;
-	if (x &gt; 5 &amp;&amp; x &lt; WORLD_SIDE_LEN - 5)
-	{
-	    MP_TYPE(x,y) = CST_WATER;
-	    MP_GROUP(x,y) = GROUP_WATER;
-	    MP_INFO(x,y).flags |= FLAG_IS_RIVER;
-	    MP_TYPE(x + d,y) = CST_WATER;
-	    MP_GROUP(x+d,y) = GROUP_WATER;
-	    MP_INFO(x+d,y).flags |= FLAG_IS_RIVER;
-	}
-	if (--y &lt; 10 || x &lt; 5 || x &gt; WORLD_SIDE_LEN - 5)
-	    break;
+    i = (rand() % 55) + 15;
+    for (j = 0; j &lt; i; j++) {
+        r = (rand() % 3) - 1 + (d * (rand() % 3));
+        if (r &lt; -1)
+            r = -1;
+        else if (r &gt; 1)
+            r = 1;
+        x += r;
+        if (!GROUP_IS_BARE(MP_GROUP(x + (d + d), y))
+            || !GROUP_IS_BARE(MP_GROUP(x + (d + d + d), y)))
+            return;
+        if (x &gt; 5 &amp;&amp; x &lt; WORLD_SIDE_LEN - 5) {
+            MP_TYPE(x, y) = CST_WATER;
+            MP_GROUP(x, y) = GROUP_WATER;
+            MP_INFO(x, y).flags |= FLAG_IS_RIVER;
+            MP_TYPE(x + d, y) = CST_WATER;
+            MP_GROUP(x + d, y) = GROUP_WATER;
+            MP_INFO(x + d, y).flags |= FLAG_IS_RIVER;
+        }
+        if (--y &lt; 10 || x &lt; 5 || x &gt; WORLD_SIDE_LEN - 5)
+            break;
     }
-    if (y &gt; 20)
-    {
-	if (x &gt; 5 &amp;&amp; x &lt; WORLD_SIDE_LEN - 5)
-	    setup_river2 (x, y, -1);
-	if (x &gt; 5 &amp;&amp; x &lt; WORLD_SIDE_LEN - 5)
-	    setup_river2 (x, y, 1);
+    if (y &gt; 20) {
+        if (x &gt; 5 &amp;&amp; x &lt; WORLD_SIDE_LEN - 5)
+            setup_river2(x, y, -1);
+        if (x &gt; 5 &amp;&amp; x &lt; WORLD_SIDE_LEN - 5)
+            setup_river2(x, y, 1);
     }
 }
 
-void
-setup_land (void)
+void setup_land(void)
 {
-  int x, y, xw, yw;
-  int aridity = rand () %400 -150;
-  for (y = 0; y &lt; WORLD_SIDE_LEN; y++) {
-	for (x = 0; x &lt; WORLD_SIDE_LEN; x++) {
-	    int d2w_min = 2 * WORLD_SIDE_LEN * WORLD_SIDE_LEN;
-	    int r;
-	    int arid=aridity;
+    int x, y, xw, yw;
+    int aridity = rand() % 400 - 150;
+    for (y = 0; y &lt; WORLD_SIDE_LEN; y++) {
+        for (x = 0; x &lt; WORLD_SIDE_LEN; x++) {
+            int d2w_min = 2 * WORLD_SIDE_LEN * WORLD_SIDE_LEN;
+            int r;
+            int arid = aridity;
 
-	    /* test against IS_RIVER to prevent terrible recursion */
-	    if ( IS_RIVER(x,y) || !GROUP_IS_BARE(MP_GROUP(x,y)))
-		continue;
+            /* test against IS_RIVER to prevent terrible recursion */
+            if (IS_RIVER(x, y) || !GROUP_IS_BARE(MP_GROUP(x, y)))
+                continue;
 
-  	    for (yw = 0; yw &lt; WORLD_SIDE_LEN; yw++) {
-		  for (xw = 0; xw &lt; WORLD_SIDE_LEN; xw++) {
-			int d2w;
-			if (!IS_RIVER(xw,yw))
-				continue;
-			d2w = (xw-x)*(xw-x) + (yw-y)*(yw-y);
-			if (d2w &lt; d2w_min)
-				d2w_min = d2w;
-		  }
-	    }
+            for (yw = 0; yw &lt; WORLD_SIDE_LEN; yw++) {
+                for (xw = 0; xw &lt; WORLD_SIDE_LEN; xw++) {
+                    int d2w;
+                    if (!IS_RIVER(xw, yw))
+                        continue;
+                    d2w = (xw - x) * (xw - x) + (yw - y) * (yw - y);
+                    if (d2w &lt; d2w_min)
+                        d2w_min = d2w;
+                }
+            }
 
-	    /* near river lower aridity */
-	    if (aridity &gt; 0) {
-		if (d2w_min &lt; 5)
-			arid = aridity/3;
-		else if (d2w_min &lt; 17)
-			arid = (aridity*2)/3;
-	    }
-	    r = rand () % (d2w_min/3+1) + arid;
-	    if (r &gt;= 300) {
-	        /* very dry land */
-	    	int r2 = rand() % 10;
-	    	if (r2 &lt;= 6)
-		        set_mappoint(x, y, CST_DESERT);
-	    	else if (r2 &lt;= 8)
-		        set_mappoint(x, y, CST_GREEN);
-	    	else 
-		        set_mappoint(x, y, CST_TREE);
-	    } else if (r &gt;= 160) {
-	    	int r2 = rand() % 10;
-	        if (r2 &lt;= 2)
-	    	    set_mappoint(x, y, CST_DESERT);
-		else if (r2 &lt;= 6)
-	    	    set_mappoint(x, y, CST_GREEN);
-		else 
-	    	    set_mappoint(x, y, CST_TREE);
-	    } else if (r &gt;= 80) {
-	    	int r2 = rand() % 10;
-		if (r2 &lt;= 1)
-	    		set_mappoint(x, y, CST_DESERT);
+            /* near river lower aridity */
+            if (aridity &gt; 0) {
+                if (d2w_min &lt; 5)
+                    arid = aridity / 3;
+                else if (d2w_min &lt; 17)
+                    arid = (aridity * 2) / 3;
+            }
+            r = rand() % (d2w_min / 3 + 1) + arid;
+            if (r &gt;= 300) {
+                /* very dry land */
+                int r2 = rand() % 10;
+                if (r2 &lt;= 6)
+                    set_mappoint(x, y, CST_DESERT);
+                else if (r2 &lt;= 8)
+                    set_mappoint(x, y, CST_GREEN);
+                else
+                    set_mappoint(x, y, CST_TREE);
+            } else if (r &gt;= 160) {
+                int r2 = rand() % 10;
+                if (r2 &lt;= 2)
+                    set_mappoint(x, y, CST_DESERT);
+                else if (r2 &lt;= 6)
+                    set_mappoint(x, y, CST_GREEN);
+                else
+                    set_mappoint(x, y, CST_TREE);
+            } else if (r &gt;= 80) {
+                int r2 = rand() % 10;
+                if (r2 &lt;= 1)
+                    set_mappoint(x, y, CST_DESERT);
                 else if (r2 &lt;= 4)
-	    		set_mappoint(x, y, CST_GREEN);
+                    set_mappoint(x, y, CST_GREEN);
                 else if (r2 &lt;= 6)
-                        set_mappoint(x, y, CST_TREE);
+                    set_mappoint(x, y, CST_TREE);
                 else
-	    		set_mappoint(x, y, CST_TREE2);
+                    set_mappoint(x, y, CST_TREE2);
             } else if (r &gt;= 40) {
-	    	int r2 = rand() % 40;
-		    if (r2 == 0)
-	    		set_mappoint(x, y, CST_DESERT);
-		    else if (r2 &lt;= 12)
-	    		set_mappoint(x, y, CST_GREEN);
-		    else if (r2 &lt;= 24)
-	    		set_mappoint(x, y, CST_TREE);
-		    else if (r2 &lt;= 36)
-			    set_mappoint(x, y, CST_TREE2);
-		    else
-			    set_mappoint(x, y, CST_TREE3);
-	    }  else if (r &gt;= 0) {
-	    	    /* normal land */
-	    	    int r2 = rand() % 40;
-		    if (r2 &lt;= 10)
-	    		set_mappoint(x, y, CST_GREEN);
-		    else if (r2 &lt;= 20)
-	    		set_mappoint(x, y, CST_TREE);
-		    else if (r2 &lt;= 30)
-			    set_mappoint(x, y, CST_TREE2);
-		    else
-			    set_mappoint(x, y, CST_TREE3);
-	    } else if (r &gt;= -40) {
-	    	    /* forest */
-	    	    int r2 = rand() % 40;
-		    if (r2 &lt;= 5)
-	    		set_mappoint(x, y, CST_GREEN);
-		    else if (r2 &lt;= 10)
-	    		set_mappoint(x, y, CST_TREE);
-		    else if (r2 &lt;= 25)
-			    set_mappoint(x, y, CST_TREE2);
-		    else
-			    set_mappoint(x, y, CST_TREE3);
-	    } else if (r &gt;= -80) {
-	    	    int r2 = rand() % 40;
-		    if (r2 &lt;= 0)
-			    MP_TYPE(x, y) = CST_WATER;
-		    else if (r2 &lt;= 6)
-	    		set_mappoint(x, y, CST_GREEN);
-		    else if (r2 &lt;= 15)
-	    		set_mappoint(x, y, CST_TREE);
-		    else if (r2 &lt;= 28)
-			    set_mappoint(x, y, CST_TREE2);
-		    else
-			    set_mappoint(x, y, CST_TREE3);
-	    } else if (r &gt;= -120) {
-	    	    int r2 = rand() % 40;
-		    if (r2 &lt;= 1)
-			    MP_TYPE(x, y) = CST_WATER;
-		    else if (r2 &lt;= 6)
-	    		set_mappoint(x, y, CST_GREEN);
-		    else if (r2 &lt;= 16)
-	    		set_mappoint(x, y, CST_TREE);
-		    else if (r2 &lt;= 30)
-			    set_mappoint(x, y, CST_TREE2);
-		    else
-			    set_mappoint(x, y, CST_TREE3);
-	    } else {
-	    	/* wetland */
-	    	int r2 = rand() % 40;
-		    if (r2 &lt;= 3 )
-			    MP_TYPE(x, y) = CST_WATER;
-		    else if (r2 &lt;= 8)
-	    		set_mappoint(x, y, CST_GREEN);
-		    else if (r2 &lt;= 20)
-	    		set_mappoint(x, y, CST_TREE);
-		    else if (r2 &lt;= 35)
-			    set_mappoint(x, y, CST_TREE2);
-		    else
-			    set_mappoint(x, y, CST_TREE3);
-	    }
-	    MP_POL(x,y) = 0;
+                int r2 = rand() % 40;
+                if (r2 == 0)
+                    set_mappoint(x, y, CST_DESERT);
+                else if (r2 &lt;= 12)
+                    set_mappoint(x, y, CST_GREEN);
+                else if (r2 &lt;= 24)
+                    set_mappoint(x, y, CST_TREE);
+                else if (r2 &lt;= 36)
+                    set_mappoint(x, y, CST_TREE2);
+                else
+                    set_mappoint(x, y, CST_TREE3);
+            } else if (r &gt;= 0) {
+                /* normal land */
+                int r2 = rand() % 40;
+                if (r2 &lt;= 10)
+                    set_mappoint(x, y, CST_GREEN);
+                else if (r2 &lt;= 20)
+                    set_mappoint(x, y, CST_TREE);
+                else if (r2 &lt;= 30)
+                    set_mappoint(x, y, CST_TREE2);
+                else
+                    set_mappoint(x, y, CST_TREE3);
+            } else if (r &gt;= -40) {
+                /* forest */
+                int r2 = rand() % 40;
+                if (r2 &lt;= 5)
+                    set_mappoint(x, y, CST_GREEN);
+                else if (r2 &lt;= 10)
+                    set_mappoint(x, y, CST_TREE);
+                else if (r2 &lt;= 25)
+                    set_mappoint(x, y, CST_TREE2);
+                else
+                    set_mappoint(x, y, CST_TREE3);
+            } else if (r &gt;= -80) {
+                int r2 = rand() % 40;
+                if (r2 &lt;= 0)
+                    MP_TYPE(x, y) = CST_WATER;
+                else if (r2 &lt;= 6)
+                    set_mappoint(x, y, CST_GREEN);
+                else if (r2 &lt;= 15)
+                    set_mappoint(x, y, CST_TREE);
+                else if (r2 &lt;= 28)
+                    set_mappoint(x, y, CST_TREE2);
+                else
+                    set_mappoint(x, y, CST_TREE3);
+            } else if (r &gt;= -120) {
+                int r2 = rand() % 40;
+                if (r2 &lt;= 1)
+                    MP_TYPE(x, y) = CST_WATER;
+                else if (r2 &lt;= 6)
+                    set_mappoint(x, y, CST_GREEN);
+                else if (r2 &lt;= 16)
+                    set_mappoint(x, y, CST_TREE);
+                else if (r2 &lt;= 30)
+                    set_mappoint(x, y, CST_TREE2);
+                else
+                    set_mappoint(x, y, CST_TREE3);
+            } else {
+                /* wetland */
+                int r2 = rand() % 40;
+                if (r2 &lt;= 3)
+                    MP_TYPE(x, y) = CST_WATER;
+                else if (r2 &lt;= 8)
+                    set_mappoint(x, y, CST_GREEN);
+                else if (r2 &lt;= 20)
+                    set_mappoint(x, y, CST_TREE);
+                else if (r2 &lt;= 35)
+                    set_mappoint(x, y, CST_TREE2);
+                else
+                    set_mappoint(x, y, CST_TREE3);
+            }
+            MP_POL(x, y) = 0;
             /* preserve rivers, so that we can connect port later */
-            if (MP_TYPE(x,y) == CST_WATER){
-                int navigable = MP_INFO(x,y).flags &amp; FLAG_IS_RIVER;
+            if (MP_TYPE(x, y) == CST_WATER) {
+                int navigable = MP_INFO(x, y).flags &amp; FLAG_IS_RIVER;
                 set_mappoint(x, y, CST_WATER);
-                MP_INFO(x,y).flags |= navigable;
-                MP_INFO(x,y).flags |= FLAG_HAS_UNDERGROUND_WATER;            
-            } else if (MP_TYPE(x,y) != CST_DESERT) {
-            	MP_INFO(x,y).flags |= FLAG_HAS_UNDERGROUND_WATER;
-            }	
-  	    /* TODO Store square of distance to river for each tile */
-	    /* MP_DIST2RIVER(x,y) = d2w_min; */
+                MP_INFO(x, y).flags |= navigable;
+                MP_INFO(x, y).flags |= FLAG_HAS_UNDERGROUND_WATER;
+            } else if (MP_TYPE(x, y) != CST_DESERT) {
+                MP_INFO(x, y).flags |= FLAG_HAS_UNDERGROUND_WATER;
+            }
+            /* TODO Store square of distance to river for each tile */
+            /* MP_DIST2RIVER(x,y) = d2w_min; */
         }
     }
     connect_rivers();
 }
 
-int
-count_groups (int g)
+int count_groups(int g)
 {
-  int x, y, i;
-  i = 0;
-  for (y = 0; y &lt; WORLD_SIDE_LEN; y++)
-    for (x = 0; x &lt; WORLD_SIDE_LEN; x++)
-      if (MP_GROUP(x,y) == g)
-	i++;
-  return (i);
+    int x, y, i;
+    i = 0;
+    for (y = 0; y &lt; WORLD_SIDE_LEN; y++)
+        for (x = 0; x &lt; WORLD_SIDE_LEN; x++)
+            if (MP_GROUP(x, y) == g)
+                i++;
+    return (i);
 }
 
-void 
-count_all_groups (int* group_count)
+void count_all_groups(int *group_count)
 {
     int x, y;
     unsigned short t, g;
     for (x = 0; x &lt; NUM_OF_GROUPS; x++)
-	group_count[x] = 0;
+        group_count[x] = 0;
     for (y = 0; y &lt; WORLD_SIDE_LEN; y++) {
-	for (x = 0; x &lt; WORLD_SIDE_LEN; x++) {
-	    t = MP_TYPE(x,y);
-	    if (t != CST_USED &amp;&amp; !GROUP_IS_BARE(MP_GROUP(x,y)))  {
-		g = get_group_of_type(t);
-		group_count[g]++;
-	    }
-	}
+        for (x = 0; x &lt; WORLD_SIDE_LEN; x++) {
+            t = MP_TYPE(x, y);
+            if (t != CST_USED &amp;&amp; !GROUP_IS_BARE(MP_GROUP(x, y))) {
+                g = get_group_of_type(t);
+                group_count[g]++;
+            }
+        }
     }
 }
 
-static void
-random_start (int* originx, int* originy)
+static void random_start(int *originx, int *originy)
 {
     int x, y, xx, yy, flag, watchdog;
 
     /* first find a place that has some water. */
-    watchdog = 90;        /* if too many tries, random placement. */
+    watchdog = 90;              /* if too many tries, random placement. */
     do {
-	do {
-	    xx = rand () % (WORLD_SIDE_LEN - 25);
-	    yy = rand () % (WORLD_SIDE_LEN - 25);
-	    flag = 0;
-	    for (y = yy + 2; y &lt; yy + 23; y++)
-		for (x = xx + 2; x &lt; xx + 23; x++)
-		    if (IS_RIVER(x,y)) {
-			flag = 1;
-			x = xx + 23;   /* break out of loop */
-			y = yy + 23;   /* break out of loop */
-		    }
-	} while (flag == 0 &amp;&amp; (--watchdog) &gt; 1);
-	for (y = yy + 4; y &lt; yy + 22; y++)
-	    for (x = xx + 4; x &lt; xx + 22; x++)
+        do {
+            xx = rand() % (WORLD_SIDE_LEN - 25);
+            yy = rand() % (WORLD_SIDE_LEN - 25);
+            flag = 0;
+            for (y = yy + 2; y &lt; yy + 23; y++)
+                for (x = xx + 2; x &lt; xx + 23; x++)
+                    if (IS_RIVER(x, y)) {
+                        flag = 1;
+                        x = xx + 23;    /* break out of loop */
+                        y = yy + 23;    /* break out of loop */
+                    }
+        } while (flag == 0 &amp;&amp; (--watchdog) &gt; 1);
+        for (y = yy + 4; y &lt; yy + 22; y++)
+            for (x = xx + 4; x &lt; xx + 22; x++)
                 /* Don't put the village on a river, but don't care of
                  * isolated random water tiles putted by setup_land
                  */
-		if (IS_RIVER(x,y)) {
+                if (IS_RIVER(x, y)) {
                     flag = 0;
-                    x = xx + 22;   /* break out of loop */
-                    y = yy + 22;   /* break out of loop */
+                    x = xx + 22;        /* break out of loop */
+                    y = yy + 22;        /* break out of loop */
                 }
     } while (flag == 0 &amp;&amp; (--watchdog) &gt; 1);
 #ifdef DEBUG
-    fprintf(stderr,&quot;random village watchdog = %i\n&quot;, watchdog);
+    fprintf(stderr, &quot;random village watchdog = %i\n&quot;, watchdog);
 #endif
 
     /* These are going to be the main_screen_origin? vars */
@@ -809,196 +764,166 @@
     *originy = yy;
 
     /*  Draw the start scene. */
-    quick_start_add (xx + 5, yy + 5, CST_FARM_O0, 4);
+    quick_start_add(xx + 5, yy + 5, CST_FARM_O0, 4);
     /* The first two farms have more underground water */
     for (int i = 0; i &lt; MP_SIZE(xx + 5, yy + 5); i++)
         for (int j = 0; j &lt; MP_SIZE(xx + 5, yy + 5); j++)
             if (!HAS_UGWATER(xx + 5 + i, yy + 5 + j) &amp;&amp; (rand() % 2))
-               MP_INFO(xx + 5 + i, yy + 5 + j).flags
-                              |= FLAG_HAS_UNDERGROUND_WATER;
- 
-    quick_start_add (xx + 9, yy + 6, CST_RESIDENCE_ML, 3);
-    MP_INFO(xx + 9,yy + 6).population = 50;
-    MP_INFO(xx + 9,yy + 6).flags 
-                |= (FLAG_FED + FLAG_EMPLOYED + FLAG_WATERWELL_COVER);
-    quick_start_add (xx + 9, yy + 9, CST_POTTERY_0, 2);
-    quick_start_add (xx + 16, yy + 9, CST_WATERWELL, 2);
+                MP_INFO(xx + 5 + i, yy + 5 + j).flags |= FLAG_HAS_UNDERGROUND_WATER;
 
-    quick_start_add (xx + 14, yy + 6, CST_RESIDENCE_ML, 3);
-    MP_INFO(xx + 14,yy + 6).population = 50;
-    MP_INFO(xx + 14,yy + 6).flags 
-                |= (FLAG_FED + FLAG_EMPLOYED + FLAG_WATERWELL_COVER);
-    quick_start_add (xx + 17, yy + 5, CST_FARM_O0, 4);
+    quick_start_add(xx + 9, yy + 6, CST_RESIDENCE_ML, 3);
+    MP_INFO(xx + 9, yy + 6).population = 50;
+    MP_INFO(xx + 9, yy + 6).flags |= (FLAG_FED + FLAG_EMPLOYED + FLAG_WATERWELL_COVER);
+    quick_start_add(xx + 9, yy + 9, CST_POTTERY_0, 2);
+    quick_start_add(xx + 16, yy + 9, CST_WATERWELL, 2);
+
+    quick_start_add(xx + 14, yy + 6, CST_RESIDENCE_ML, 3);
+    MP_INFO(xx + 14, yy + 6).population = 50;
+    MP_INFO(xx + 14, yy + 6).flags |= (FLAG_FED + FLAG_EMPLOYED + FLAG_WATERWELL_COVER);
+    quick_start_add(xx + 17, yy + 5, CST_FARM_O0, 4);
     for (int i = 0; i &lt; MP_SIZE(xx + 17, yy + 5); i++)
         for (int j = 0; j &lt; MP_SIZE(xx + 17, yy + 5); j++)
             if (!HAS_UGWATER(xx + 17 + i, yy + 5 + j) &amp;&amp; (rand() % 2))
-                MP_INFO(xx + 17 + i, yy + 5 + j).flags 
-                              |= FLAG_HAS_UNDERGROUND_WATER; 
+                MP_INFO(xx + 17 + i, yy + 5 + j).flags |= FLAG_HAS_UNDERGROUND_WATER;
 
-    quick_start_add (xx + 14, yy + 9, CST_MARKET_EMPTY, 2);
+    quick_start_add(xx + 14, yy + 9, CST_MARKET_EMPTY, 2);
     marketx[numof_markets] = xx + 14;
     markety[numof_markets] = yy + 9;
     numof_markets++;
     /* Bootstrap markets with some stuff. */
-    MP_INFO(xx + 14,yy + 9).int_1 = 2000;
-    MP_INFO(xx + 14,yy + 9).int_2 = 10000;
-    MP_INFO(xx + 14,yy + 9).int_3 = 100;
-    MP_INFO(xx + 14,yy + 9).int_5 = 10000;
-    MP_INFO(xx + 14,yy + 9).flags 
-	    |= (FLAG_MB_FOOD + FLAG_MS_FOOD + FLAG_MB_JOBS
-		+ FLAG_MS_JOBS + FLAG_MB_COAL + FLAG_MS_COAL + FLAG_MB_ORE
-		+ FLAG_MS_ORE + FLAG_MB_GOODS + FLAG_MS_GOODS + FLAG_MB_STEEL
-		+ FLAG_MS_STEEL);
+    MP_INFO(xx + 14, yy + 9).int_1 = 2000;
+    MP_INFO(xx + 14, yy + 9).int_2 = 10000;
+    MP_INFO(xx + 14, yy + 9).int_3 = 100;
+    MP_INFO(xx + 14, yy + 9).int_5 = 10000;
+    MP_INFO(xx + 14, yy + 9).flags
+        |= (FLAG_MB_FOOD + FLAG_MS_FOOD + FLAG_MB_JOBS
+            + FLAG_MS_JOBS + FLAG_MB_COAL + FLAG_MS_COAL + FLAG_MB_ORE
+            + FLAG_MS_ORE + FLAG_MB_GOODS + FLAG_MS_GOODS + FLAG_MB_STEEL + FLAG_MS_STEEL);
 
-    for (x = 5; x &lt; 19; x++)
-    {
-	quick_start_add (xx + x, yy + 11, CST_TRACK_LR, 1);
-	MP_INFO(xx + x,yy + 11).flags |= FLAG_IS_TRANSPORT;
+    for (x = 5; x &lt; 19; x++) {
+        quick_start_add(xx + x, yy + 11, CST_TRACK_LR, 1);
+        MP_INFO(xx + x, yy + 11).flags |= FLAG_IS_TRANSPORT;
     }
-    quick_start_add (xx + 6, yy + 12, CST_COMMUNE_1, 4);
-    quick_start_add (xx + 6, yy + 17, CST_COMMUNE_1, 4);
-    quick_start_add (xx + 11, yy + 12, CST_COMMUNE_1, 4);
-    quick_start_add (xx + 11, yy + 17, CST_COMMUNE_1, 4);
-    quick_start_add (xx + 16, yy + 12, CST_COMMUNE_1, 4);
-    quick_start_add (xx + 16, yy + 17, CST_COMMUNE_1, 4);
+    quick_start_add(xx + 6, yy + 12, CST_COMMUNE_1, 4);
+    quick_start_add(xx + 6, yy + 17, CST_COMMUNE_1, 4);
+    quick_start_add(xx + 11, yy + 12, CST_COMMUNE_1, 4);
+    quick_start_add(xx + 11, yy + 17, CST_COMMUNE_1, 4);
+    quick_start_add(xx + 16, yy + 12, CST_COMMUNE_1, 4);
+    quick_start_add(xx + 16, yy + 17, CST_COMMUNE_1, 4);
 }
 
 /* XXX: WCK: What is up with this?  Why not just use set_mappoint?! */
-static void
-quick_start_add (int x, int y, short type, int size)
+static void quick_start_add(int x, int y, short type, int size)
 {
-  int xx, yy;
-  if (size == 1) {
-      MP_TYPE(x,y) = type;
-      MP_GROUP(x,y) = get_group_of_type(type);
-      return;
-  }
-  for (yy = 0; yy &lt; size; yy++) {
-    for (xx = 0; xx &lt; size; xx++) {
-	if (xx == 0 &amp;&amp; yy == 0)
-	  continue;
-	set_mappoint_used (x, y, x + xx, y + yy);
-      }
-  }
-  MP_TYPE(x,y) = type;
-  MP_GROUP(x,y) = get_group_of_type(type);
+    int xx, yy;
+    if (size == 1) {
+        MP_TYPE(x, y) = type;
+        MP_GROUP(x, y) = get_group_of_type(type);
+        return;
+    }
+    for (yy = 0; yy &lt; size; yy++) {
+        for (xx = 0; xx &lt; size; xx++) {
+            if (xx == 0 &amp;&amp; yy == 0)
+                continue;
+            set_mappoint_used(x, y, x + xx, y + yy);
+        }
+    }
+    MP_TYPE(x, y) = type;
+    MP_GROUP(x, y) = get_group_of_type(type);
 }
 
-void
-sustainability_test (void)
+void sustainability_test(void)
 {
-  int i;
-  if (sust_dig_ore_coal_tip_flag == 0)
-    {
-      sust_dig_ore_coal_tip_flag = 1;
-      sust_dig_ore_coal_count = 0;
-    }
-  else
-    sust_dig_ore_coal_count++;
+    int i;
+    if (sust_dig_ore_coal_tip_flag == 0) {
+        sust_dig_ore_coal_tip_flag = 1;
+        sust_dig_ore_coal_count = 0;
+    } else
+        sust_dig_ore_coal_count++;
 
-  if (sust_port_flag == 0)
-    {
-      sust_port_flag = 1;
-      sust_port_count = 0;
-    }
-  else
-    sust_port_count++;
+    if (sust_port_flag == 0) {
+        sust_port_flag = 1;
+        sust_port_count = 0;
+    } else
+        sust_port_count++;
 
-  /* Money must be going up or the same. (ie can't build.) */
-  if (sust_old_money &gt; total_money)
-    sust_old_money_count = 0;
-  else
-    sust_old_money_count++;
-  sust_old_money = total_money;
+    /* Money must be going up or the same. (ie can't build.) */
+    if (sust_old_money &gt; total_money)
+        sust_old_money_count = 0;
+    else
+        sust_old_money_count++;
+    sust_old_money = total_money;
 
-  /* population must be withing 2% of when it started. */
-  i = (housed_population + people_pool) - sust_old_population;
-  if (abs (i) &gt; (sust_old_population / 40)	/* 2.5%  */
-      || (housed_population + people_pool) &lt; SUST_MIN_POPULATION)
-    {
-      sust_old_population = (housed_population + people_pool);
-      sust_old_population_count = 0;
-    }
-  else
-    sust_old_population_count++;
+    /* population must be withing 2% of when it started. */
+    i = (housed_population + people_pool) - sust_old_population;
+    if (abs(i) &gt; (sust_old_population / 40)     /* 2.5%  */
+        ||(housed_population + people_pool) &lt; SUST_MIN_POPULATION) {
+        sust_old_population = (housed_population + people_pool);
+        sust_old_population_count = 0;
+    } else
+        sust_old_population_count++;
 
-  /* tech level must be going up or not fall more than 0.5% from it's
-     highest during the sus count
-  */
-  i = tech_level - sust_old_tech;
-  if (i &lt; 0 || tech_level &lt; SUST_MIN_TECH_LEVEL)
-    {
-      i = -i;
-      if ((i &gt; sust_old_tech / 100) || tech_level &lt; SUST_MIN_TECH_LEVEL)
-	{
-	  sust_old_tech_count = 0;
-	  sust_old_tech = tech_level;
-	}
-      else
-	sust_old_tech_count++;
+    /* tech level must be going up or not fall more than 0.5% from it's
+       highest during the sus count
+     */
+    i = tech_level - sust_old_tech;
+    if (i &lt; 0 || tech_level &lt; SUST_MIN_TECH_LEVEL) {
+        i = -i;
+        if ((i &gt; sust_old_tech / 100) || tech_level &lt; SUST_MIN_TECH_LEVEL) {
+            sust_old_tech_count = 0;
+            sust_old_tech = tech_level;
+        } else
+            sust_old_tech_count++;
+    } else {
+        sust_old_tech_count++;
+        sust_old_tech = tech_level;
     }
-  else
-    {
-      sust_old_tech_count++;
-      sust_old_tech = tech_level;
-    }
 
-  /* check fire cover only every three years */
-  if (total_time % (NUMOF_DAYS_IN_YEAR * 3) == 0)
-    {
-      if (sust_fire_cover () != 0)
-	sust_fire_count += 3;
-      else
-	sust_fire_count = 0;
+    /* check fire cover only every three years */
+    if (total_time % (NUMOF_DAYS_IN_YEAR * 3) == 0) {
+        if (sust_fire_cover() != 0)
+            sust_fire_count += 3;
+        else
+            sust_fire_count = 0;
 
     }
 }
 
-int
-sust_fire_cover (void)
+int sust_fire_cover(void)
 {
-  int x, y;
-  for (x = 0; x &lt; WORLD_SIDE_LEN; x++)
-    for (y = 0; y &lt; WORLD_SIDE_LEN; y++)
-      {
-	if (GROUP_IS_BARE(MP_GROUP(x,y))
-	    || MP_TYPE(x,y) == CST_USED
-	    || MP_GROUP(x,y) == GROUP_WATER
-	    || MP_GROUP(x,y) == GROUP_POWER_LINE
-	    || MP_GROUP(x,y) == GROUP_OREMINE
-	    || MP_GROUP(x,y) == GROUP_ROCKET
-	    || MP_GROUP(x,y) == GROUP_MONUMENT
-	    || MP_GROUP(x,y) == GROUP_BURNT)
-	  ;			/* do nothing */
+    int x, y;
+    for (x = 0; x &lt; WORLD_SIDE_LEN; x++)
+        for (y = 0; y &lt; WORLD_SIDE_LEN; y++) {
+            if (GROUP_IS_BARE(MP_GROUP(x, y))
+                || MP_TYPE(x, y) == CST_USED || MP_GROUP(x, y) == GROUP_WATER || MP_GROUP(x, y) == GROUP_POWER_LINE \
+                                || MP_GROUP(x, y) == GROUP_OREMINE || MP_GROUP(x, y) == GROUP_ROCKET \
+                                || MP_GROUP(x, y) == GROUP_MONUMENT || MP_GROUP(x, y) == GROUP_BURNT) ;/* do nothing */
 
-	else if ((MP_INFO(x,y).flags &amp; FLAG_FIRE_COVER) == 0)
-	  return (0);
-      }
-  return (1);
+            else if ((MP_INFO(x, y).flags &amp; FLAG_FIRE_COVER) == 0)
+                return (0);
+        }
+    return (1);
 }
 
-void 
-debug_mappoints (void)
+void debug_mappoints(void)
 {
-  int x, y;
-  for (x = 0; x &lt; WORLD_SIDE_LEN; x++) {
-    for (y = 0; y &lt; WORLD_SIDE_LEN; y++) {
-      if ((MP_TYPE(x,y) &lt; 0) || (MP_TYPE(x,y) &gt; 400)) {
-	printf (&quot;Error in mappoint %d %d (%d)\n&quot;, x, y, MP_TYPE(x,y));
-	exit(-1);
-      }
+    int x, y;
+    for (x = 0; x &lt; WORLD_SIDE_LEN; x++) {
+        for (y = 0; y &lt; WORLD_SIDE_LEN; y++) {
+            if ((MP_TYPE(x, y) &lt; 0) || (MP_TYPE(x, y) &gt; 400)) {
+                printf(&quot;Error in mappoint %d %d (%d)\n&quot;, x, y, MP_TYPE(x, y));
+                exit(-1);
+            }
+        }
     }
-  }
 }
 
-void
-initialize_tax_rates (void)
+void initialize_tax_rates(void)
 {
-  income_tax_rate = INCOME_TAX_RATE;
-  coal_tax_rate = COAL_TAX_RATE;
-  goods_tax_rate = GOODS_TAX_RATE;
-  dole_rate = DOLE_RATE;
-  transport_cost_rate = TRANSPORT_COST_RATE;
-  import_cost_rate = IM_PORT_COST_RATE;
+    income_tax_rate = INCOME_TAX_RATE;
+    coal_tax_rate = COAL_TAX_RATE;
+    goods_tax_rate = GOODS_TAX_RATE;
+    dole_rate = DOLE_RATE;
+    transport_cost_rate = TRANSPORT_COST_RATE;
+    import_cost_rate = IM_PORT_COST_RATE;
 }
-

Modified: trunk/src/lincity/simulate.h
===================================================================
--- trunk/src/lincity/simulate.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/simulate.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -6,8 +6,8 @@
 #ifndef __simulate_h__
 #define __simulate_h__
 
-void new_city (int* originx, int* originy, int random_village);
-void count_all_groups (int* group_count);
-void do_time_step (void);
+void new_city(int *originx, int *originy, int random_village);
+void count_all_groups(int *group_count);
+void do_time_step(void);
 
-#endif	/* __simulate_h__ */
+#endif /* __simulate_h__ */

Modified: trunk/src/lincity/stats.cpp
===================================================================
--- trunk/src/lincity/stats.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/stats.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -23,9 +23,9 @@
 int jobs_in_markets;
 int coal_in_markets;
 int goods_in_markets;
-int ore_in_markets; 
-int steel_in_markets; 
-int waste_in_markets; 
+int ore_in_markets;
+int steel_in_markets;
+int waste_in_markets;
 
 /* Monthly accumulators */
 int tfood_in_markets;
@@ -40,22 +40,22 @@
 int tunemployed_population;
 
 /* yearly */
-int income_tax; 
-int coal_tax; 
-int goods_tax; 
-int export_tax; 
+int income_tax;
+int coal_tax;
+int goods_tax;
+int export_tax;
 int import_cost;
-int unemployment_cost; 
-int transport_cost; 
-int windmill_cost; 
-int university_cost; 
-int recycle_cost; 
-int deaths_cost; 
-int health_cost; 
-int rocket_pad_cost; 
-int school_cost; 
-int fire_cost; 
-int cricket_cost; 
+int unemployment_cost;
+int transport_cost;
+int windmill_cost;
+int university_cost;
+int recycle_cost;
+int deaths_cost;
+int health_cost;
+int rocket_pad_cost;
+int school_cost;
+int fire_cost;
+int cricket_cost;
 int other_cost;
 
 /* Last Year's totals */
@@ -81,15 +81,12 @@
 /* Averaging variables */
 int data_last_month;
 
-
 /* ---------------------------------------------------------------------- *
  * Private Function Prototypes
  * ---------------------------------------------------------------------- */
 void inventory_market(int x, int y);
 
-
-void
-init_daily(void)
+void init_daily(void)
 {
     population = 0;
     starving_population = 0;
@@ -102,11 +99,10 @@
     steel_in_markets = 0;
 }
 
-void
-init_monthly(void)
+void init_monthly(void)
 {
     data_last_month = 0;
-    
+
     tpopulation = 0;
     tstarving_population = 0;
     tfood_in_markets = 0;
@@ -119,8 +115,7 @@
     unnat_deaths = 0;
 }
 
-void
-init_yearly(void)
+void init_yearly(void)
 {
     income_tax = 0;
     coal_tax = 0;
@@ -140,8 +135,7 @@
     cricket_cost = 0;
 }
 
-void
-init_lastyear(void)
+void init_lastyear(void)
 {
     ly_income_tax = 0;
     ly_coal_tax = 0;
@@ -163,27 +157,24 @@
     ly_fire_cost = 0;
 }
 
-void
-inventory(int x, int y)
+void inventory(int x, int y)
 {
 
-    switch(get_group_of_type(MP_TYPE(x,y))) {
+    switch (get_group_of_type(MP_TYPE(x, y))) {
 
-    case GROUP_MARKET: 
-	inventory_market(x, y); 
-	break;
-    
-    default: {
-	printf(&quot;Default in inventory(%d,%d): got %d\n&quot;, 
-	    x, y, get_group_of_type(MP_TYPE(x,y)));
-	break;
-    }
+    case GROUP_MARKET:
+        inventory_market(x, y);
+        break;
 
+    default:{
+            printf(&quot;Default in inventory(%d,%d): got %d\n&quot;, x, y, get_group_of_type(MP_TYPE(x, y)));
+            break;
+        }
+
     }
 }
 
-void
-init_inventory(void)
+void init_inventory(void)
 {
     init_daily();
     init_monthly();
@@ -191,27 +182,24 @@
     init_lastyear();
 }
 
-void
-inventory_market(int x, int y) 
+void inventory_market(int x, int y)
 {
-    food_in_markets += MP_INFO(x,y).int_1;
-    jobs_in_markets += MP_INFO(x,y).int_2;
-    coal_in_markets += MP_INFO(x,y).int_3;
-    goods_in_markets += MP_INFO(x,y).int_4;
-    ore_in_markets += MP_INFO(x,y).int_5;
-    steel_in_markets += MP_INFO(x,y).int_6;
-    waste_in_markets += MP_INFO(x,y).int_7;
+    food_in_markets += MP_INFO(x, y).int_1;
+    jobs_in_markets += MP_INFO(x, y).int_2;
+    coal_in_markets += MP_INFO(x, y).int_3;
+    goods_in_markets += MP_INFO(x, y).int_4;
+    ore_in_markets += MP_INFO(x, y).int_5;
+    steel_in_markets += MP_INFO(x, y).int_6;
+    waste_in_markets += MP_INFO(x, y).int_7;
 }
 
-
 /* XXX: WCK:  Why oh why must we divide by arbitrary values, below? */
 /* If this is fixed, make sure to fix it in pbar also! */
 
-void
-add_daily_to_monthly(void)
+void add_daily_to_monthly(void)
 {
     data_last_month++;
-    
+
     tpopulation += population;
     tstarving_population += starving_population;
     tfood_in_markets += food_in_markets / 1000;

Modified: trunk/src/lincity/stats.h
===================================================================
--- trunk/src/lincity/stats.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/stats.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -6,7 +6,7 @@
  * ---------------------------------------------------------------------- */
 
 #ifndef __stats_h__
-#define __stats_h__ 
+#define __stats_h__
 
 /* Statistics, Accumulators and Counters all reside here */
 
@@ -29,63 +29,63 @@
 */
 
 /* daily */
-extern int food_in_markets; 
-extern int jobs_in_markets; 
-extern int coal_in_markets; 
-extern int goods_in_markets; 
-extern int ore_in_markets; 
-extern int steel_in_markets; 
-extern int waste_in_markets; 
+extern int food_in_markets;
+extern int jobs_in_markets;
+extern int coal_in_markets;
+extern int goods_in_markets;
+extern int ore_in_markets;
+extern int steel_in_markets;
+extern int waste_in_markets;
 
 /* monthly */
-extern int tfood_in_markets; 
-extern int tjobs_in_markets; 
-extern int tcoal_in_markets; 
-extern int tgoods_in_markets; 
-extern int tore_in_markets; 
-extern int tsteel_in_markets; 
+extern int tfood_in_markets;
+extern int tjobs_in_markets;
+extern int tcoal_in_markets;
+extern int tgoods_in_markets;
+extern int tore_in_markets;
+extern int tsteel_in_markets;
 extern int twaste_in_markets;
-extern int tpopulation; 
-extern int tstarving_population; 
-extern int tunemployed_population; 
+extern int tpopulation;
+extern int tstarving_population;
+extern int tunemployed_population;
 extern int twaste_in_markets;
 
 /* yearly */
-extern int income_tax; 
-extern int coal_tax; 
-extern int goods_tax; 
-extern int export_tax; 
+extern int income_tax;
+extern int coal_tax;
+extern int goods_tax;
+extern int export_tax;
 extern int import_cost;
-extern int unemployment_cost; 
-extern int transport_cost; 
-extern int windmill_cost; 
-extern int university_cost; 
-extern int recycle_cost; 
-extern int deaths_cost; 
-extern int health_cost; 
-extern int rocket_pad_cost; 
-extern int school_cost; 
-extern int fire_cost; 
-extern int cricket_cost; 
+extern int unemployment_cost;
+extern int transport_cost;
+extern int windmill_cost;
+extern int university_cost;
+extern int recycle_cost;
+extern int deaths_cost;
+extern int health_cost;
+extern int rocket_pad_cost;
+extern int school_cost;
+extern int fire_cost;
+extern int cricket_cost;
 extern int other_cost;
 
 /* yearly */
-extern int ly_income_tax; 
-extern int ly_coal_tax; 
-extern int ly_goods_tax; 
-extern int ly_export_tax; 
-extern int ly_import_cost; 
-extern int ly_other_cost; 
-extern int ly_unemployment_cost; 
-extern int ly_transport_cost; 
-extern int ly_fire_cost; 
-extern int ly_university_cost; 
-extern int ly_recycle_cost; 
-extern int ly_school_cost; 
-extern int ly_deaths_cost; 
-extern int ly_health_cost; 
-extern int ly_rocket_pad_cost; 
-extern int ly_interest; 
+extern int ly_income_tax;
+extern int ly_coal_tax;
+extern int ly_goods_tax;
+extern int ly_export_tax;
+extern int ly_import_cost;
+extern int ly_other_cost;
+extern int ly_unemployment_cost;
+extern int ly_transport_cost;
+extern int ly_fire_cost;
+extern int ly_university_cost;
+extern int ly_recycle_cost;
+extern int ly_school_cost;
+extern int ly_deaths_cost;
+extern int ly_health_cost;
+extern int ly_rocket_pad_cost;
+extern int ly_interest;
 extern int ly_windmill_cost;
 extern int ly_cricket_cost;
 

Modified: trunk/src/lincity/transport.cpp
===================================================================
--- trunk/src/lincity/transport.cpp	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/transport.cpp	2007-11-25 19:15:34 UTC (rev 1286)
@@ -11,7 +11,7 @@
 #include &quot;lin-city.h&quot;
 #include &quot;transport.h&quot;
 #include &quot;power.h&quot;
-#include &quot;stats.h&quot; /* for transport_cost */
+#include &quot;stats.h&quot;              /* for transport_cost */
 
 /* ---------------------------------------------------------------------
    For track, road and rail:
@@ -25,9 +25,7 @@
    int_7 contains the amount of waste
   --------------------------------------------------------------------- */
 
-void
-general_transport (Map_Point_Info *minfo, int *pol,
-		   int max_waste, int *waste_count)
+void general_transport(Map_Point_Info * minfo, int *pol, int max_waste, int *waste_count)
 {
     int tot, av, *base, xm1, xp1, ym1, yp1;
 
@@ -50,186 +48,184 @@
      */
 
     base = &amp;minfo-&gt;int_1;
-    switch (minfo-&gt;flags &amp; 0x0F)
-    {
+    switch (minfo-&gt;flags &amp; 0x0F) {
     case 0:
-	return;
+        return;
 
-    case 1:			/* inlined t_av_l() -- (ThMO) */
-	xm1 = &amp;minfo[-WORLD_SIDE_LEN].int_1 - base;
-	do {
-	    tot = *base + base[xm1];
-	    av = tot / 2;
-	    base[xm1] = av;
-	    *base++ = av + tot % 2;
-	} while (base &lt;= &amp;minfo-&gt;int_7);
-	break;
+    case 1:                    /* inlined t_av_l() -- (ThMO) */
+        xm1 = &amp;minfo[-WORLD_SIDE_LEN].int_1 - base;
+        do {
+            tot = *base + base[xm1];
+            av = tot / 2;
+            base[xm1] = av;
+            *base++ = av + tot % 2;
+        } while (base &lt;= &amp;minfo-&gt;int_7);
+        break;
 
-    case 2:			/* inlined t_av_u() -- (ThMO) */
-	ym1 = &amp;minfo[-1].int_1 - base;
-	do {
-	    tot = *base + base[ym1];
-	    av = tot / 2;
-	    base[ym1] = av;
-	    *base++ = av + tot % 2;
-	} while (base &lt;= &amp;minfo-&gt;int_7);
-	break;
+    case 2:                    /* inlined t_av_u() -- (ThMO) */
+        ym1 = &amp;minfo[-1].int_1 - base;
+        do {
+            tot = *base + base[ym1];
+            av = tot / 2;
+            base[ym1] = av;
+            *base++ = av + tot % 2;
+        } while (base &lt;= &amp;minfo-&gt;int_7);
+        break;
 
-    case 3:			/* inlined t_av_lu() -- (ThMO) */
-	xm1 = &amp;minfo[-WORLD_SIDE_LEN].int_1 - base;
-	ym1 = &amp;minfo[-1].int_1 - base;
-	do {
-	    tot = *base + base[xm1] + base[ym1];
-	    av = tot / 3;
-	    base[xm1] = base[ym1] = av;
-	    *base++ = av + tot % 3;
-	} while (base &lt;= &amp;minfo-&gt;int_7);
-	break;
+    case 3:                    /* inlined t_av_lu() -- (ThMO) */
+        xm1 = &amp;minfo[-WORLD_SIDE_LEN].int_1 - base;
+        ym1 = &amp;minfo[-1].int_1 - base;
+        do {
+            tot = *base + base[xm1] + base[ym1];
+            av = tot / 3;
+            base[xm1] = base[ym1] = av;
+            *base++ = av + tot % 3;
+        } while (base &lt;= &amp;minfo-&gt;int_7);
+        break;
 
-    case 4:			/* inlined t_av_r() -- (ThMO) */
-	xp1 = &amp;minfo[WORLD_SIDE_LEN].int_1 - base;
-	do {
-	    tot = *base + base[xp1];
-	    av = tot / 2;
-	    base[xp1] = av;
-	    *base++ = av + tot % 2;
-	} while (base &lt;= &amp;minfo-&gt;int_7);
-	break;
+    case 4:                    /* inlined t_av_r() -- (ThMO) */
+        xp1 = &amp;minfo[WORLD_SIDE_LEN].int_1 - base;
+        do {
+            tot = *base + base[xp1];
+            av = tot / 2;
+            base[xp1] = av;
+            *base++ = av + tot % 2;
+        } while (base &lt;= &amp;minfo-&gt;int_7);
+        break;
 
-    case 5:			/* inlined t_av_lr() -- (ThMO) */
-	xm1 = &amp;minfo[-WORLD_SIDE_LEN].int_1 - base;
-	xp1 = &amp;minfo[WORLD_SIDE_LEN].int_1 - base;
-	do {
-	    tot = *base + base[xm1] + base[xp1];
-	    av = tot / 3;
-	    base[xm1] = base[xp1] = av;
-	    *base++ = av + tot % 3;
-	} while (base &lt;= &amp;minfo-&gt;int_7);
-	break;
+    case 5:                    /* inlined t_av_lr() -- (ThMO) */
+        xm1 = &amp;minfo[-WORLD_SIDE_LEN].int_1 - base;
+        xp1 = &amp;minfo[WORLD_SIDE_LEN].int_1 - base;
+        do {
+            tot = *base + base[xm1] + base[xp1];
+            av = tot / 3;
+            base[xm1] = base[xp1] = av;
+            *base++ = av + tot % 3;
+        } while (base &lt;= &amp;minfo-&gt;int_7);
+        break;
 
-    case 6:			/* inline t_av_ur() -- (ThMO) */
-	ym1 = &amp;minfo[-1].int_1 - base;
-	xp1 = &amp;minfo[WORLD_SIDE_LEN].int_1 - base;
-	do {
-	    tot = *base + base[ym1] + base[xp1];
-	    av = tot / 3;
-	    base[ym1] = base[xp1] = av;
-	    *base++ = av + tot % 3;
-	} while (base &lt;= &amp;minfo-&gt;int_7);
-	break;
+    case 6:                    /* inline t_av_ur() -- (ThMO) */
+        ym1 = &amp;minfo[-1].int_1 - base;
+        xp1 = &amp;minfo[WORLD_SIDE_LEN].int_1 - base;
+        do {
+            tot = *base + base[ym1] + base[xp1];
+            av = tot / 3;
+            base[ym1] = base[xp1] = av;
+            *base++ = av + tot % 3;
+        } while (base &lt;= &amp;minfo-&gt;int_7);
+        break;
 
-    case 7:			/* inlined t_av_lur() -- (ThMO) */
-	xm1 = &amp;minfo[-WORLD_SIDE_LEN].int_1 - base;
-	ym1 = &amp;minfo[-1].int_1 - base;
-	xp1 = &amp;minfo[WORLD_SIDE_LEN].int_1 - base;
-	do {
-	    tot = *base + base[xm1] + base[ym1] + base[xp1];
-	    av = tot / 4;
-	    base[xm1] = base[ym1] = base[xp1] = av;
-	    *base++ = av + tot % 4;
-	} while (base &lt;= &amp;minfo-&gt;int_7);
-	break;
+    case 7:                    /* inlined t_av_lur() -- (ThMO) */
+        xm1 = &amp;minfo[-WORLD_SIDE_LEN].int_1 - base;
+        ym1 = &amp;minfo[-1].int_1 - base;
+        xp1 = &amp;minfo[WORLD_SIDE_LEN].int_1 - base;
+        do {
+            tot = *base + base[xm1] + base[ym1] + base[xp1];
+            av = tot / 4;
+            base[xm1] = base[ym1] = base[xp1] = av;
+            *base++ = av + tot % 4;
+        } while (base &lt;= &amp;minfo-&gt;int_7);
+        break;
 
-    case 8:			/* inlined t_av_d() -- (ThMO) */
-	yp1 = &amp;minfo[1].int_1 - base;
-	do {
-	    tot = *base + base[yp1];
-	    av = tot / 2;
-	    base[yp1] = av;
-	    *base++ = av + tot % 2;
-	} while (base &lt;= &amp;minfo-&gt;int_7);
-	break;
+    case 8:                    /* inlined t_av_d() -- (ThMO) */
+        yp1 = &amp;minfo[1].int_1 - base;
+        do {
+            tot = *base + base[yp1];
+            av = tot / 2;
+            base[yp1] = av;
+            *base++ = av + tot % 2;
+        } while (base &lt;= &amp;minfo-&gt;int_7);
+        break;
 
-    case 9:			/* inlined t_av_ld() -- (ThMO) */
-	xm1 = &amp;minfo[-WORLD_SIDE_LEN].int_1 - base;
-	yp1 = &amp;minfo[1].int_1 - base;
-	do {
-	    tot = *base + base[xm1] + base[yp1];
-	    av = tot / 3;
-	    base[xm1] = base[yp1] = av;
-	    *base++ = av + tot % 3;
-	} while (base &lt;= &amp;minfo-&gt;int_7);
-	break;
+    case 9:                    /* inlined t_av_ld() -- (ThMO) */
+        xm1 = &amp;minfo[-WORLD_SIDE_LEN].int_1 - base;
+        yp1 = &amp;minfo[1].int_1 - base;
+        do {
+            tot = *base + base[xm1] + base[yp1];
+            av = tot / 3;
+            base[xm1] = base[yp1] = av;
+            *base++ = av + tot % 3;
+        } while (base &lt;= &amp;minfo-&gt;int_7);
+        break;
 
-    case 10:			/* inlined t_av_ud() -- (ThMO) */
-	ym1 = &amp;minfo[-1].int_1 - base;
-	yp1 = &amp;minfo[1].int_1 - base;
-	do {
-	    tot = *base + base[ym1] + base[yp1];
-	    av = tot / 3;
-	    base[ym1] = base[yp1] = av;
-	    *base++ = av + tot % 3;
-	} while (base &lt;= &amp;minfo-&gt;int_7);
-	break;
+    case 10:                   /* inlined t_av_ud() -- (ThMO) */
+        ym1 = &amp;minfo[-1].int_1 - base;
+        yp1 = &amp;minfo[1].int_1 - base;
+        do {
+            tot = *base + base[ym1] + base[yp1];
+            av = tot / 3;
+            base[ym1] = base[yp1] = av;
+            *base++ = av + tot % 3;
+        } while (base &lt;= &amp;minfo-&gt;int_7);
+        break;
 
-    case 11:			/* inlined t_av_lud() -- (ThMO) */
-	xm1 = &amp;minfo[-WORLD_SIDE_LEN].int_1 - base;
-	ym1 = &amp;minfo[-1].int_1 - base;
-	yp1 = &amp;minfo[1].int_1 - base;
-	do {
-	    tot = *base + base[xm1] + base[ym1] + base[yp1];
-	    av = tot / 4;
-	    base[xm1] = base[ym1] = base[yp1] = av;
-	    *base++ = av + tot % 4;
-	} while (base &lt;= &amp;minfo-&gt;int_7);
-	break;
+    case 11:                   /* inlined t_av_lud() -- (ThMO) */
+        xm1 = &amp;minfo[-WORLD_SIDE_LEN].int_1 - base;
+        ym1 = &amp;minfo[-1].int_1 - base;
+        yp1 = &amp;minfo[1].int_1 - base;
+        do {
+            tot = *base + base[xm1] + base[ym1] + base[yp1];
+            av = tot / 4;
+            base[xm1] = base[ym1] = base[yp1] = av;
+            *base++ = av + tot % 4;
+        } while (base &lt;= &amp;minfo-&gt;int_7);
+        break;
 
-    case 12:			/* inlined t_av_rd() -- (ThMO) */
-	xp1 = &amp;minfo[WORLD_SIDE_LEN].int_1 - base;
-	yp1 = &amp;minfo[1].int_1 - base;
-	do {
-	    tot = *base + base[xp1] + base[yp1];
-	    av = tot / 3;
-	    base[xp1] = base[yp1] = av;
-	    *base++ = av + tot % 3;
-	} while (base &lt;= &amp;minfo-&gt;int_7);
-	break;
+    case 12:                   /* inlined t_av_rd() -- (ThMO) */
+        xp1 = &amp;minfo[WORLD_SIDE_LEN].int_1 - base;
+        yp1 = &amp;minfo[1].int_1 - base;
+        do {
+            tot = *base + base[xp1] + base[yp1];
+            av = tot / 3;
+            base[xp1] = base[yp1] = av;
+            *base++ = av + tot % 3;
+        } while (base &lt;= &amp;minfo-&gt;int_7);
+        break;
 
-    case 13:			/* inlined t_av_lrd() -- (ThMO) */
-	xm1 = &amp;minfo[-WORLD_SIDE_LEN].int_1 - base;
-	xp1 = &amp;minfo[WORLD_SIDE_LEN].int_1 - base;
-	yp1 = &amp;minfo[1].int_1 - base;
-	do {
-	    tot = *base + base[xm1] + base[xp1] + base[yp1];
-	    av = tot / 4;
-	    base[xm1] = base[xp1] = base[yp1] = av;
-	    *base++ = av + tot % 4;
-	} while (base &lt;= &amp;minfo-&gt;int_7);
-	break;
+    case 13:                   /* inlined t_av_lrd() -- (ThMO) */
+        xm1 = &amp;minfo[-WORLD_SIDE_LEN].int_1 - base;
+        xp1 = &amp;minfo[WORLD_SIDE_LEN].int_1 - base;
+        yp1 = &amp;minfo[1].int_1 - base;
+        do {
+            tot = *base + base[xm1] + base[xp1] + base[yp1];
+            av = tot / 4;
+            base[xm1] = base[xp1] = base[yp1] = av;
+            *base++ = av + tot % 4;
+        } while (base &lt;= &amp;minfo-&gt;int_7);
+        break;
 
-    case 14:			/* inlined t_av_urd() -- (ThMO) */
-	ym1 = &amp;minfo[-1].int_1 - base;
-	xp1 = &amp;minfo[WORLD_SIDE_LEN].int_1 - base;
-	yp1 = &amp;minfo[1].int_1 - base;
-	do {
-	    tot = *base + base[ym1] + base[xp1] + base[yp1];
-	    av = tot / 4;
-	    base[ym1] = base[xp1] = base[yp1] = av;
-	    *base++ = av + tot % 4;
-	} while (base &lt;= &amp;minfo-&gt;int_7);
-	break;
+    case 14:                   /* inlined t_av_urd() -- (ThMO) */
+        ym1 = &amp;minfo[-1].int_1 - base;
+        xp1 = &amp;minfo[WORLD_SIDE_LEN].int_1 - base;
+        yp1 = &amp;minfo[1].int_1 - base;
+        do {
+            tot = *base + base[ym1] + base[xp1] + base[yp1];
+            av = tot / 4;
+            base[ym1] = base[xp1] = base[yp1] = av;
+            *base++ = av + tot % 4;
+        } while (base &lt;= &amp;minfo-&gt;int_7);
+        break;
 
-    case 15:			/* inlined t_av_lurd() -- (ThMO) */
-	xm1 = &amp;minfo[-WORLD_SIDE_LEN].int_1 - base;
-	ym1 = &amp;minfo[-1].int_1 - base;
-	xp1 = &amp;minfo[WORLD_SIDE_LEN].int_1 - base;
-	yp1 = &amp;minfo[1].int_1 - base;
-	do {
-	    tot = *base + base[xm1] + base[ym1] + base[xp1] + base[yp1];
-	    av = tot / 5;
-	    base[xm1] = base[ym1] = base[xp1] = base[yp1] = av;
-	    *base++ = av + tot % 5;
-	} while (base &lt;= &amp;minfo-&gt;int_7);
-	break;
+    case 15:                   /* inlined t_av_lurd() -- (ThMO) */
+        xm1 = &amp;minfo[-WORLD_SIDE_LEN].int_1 - base;
+        ym1 = &amp;minfo[-1].int_1 - base;
+        xp1 = &amp;minfo[WORLD_SIDE_LEN].int_1 - base;
+        yp1 = &amp;minfo[1].int_1 - base;
+        do {
+            tot = *base + base[xm1] + base[ym1] + base[xp1] + base[yp1];
+            av = tot / 5;
+            base[xm1] = base[ym1] = base[xp1] = base[yp1] = av;
+            *base++ = av + tot % 5;
+        } while (base &lt;= &amp;minfo-&gt;int_7);
+        break;
     }
     if (*--base &gt;= max_waste) {
-	*base -= WASTE_BURN_ON_TRANSPORT;
-	++*pol;
-	if (*waste_count &gt; TRANSPORT_BURN_WASTE_COUNT) {
-	    *waste_count = 0;
-	} else {
-	    ++ * waste_count;
-	}
+        *base -= WASTE_BURN_ON_TRANSPORT;
+        ++*pol;
+        if (*waste_count &gt; TRANSPORT_BURN_WASTE_COUNT) {
+            *waste_count = 0;
+        } else {
+            ++*waste_count;
+        }
     }
 }
-

Modified: trunk/src/lincity/transport.h
===================================================================
--- trunk/src/lincity/transport.h	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/lincity/transport.h	2007-11-25 19:15:34 UTC (rev 1286)
@@ -15,5 +15,4 @@
  (MP_GROUP(x,y) == GROUP_RAIL) || \
  (MP_GROUP(x,y) == GROUP_POWER_LINE))
 
-
 #endif

Deleted: trunk/src/tools/Lindent-2.6.23.8.sh
===================================================================
--- trunk/src/tools/Lindent-2.6.23.8.sh	2007-11-25 19:00:26 UTC (rev 1285)
+++ trunk/src/tools/Lindent-2.6.23.8.sh	2007-11-25 19:15:34 UTC (rev 1286)
@@ -1,11 +0,0 @@
-#!/bin/sh
-# The original tiny script is use to put linux code in corformance with
-# the Linux Coding Style. You should read it :-)
-#indent -npro -kr -i8 -ts8 -sob -l80 -ss -ncs -cp1 &quot;$@&quot;
-
-# However for Lincity-ng, due to
-# - C++ code which tends to have longs lines
-# - NG is graphic so run on rather good hardware =&gt; we can afford longer line (120) than linux kernel (80)
-# - indent 8 is too much for existing code =&gt; indent is 4
-# - tabs causes trouble to some we use spaces intead of tabs.
-indent -npro -kr -i4 --no-tabs -sob -l120 -ss -ncs -cp1 &quot;$@&quot;

Copied: trunk/src/tools/Lindent.sh (from rev 1285, trunk/src/tools/Lindent-2.6.23.8.sh)


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000213.html">[Lincity-ng-commit] r1285 - in trunk: . src/tools
</A></li>
	<LI>Next message: <A HREF="000214.html">[Lincity-ng-commit] r1287 - in trunk/src/lincity: . modules
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#362">[ date ]</a>
              <a href="thread.html#362">[ thread ]</a>
              <a href="subject.html#362">[ subject ]</a>
              <a href="author.html#362">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/lincity-ng-commit">More information about the Lincity-ng-commit
mailing list</a><br>
</body></html>
